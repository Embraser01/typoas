import {
  DefaultError,
  QueryClient,
  UseMutationOptions,
  useMutation,
  UseMutationResult,
} from '@tanstack/react-query';
import {
  BaseFetcherData,
  Context,
  ok,
  SuccessfulStatus,
} from '@typoas/runtime';
import { useApiContext } from './api-context';
import { TypoasFuncStatusType, TypoasReturnType } from './types';
import { getQueryFunctionKey } from './func-names';

export type TypoasMutationVariables<
  Func extends TypoasMutationFunction<FetcherData>,
  FetcherData extends BaseFetcherData = BaseFetcherData,
> = FetcherData extends Parameters<Func>[3]
  ? [Parameters<Func>[1], Parameters<Func>[2]]
  : [Parameters<Func>[1]];

/**
 * Combined options usable in useMutation hook.
 */
export type TypoasMutationOptions<
  Func extends TypoasMutationFunction<FetcherData>,
  S extends TypoasFuncStatusType<Func>,
  TError = DefaultError,
  FetcherData extends BaseFetcherData = BaseFetcherData,
> = UseMutationOptions<
  TypoasReturnType<Func, S>,
  TError,
  TypoasMutationVariables<Func>
> & {
  fetcherData?: FetcherData;
  successStatus?: S;
};

/* eslint-disable @typescript-eslint/no-explicit-any */
export type TypoasMutationFunction<FetcherData extends BaseFetcherData> =
  | ((
      ctx: Context<never, FetcherData>,
      params: any,
      body: any,
      opts?: FetcherData,
    ) => Promise<any>)
  | ((
      ctx: Context<never, FetcherData>,
      params: any,
      opts?: FetcherData,
    ) => Promise<any>);
/* eslint-enable @typescript-eslint/no-explicit-any */

/**
 * Create a React hook for a specific mutation.
 *
 * The returned hook is a wrapper around the useMutation hook from react-query.
 * It forces the variables type of the mutate/mutateAsync function.
 *
 * @param func Typoas generated function
 * @param baseOptions Options applied to every usage of this hook. May be overridden by options passed to the hook.
 * @param context Optional default context to use for the query. If not provided, you MUST use the ApiContextProvider.
 */
export function createMutationHook<
  Func extends TypoasMutationFunction<FetcherData>,
  S extends TypoasFuncStatusType<Func> = TypoasFuncStatusType<Func> &
    SuccessfulStatus,
  TError = unknown,
  FetcherData extends BaseFetcherData = BaseFetcherData,
>(
  func: Func,
  baseOptions: Omit<
    TypoasMutationOptions<Func, S, TError, FetcherData>,
    'mutationFn'
  > = {},
  context?: Context<never, FetcherData>,
): (
  options: Omit<
    TypoasMutationOptions<Func, S, TError, FetcherData>,
    'mutationFn' | 'successStatus'
  >,
  queryClient?: QueryClient,
) => UseMutationResult<
  TypoasReturnType<Func, S>,
  TError,
  TypoasMutationVariables<Func>
> {
  return (options, queryClient) => {
    const { context: localContext } = useApiContext();

    return useMutation(
      {
        ...baseOptions,
        ...options,
        // Override the mutation key to differentiate between multiple typoas functions
        mutationKey: options.mutationKey
          ? [getQueryFunctionKey(func), ...options.mutationKey]
          : undefined,
        mutationFn: ([params, body]) => {
          const ctx = localContext || context;
          if (!ctx) {
            throw new Error(
              'No context provided for query, use ApiContextProvider or provide a context in createQueryHook',
            );
          }

          // This works because functions generated by typoas are either 3 or 4 parameters long
          if (func.length === 3) {
            return ok(
              func(ctx, params, options.fetcherData ?? baseOptions.fetcherData),
              baseOptions.successStatus,
            );
          }
          return ok(
            func(
              ctx,
              params,
              body,
              options.fetcherData ?? baseOptions.fetcherData,
            ),
            baseOptions.successStatus,
          );
        },
      },
      queryClient,
    );
  };
}
