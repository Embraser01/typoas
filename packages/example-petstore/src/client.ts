import * as r from '@typoas/runtime';
export type SimpleUser = {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string | null;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: string;
  site_admin: boolean;
  starred_at?: string;
} | null;
export type Integration = {
  id: number;
  slug?: string;
  node_id: string;
  owner: any;
  name: string;
  description: string | null;
  external_url: string;
  html_url: string;
  created_at: Date;
  updated_at: Date;
  permissions: {
    issues?: string;
    checks?: string;
    metadata?: string;
    contents?: string;
    deployments?: string;
  } & {
    [key: string]: string;
  };
  events: string[];
  installations_count?: number;
  client_id?: string;
  client_secret?: string;
  webhook_secret?: string;
  pem?: string;
} & {
  [key: string]: any;
};
export type BasicError = {
  message?: string;
  documentation_url?: string;
};
export type ValidationErrorSimple = {
  message: string;
  documentation_url: string;
  errors?: string[];
};
export type WebhookConfigUrl = string;
export type WebhookConfigContentType = string;
export type WebhookConfigSecret = string;
export type WebhookConfigInsecureSsl = string;
export type WebhookConfig = {
  url?: WebhookConfigUrl;
  content_type?: WebhookConfigContentType;
  secret?: WebhookConfigSecret;
  insecure_ssl?: WebhookConfigInsecureSsl;
};
export type Enterprise = {
  description?: string | null;
  html_url: string;
  website_url?: string | null;
  id: number;
  node_id: string;
  name: string;
  slug: string;
  created_at: Date | null;
  updated_at: Date | null;
  avatar_url: string;
};
export type Installation = {
  id: number;
  account: (SimpleUser | Enterprise) | null;
  repository_selection: 'all' | 'selected';
  access_tokens_url: string;
  repositories_url: string;
  html_url: string;
  app_id: number;
  target_id: number;
  target_type: string;
  permissions: {
    deployments?: string;
    checks?: string;
    metadata?: string;
    contents?: string;
    pull_requests?: string;
    statuses?: string;
    issues?: string;
    organization_administration?: string;
  };
  events: string[];
  created_at: Date;
  updated_at: Date;
  single_file_name: string | null;
  has_multiple_single_files?: boolean;
  single_file_paths?: string[];
  app_slug: string;
  suspended_by?: any;
  suspended_at?: Date | null;
  contact_email?: string | null;
};
export type AppPermissions = {
  actions?: 'read' | 'write';
  administration?: 'read' | 'write';
  checks?: 'read' | 'write';
  content_references?: 'read' | 'write';
  contents?: 'read' | 'write';
  deployments?: 'read' | 'write';
  environments?: 'read' | 'write';
  issues?: 'read' | 'write';
  metadata?: 'read' | 'write';
  packages?: 'read' | 'write';
  pages?: 'read' | 'write';
  pull_requests?: 'read' | 'write';
  repository_hooks?: 'read' | 'write';
  repository_projects?: 'read' | 'write' | 'admin';
  secret_scanning_alerts?: 'read' | 'write';
  secrets?: 'read' | 'write';
  security_events?: 'read' | 'write';
  single_file?: 'read' | 'write';
  statuses?: 'read' | 'write';
  vulnerability_alerts?: 'read';
  workflows?: 'write';
  members?: 'read' | 'write';
  organization_administration?: 'read' | 'write';
  organization_hooks?: 'read' | 'write';
  organization_plan?: 'read';
  organization_projects?: 'read' | 'write' | 'admin';
  organization_secrets?: 'read' | 'write';
  organization_self_hosted_runners?: 'read' | 'write';
  organization_user_blocking?: 'read' | 'write';
  team_discussions?: 'read' | 'write';
};
export type LicenseSimple = {
  key: string;
  name: string;
  url: string | null;
  spdx_id: string | null;
  node_id: string;
  html_url?: string;
};
export type Repository = {
  id: number;
  node_id: string;
  name: string;
  full_name: string;
  license: any;
  forks: number;
  permissions?: {
    admin: boolean;
    pull: boolean;
    triage?: boolean;
    push: boolean;
    maintain?: boolean;
  };
  owner: any;
  private: boolean;
  html_url: string;
  description: string | null;
  fork: boolean;
  url: string;
  archive_url: string;
  assignees_url: string;
  blobs_url: string;
  branches_url: string;
  collaborators_url: string;
  comments_url: string;
  commits_url: string;
  compare_url: string;
  contents_url: string;
  contributors_url: string;
  deployments_url: string;
  downloads_url: string;
  events_url: string;
  forks_url: string;
  git_commits_url: string;
  git_refs_url: string;
  git_tags_url: string;
  git_url: string;
  issue_comment_url: string;
  issue_events_url: string;
  issues_url: string;
  keys_url: string;
  labels_url: string;
  languages_url: string;
  merges_url: string;
  milestones_url: string;
  notifications_url: string;
  pulls_url: string;
  releases_url: string;
  ssh_url: string;
  stargazers_url: string;
  statuses_url: string;
  subscribers_url: string;
  subscription_url: string;
  tags_url: string;
  teams_url: string;
  trees_url: string;
  clone_url: string;
  mirror_url: string | null;
  hooks_url: string;
  svn_url: string;
  homepage: string | null;
  language: string | null;
  forks_count: number;
  stargazers_count: number;
  watchers_count: number;
  size: number;
  default_branch: string;
  open_issues_count: number;
  is_template?: boolean;
  topics?: string[];
  has_issues: boolean;
  has_projects: boolean;
  has_wiki: boolean;
  has_pages: boolean;
  has_downloads: boolean;
  archived: boolean;
  disabled: boolean;
  visibility?: string;
  pushed_at: Date | null;
  created_at: Date | null;
  updated_at: Date | null;
  allow_rebase_merge?: boolean;
  template_repository?: {
    id?: number;
    node_id?: string;
    name?: string;
    full_name?: string;
    owner?: {
      login?: string;
      id?: number;
      node_id?: string;
      avatar_url?: string;
      gravatar_id?: string;
      url?: string;
      html_url?: string;
      followers_url?: string;
      following_url?: string;
      gists_url?: string;
      starred_url?: string;
      subscriptions_url?: string;
      organizations_url?: string;
      repos_url?: string;
      events_url?: string;
      received_events_url?: string;
      type?: string;
      site_admin?: boolean;
    };
    private?: boolean;
    html_url?: string;
    description?: string;
    fork?: boolean;
    url?: string;
    archive_url?: string;
    assignees_url?: string;
    blobs_url?: string;
    branches_url?: string;
    collaborators_url?: string;
    comments_url?: string;
    commits_url?: string;
    compare_url?: string;
    contents_url?: string;
    contributors_url?: string;
    deployments_url?: string;
    downloads_url?: string;
    events_url?: string;
    forks_url?: string;
    git_commits_url?: string;
    git_refs_url?: string;
    git_tags_url?: string;
    git_url?: string;
    issue_comment_url?: string;
    issue_events_url?: string;
    issues_url?: string;
    keys_url?: string;
    labels_url?: string;
    languages_url?: string;
    merges_url?: string;
    milestones_url?: string;
    notifications_url?: string;
    pulls_url?: string;
    releases_url?: string;
    ssh_url?: string;
    stargazers_url?: string;
    statuses_url?: string;
    subscribers_url?: string;
    subscription_url?: string;
    tags_url?: string;
    teams_url?: string;
    trees_url?: string;
    clone_url?: string;
    mirror_url?: string;
    hooks_url?: string;
    svn_url?: string;
    homepage?: string;
    language?: string;
    forks_count?: number;
    stargazers_count?: number;
    watchers_count?: number;
    size?: number;
    default_branch?: string;
    open_issues_count?: number;
    is_template?: boolean;
    topics?: string[];
    has_issues?: boolean;
    has_projects?: boolean;
    has_wiki?: boolean;
    has_pages?: boolean;
    has_downloads?: boolean;
    archived?: boolean;
    disabled?: boolean;
    visibility?: string;
    pushed_at?: string;
    created_at?: string;
    updated_at?: string;
    permissions?: {
      admin?: boolean;
      push?: boolean;
      pull?: boolean;
    };
    allow_rebase_merge?: boolean;
    temp_clone_token?: string;
    allow_squash_merge?: boolean;
    delete_branch_on_merge?: boolean;
    allow_merge_commit?: boolean;
    subscribers_count?: number;
    network_count?: number;
  } | null;
  temp_clone_token?: string;
  allow_squash_merge?: boolean;
  delete_branch_on_merge?: boolean;
  allow_merge_commit?: boolean;
  subscribers_count?: number;
  network_count?: number;
  open_issues: number;
  watchers: number;
  master_branch?: string;
  starred_at?: string;
};
export type InstallationToken = {
  token: string;
  expires_at: string;
  permissions?: {
    issues?: string;
    contents?: string;
    metadata?: string;
    single_file?: string;
  };
  repository_selection?: 'all' | 'selected';
  repositories?: Repository[];
  single_file?: string;
  has_multiple_single_files?: boolean;
  single_file_paths?: string[];
};
export type ValidationError = {
  message: string;
  documentation_url: string;
  errors?: {
    resource?: string;
    field?: string;
    message?: string;
    code: string;
    index?: number;
    value?: (string | null) | (number | null) | (string[] | null);
  }[];
};
export type ApplicationGrant = {
  id: number;
  url: string;
  app: {
    client_id: string;
    name: string;
    url: string;
  };
  created_at: Date;
  updated_at: Date;
  scopes: string[];
  user?: any;
};
export type ScopedInstallation = {
  permissions: AppPermissions;
  repository_selection: 'all' | 'selected';
  single_file_name: string | null;
  has_multiple_single_files?: boolean;
  single_file_paths?: string[];
  repositories_url: string;
  account: SimpleUser;
};
export type Authorization = {
  id: number;
  url: string;
  scopes: string[] | null;
  token: string;
  token_last_eight: string | null;
  hashed_token: string | null;
  app: {
    client_id: string;
    name: string;
    url: string;
  };
  note: string | null;
  note_url: string | null;
  updated_at: Date;
  created_at: Date;
  fingerprint: string | null;
  user?: any;
  installation?: any;
};
export type CodeOfConduct = {
  key: string;
  name: string;
  url: string;
  body?: string;
  html_url: string | null;
};
export type ContentReferenceAttachment = {
  id: number;
  title: string;
  body: string;
  node_id?: string;
};
export type EnabledOrganizations = 'all' | 'none' | 'selected';
export type AllowedActions = 'all' | 'local_only' | 'selected';
export type SelectedActionsUrl = string;
export type ActionsEnterprisePermissions = {
  enabled_organizations: EnabledOrganizations;
  selected_organizations_url?: string;
  allowed_actions: AllowedActions;
  selected_actions_url?: SelectedActionsUrl;
};
export type OrganizationSimple = {
  login: string;
  id: number;
  node_id: string;
  url: string;
  repos_url: string;
  events_url: string;
  hooks_url: string;
  issues_url: string;
  members_url: string;
  public_members_url: string;
  avatar_url: string;
  description: string | null;
};
export type SelectedActions = {
  github_owned_allowed: boolean;
  verified_allowed: boolean;
  patterns_allowed: string[];
};
export type RunnerGroupsEnterprise = {
  id: number;
  name: string;
  visibility: string;
  default: boolean;
  selected_organizations_url?: string;
  runners_url: string;
  allows_public_repositories: boolean;
};
export type Runner = {
  id: number;
  name: string;
  os: string;
  status: string;
  busy: boolean;
  labels: {
    id?: number;
    name?: string;
    type?: 'read-only' | 'custom';
  }[];
};
export type RunnerApplication = {
  os: string;
  architecture: string;
  download_url: string;
  filename: string;
};
export type AuthenticationToken = {
  token: string;
  expires_at: Date;
  permissions?: any;
  repositories?: Repository[];
  single_file?: string | null;
  repository_selection?: 'all' | 'selected';
};
export type AuditLogEvent = {
  '@timestamp'?: number;
  action?: string;
  active?: boolean;
  active_was?: boolean;
  actor?: string;
  blocked_user?: string;
  business?: string;
  config?: any[];
  config_was?: any[];
  content_type?: string;
  created_at?: number;
  deploy_key_fingerprint?: string;
  emoji?: string;
  events?: any[];
  events_were?: any[];
  explanation?: string;
  fingerprint?: string;
  hook_id?: number;
  limited_availability?: boolean;
  message?: string;
  name?: string;
  old_user?: string;
  openssh_public_key?: string;
  org?: string;
  previous_visibility?: string;
  read_only?: boolean;
  repo?: string;
  repository?: string;
  repository_public?: boolean;
  target_login?: string;
  team?: string;
  transport_protocol?: number;
  transport_protocol_name?: string;
  user?: string;
  visibility?: string;
};
export type ActionsBillingUsage = {
  total_minutes_used: number;
  total_paid_minutes_used: number;
  included_minutes: number;
  minutes_used_breakdown: {
    UBUNTU?: number;
    MACOS?: number;
    WINDOWS?: number;
  };
};
export type PackagesBillingUsage = {
  total_gigabytes_bandwidth_used: number;
  total_paid_gigabytes_bandwidth_used: number;
  included_gigabytes_bandwidth: number;
};
export type CombinedBillingUsage = {
  days_left_in_billing_cycle: number;
  estimated_paid_storage_for_month: number;
  estimated_storage_for_month: number;
};
export type Actor = {
  id: number;
  login: string;
  display_login?: string;
  gravatar_id: string | null;
  url: string;
  avatar_url: string;
};
export type Label = {
  id: number;
  node_id: string;
  url: string;
  name: string;
  description: string | null;
  color: string;
  default: boolean;
};
export type Milestone = {
  url: string;
  html_url: string;
  labels_url: string;
  id: number;
  node_id: string;
  number: number;
  state: 'open' | 'closed';
  title: string;
  description: string | null;
  creator: any;
  open_issues: number;
  closed_issues: number;
  created_at: Date;
  updated_at: Date;
  closed_at: Date | null;
  due_on: Date | null;
};
export type Author_association =
  | 'COLLABORATOR'
  | 'CONTRIBUTOR'
  | 'FIRST_TIMER'
  | 'FIRST_TIME_CONTRIBUTOR'
  | 'MANNEQUIN'
  | 'MEMBER'
  | 'NONE'
  | 'OWNER';
export type IssueSimple = {
  id: number;
  node_id: string;
  url: string;
  repository_url: string;
  labels_url: string;
  comments_url: string;
  events_url: string;
  html_url: string;
  number: number;
  state: string;
  title: string;
  body?: string;
  user: any;
  labels: Label[];
  assignee: any;
  assignees?: SimpleUser[] | null;
  milestone: any;
  locked: boolean;
  active_lock_reason?: string | null;
  comments: number;
  pull_request?: {
    merged_at?: Date | null;
    diff_url: string | null;
    html_url: string | null;
    patch_url: string | null;
    url: string | null;
  };
  closed_at: Date | null;
  created_at: Date;
  updated_at: Date;
  author_association: Author_association;
  body_html?: string;
  body_text?: string;
  timeline_url?: string;
  repository?: Repository;
  performed_via_github_app?: any;
};
export type ReactionRollup = {
  url: string;
  total_count: number;
  '+1': number;
  '-1': number;
  laugh: number;
  confused: number;
  heart: number;
  hooray: number;
  eyes: number;
  rocket: number;
};
export type IssueComment = {
  id: number;
  node_id: string;
  url: string;
  body?: string;
  body_text?: string;
  body_html?: string;
  html_url: string;
  user: any;
  created_at: Date;
  updated_at: Date;
  issue_url: string;
  author_association: Author_association;
  performed_via_github_app?: any;
  reactions?: ReactionRollup;
};
export type Event = {
  id: string;
  type: string | null;
  actor: Actor;
  repo: {
    id: number;
    name: string;
    url: string;
  };
  org?: Actor;
  payload: {
    action: string;
    issue?: IssueSimple;
    comment?: IssueComment;
    pages?: {
      page_name?: string;
      title?: string;
      summary?: string | null;
      action?: string;
      sha?: string;
      html_url?: string;
    }[];
  };
  public: boolean;
  created_at: Date | null;
};
export type LinkWithType = {
  href: string;
  type: string;
};
export type Feed = {
  timeline_url: string;
  user_url: string;
  current_user_public_url?: string;
  current_user_url?: string;
  current_user_actor_url?: string;
  current_user_organization_url?: string;
  current_user_organization_urls?: string[];
  security_advisories_url?: string;
  _links: {
    timeline: LinkWithType;
    user: LinkWithType;
    security_advisories?: LinkWithType;
    current_user?: LinkWithType;
    current_user_public?: LinkWithType;
    current_user_actor?: LinkWithType;
    current_user_organization?: LinkWithType;
    current_user_organizations?: LinkWithType[];
  };
};
export type BaseGist = {
  url: string;
  forks_url: string;
  commits_url: string;
  id: string;
  node_id: string;
  git_pull_url: string;
  git_push_url: string;
  html_url: string;
  files: {
    [key: string]: {
      filename?: string;
      type?: string;
      language?: string;
      raw_url?: string;
      size?: number;
    };
  };
  public: boolean;
  created_at: Date;
  updated_at: Date;
  description: string | null;
  comments: number;
  user: any;
  comments_url: string;
  owner?: any;
  truncated?: boolean;
  forks?: any[];
  history?: any[];
};
export type GistSimple = {
  url?: string;
  forks_url?: string;
  commits_url?: string;
  id?: string;
  node_id?: string;
  git_pull_url?: string;
  git_push_url?: string;
  html_url?: string;
  files?: {
    [key: string]: {
      filename?: string;
      type?: string;
      language?: string;
      raw_url?: string;
      size?: number;
      truncated?: boolean;
      content?: string;
    } | null;
  };
  public?: boolean;
  created_at?: string;
  updated_at?: string;
  description?: string | null;
  comments?: number;
  user?: string | null;
  comments_url?: string;
  owner?: SimpleUser;
  truncated?: boolean;
};
export type GistComment = {
  id: number;
  node_id: string;
  url: string;
  body: string;
  user: any;
  created_at: Date;
  updated_at: Date;
  author_association: Author_association;
};
export type GistCommit = {
  url: string;
  version: string;
  user: any;
  change_status: {
    total?: number;
    additions?: number;
    deletions?: number;
  };
  committed_at: Date;
};
export type GitignoreTemplate = {
  name: string;
  source: string;
};
export type Issue = {
  id: number;
  node_id: string;
  url: string;
  repository_url: string;
  labels_url: string;
  comments_url: string;
  events_url: string;
  html_url: string;
  number: number;
  state: string;
  title: string;
  body?: string;
  user: any;
  labels: (
    | string
    | {
        id?: number;
        node_id?: string;
        url?: string;
        name?: string;
        description?: string | null;
        color?: string | null;
        default?: boolean;
      }
  )[];
  assignee: any;
  assignees?: SimpleUser[] | null;
  milestone: any;
  locked: boolean;
  active_lock_reason?: string | null;
  comments: number;
  pull_request?: {
    merged_at?: Date | null;
    diff_url: string | null;
    html_url: string | null;
    patch_url: string | null;
    url: string | null;
  };
  closed_at: Date | null;
  created_at: Date;
  updated_at: Date;
  closed_by?: any;
  body_html?: string;
  body_text?: string;
  timeline_url?: string;
  repository?: Repository;
  performed_via_github_app?: any;
  author_association: Author_association;
  reactions?: ReactionRollup;
};
export type License = {
  key: string;
  name: string;
  spdx_id: string | null;
  url: string | null;
  node_id: string;
  html_url: string;
  description: string;
  implementation: string;
  permissions: string[];
  conditions: string[];
  limitations: string[];
  body: string;
  featured: boolean;
};
export type MarketplaceListingPlan = {
  url: string;
  accounts_url: string;
  id: number;
  number: number;
  name: string;
  description: string;
  monthly_price_in_cents: number;
  yearly_price_in_cents: number;
  price_model: string;
  has_free_trial: boolean;
  unit_name: string | null;
  state: string;
  bullets: string[];
};
export type MarketplacePurchase = {
  url: string;
  type: string;
  id: number;
  login: string;
  organization_billing_email?: string;
  marketplace_pending_change?: {
    is_installed?: boolean;
    effective_date?: string;
    unit_count?: number | null;
    id?: number;
    plan?: MarketplaceListingPlan;
  } | null;
  marketplace_purchase: {
    billing_cycle?: string;
    next_billing_date?: string | null;
    is_installed?: boolean;
    unit_count?: number | null;
    on_free_trial?: boolean;
    free_trial_ends_on?: string | null;
    updated_at?: string;
    plan?: MarketplaceListingPlan;
  };
};
export type ApiOverview = {
  verifiable_password_authentication: boolean;
  ssh_key_fingerprints?: {
    SHA256_RSA?: string;
    SHA256_DSA?: string;
  };
  hooks?: string[];
  web?: string[];
  api?: string[];
  git?: string[];
  pages?: string[];
  importer?: string[];
  actions?: string[];
};
export type MinimalRepository = {
  id: number;
  node_id: string;
  name: string;
  full_name: string;
  owner: any | null;
  private: boolean;
  html_url: string;
  description: string | null;
  fork: boolean;
  url: string;
  archive_url: string;
  assignees_url: string;
  blobs_url: string;
  branches_url: string;
  collaborators_url: string;
  comments_url: string;
  commits_url: string;
  compare_url: string;
  contents_url: string;
  contributors_url: string;
  deployments_url: string;
  downloads_url: string;
  events_url: string;
  forks_url: string;
  git_commits_url: string;
  git_refs_url: string;
  git_tags_url: string;
  git_url?: string;
  issue_comment_url: string;
  issue_events_url: string;
  issues_url: string;
  keys_url: string;
  labels_url: string;
  languages_url: string;
  merges_url: string;
  milestones_url: string;
  notifications_url: string;
  pulls_url: string;
  releases_url: string;
  ssh_url?: string;
  stargazers_url: string;
  statuses_url: string;
  subscribers_url: string;
  subscription_url: string;
  tags_url: string;
  teams_url: string;
  trees_url: string;
  clone_url?: string;
  mirror_url?: string | null;
  hooks_url: string;
  svn_url?: string;
  homepage?: string | null;
  language?: string | null;
  forks_count?: number;
  stargazers_count?: number;
  watchers_count?: number;
  size?: number;
  default_branch?: string;
  open_issues_count?: number;
  is_template?: boolean;
  topics?: string[];
  has_issues?: boolean;
  has_projects?: boolean;
  has_wiki?: boolean;
  has_pages?: boolean;
  has_downloads?: boolean;
  archived?: boolean;
  disabled?: boolean;
  visibility?: string;
  pushed_at?: Date | null;
  created_at?: Date | null;
  updated_at?: Date | null;
  permissions?: {
    admin?: boolean;
    push?: boolean;
    pull?: boolean;
  };
  template_repository?: any | null;
  temp_clone_token?: string;
  delete_branch_on_merge?: boolean;
  subscribers_count?: number;
  network_count?: number;
  license?: {
    key?: string;
    name?: string;
    spdx_id?: string;
    url?: string;
    node_id?: string;
  } | null;
  forks?: number;
  open_issues?: number;
  watchers?: number;
};
export type Thread = {
  id: string;
  repository: MinimalRepository;
  subject: {
    title: string;
    url: string;
    latest_comment_url: string;
    type: string;
  };
  reason: string;
  unread: boolean;
  updated_at: string;
  last_read_at: string | null;
  url: string;
  subscription_url: string;
};
export type ThreadSubscription = {
  subscribed: boolean;
  ignored: boolean;
  reason: string | null;
  created_at: Date | null;
  url: string;
  thread_url?: string;
  repository_url?: string;
};
export type OrganizationFull = {
  login: string;
  id: number;
  node_id: string;
  url: string;
  repos_url: string;
  events_url: string;
  hooks_url: string;
  issues_url: string;
  members_url: string;
  public_members_url: string;
  avatar_url: string;
  description: string | null;
  name?: string;
  company?: string;
  blog?: string;
  location?: string;
  email?: string;
  twitter_username?: string | null;
  is_verified?: boolean;
  has_organization_projects: boolean;
  has_repository_projects: boolean;
  public_repos: number;
  public_gists: number;
  followers: number;
  following: number;
  html_url: string;
  created_at: Date;
  type: string;
  total_private_repos?: number;
  owned_private_repos?: number;
  private_gists?: number | null;
  disk_usage?: number | null;
  collaborators?: number | null;
  billing_email?: string | null;
  plan?: {
    name: string;
    space: number;
    private_repos: number;
    filled_seats?: number;
    seats?: number;
  };
  default_repository_permission?: string | null;
  members_can_create_repositories?: boolean | null;
  two_factor_requirement_enabled?: boolean | null;
  members_allowed_repository_creation_type?: string;
  members_can_create_public_repositories?: boolean;
  members_can_create_private_repositories?: boolean;
  members_can_create_internal_repositories?: boolean;
  members_can_create_pages?: boolean;
  updated_at: Date;
};
export type EnabledRepositories = 'all' | 'none' | 'selected';
export type ActionsOrganizationPermissions = {
  enabled_repositories: EnabledRepositories;
  selected_repositories_url?: string;
  allowed_actions: AllowedActions;
  selected_actions_url?: SelectedActionsUrl;
};
export type RunnerGroupsOrg = {
  id: number;
  name: string;
  visibility: string;
  default: boolean;
  selected_repositories_url?: string;
  runners_url: string;
  inherited: boolean;
  inherited_allows_public_repositories?: boolean;
  allows_public_repositories: boolean;
};
export type OrganizationActionsSecret = {
  name: string;
  created_at: Date;
  updated_at: Date;
  visibility: 'all' | 'private' | 'selected';
  selected_repositories_url?: string;
};
export type ActionsPublicKey = {
  key_id: string;
  key: string;
  id?: number;
  url?: string;
  title?: string;
  created_at?: string;
};
export type CredentialAuthorization = {
  login: string;
  credential_id: number;
  credential_type: string;
  token_last_eight?: string;
  credential_authorized_at: Date;
  scopes?: string[];
  fingerprint?: string;
  credential_accessed_at?: Date | null;
  authorized_credential_id?: number | null;
  authorized_credential_title?: string | null;
  authorized_credential_note?: string | null;
};
export type OrganizationInvitation = {
  id: number;
  login: string | null;
  email: string | null;
  role: string;
  created_at: string;
  failed_at?: string;
  failed_reason?: string;
  inviter: SimpleUser;
  team_count: number;
  invitation_team_url: string;
  node_id: string;
  invitation_teams_url?: string;
};
export type OrgHook = {
  id: number;
  url: string;
  ping_url: string;
  name: string;
  events: string[];
  active: boolean;
  config: {
    url?: string;
    insecure_ssl?: string;
    content_type?: string;
    secret?: string;
  };
  updated_at: Date;
  created_at: Date;
  type: string;
};
export type InteractionGroup =
  | 'existing_users'
  | 'contributors_only'
  | 'collaborators_only';
export type InteractionLimitResponse = {
  limit: InteractionGroup;
  origin: string;
  expires_at: Date;
};
export type InteractionExpiry =
  | 'one_day'
  | 'three_days'
  | 'one_week'
  | 'one_month'
  | 'six_months';
export type InteractionLimit = {
  limit: InteractionGroup;
  expiry?: InteractionExpiry;
};
export type TeamSimple = {
  id: number;
  node_id: string;
  url: string;
  members_url: string;
  name: string;
  description: string | null;
  permission: string;
  privacy?: string;
  html_url: string;
  repositories_url: string;
  slug: string;
  ldap_dn?: string;
} | null;
export type Team = {
  id: number;
  node_id: string;
  name: string;
  slug: string;
  description: string | null;
  privacy?: string;
  permission: string;
  url: string;
  html_url: string;
  members_url: string;
  repositories_url: string;
  parent?: any;
};
export type OrgMembership = {
  url: string;
  state: string;
  role: string;
  organization_url: string;
  organization: OrganizationSimple;
  user: any;
  permissions?: {
    can_create_repository: boolean;
  };
};
export type Migration = {
  id: number;
  owner: any;
  guid: string;
  state: string;
  lock_repositories: boolean;
  exclude_attachments: boolean;
  repositories: Repository[];
  url: string;
  created_at: Date;
  updated_at: Date;
  node_id: string;
  archive_url?: string;
  exclude?: any[];
};
export type Package = {
  id: number;
  name: string;
  package_type: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container';
  url: string;
  html_url: string;
  version_count: number;
  visibility: 'private' | 'public';
  owner?: any;
  repository?: any;
  created_at: Date;
  updated_at: Date;
};
export type PackageVersion = {
  id: number;
  name: string;
  url: string;
  package_html_url: string;
  html_url?: string;
  license?: string;
  description?: string;
  created_at: Date;
  updated_at: Date;
  deleted_at?: Date;
  metadata?: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    container?: {
      tags: any[];
    };
    docker?: {
      tag?: any[];
    };
  };
};
export type Project = {
  owner_url: string;
  url: string;
  html_url: string;
  columns_url: string;
  id: number;
  node_id: string;
  name: string;
  body: string | null;
  number: number;
  state: string;
  creator: any;
  created_at: Date;
  updated_at: Date;
  organization_permission?: 'read' | 'write' | 'admin' | 'none';
  private?: boolean;
};
export type GroupMapping = {
  groups?: {
    group_id: string;
    group_name: string;
    group_description: string;
    status?: string;
    synced_at?: string;
  }[];
};
export type TeamFull = {
  id: number;
  node_id: string;
  url: string;
  html_url: string;
  name: string;
  slug: string;
  description: string | null;
  privacy?: 'closed' | 'secret';
  permission: string;
  members_url: string;
  repositories_url: string;
  parent?: any;
  members_count: number;
  repos_count: number;
  created_at: Date;
  updated_at: Date;
  organization: OrganizationFull;
  ldap_dn?: string;
};
export type TeamDiscussion = {
  author: any;
  body: string;
  body_html: string;
  body_version: string;
  comments_count: number;
  comments_url: string;
  created_at: Date;
  last_edited_at: Date | null;
  html_url: string;
  node_id: string;
  number: number;
  pinned: boolean;
  private: boolean;
  team_url: string;
  title: string;
  updated_at: Date;
  url: string;
  reactions?: ReactionRollup;
};
export type TeamDiscussionComment = {
  author: any;
  body: string;
  body_html: string;
  body_version: string;
  created_at: Date;
  last_edited_at: Date | null;
  discussion_url: string;
  html_url: string;
  node_id: string;
  number: number;
  updated_at: Date;
  url: string;
  reactions?: ReactionRollup;
};
export type Reaction = {
  id: number;
  node_id: string;
  user: any;
  content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  created_at: Date;
};
export type TeamMembership = {
  url: string;
  role: 'member' | 'maintainer';
  state: string;
};
export type TeamProject = {
  owner_url: string;
  url: string;
  html_url: string;
  columns_url: string;
  id: number;
  node_id: string;
  name: string;
  body: string | null;
  number: number;
  state: string;
  creator: SimpleUser;
  created_at: string;
  updated_at: string;
  organization_permission?: string;
  private?: boolean;
  permissions: {
    read: boolean;
    write: boolean;
    admin: boolean;
  };
};
export type TeamRepository = {
  id: number;
  node_id: string;
  name: string;
  full_name: string;
  license: any;
  forks: number;
  permissions?: {
    admin: boolean;
    pull: boolean;
    triage?: boolean;
    push: boolean;
    maintain?: boolean;
  };
  owner: any;
  private: boolean;
  html_url: string;
  description: string | null;
  fork: boolean;
  url: string;
  archive_url: string;
  assignees_url: string;
  blobs_url: string;
  branches_url: string;
  collaborators_url: string;
  comments_url: string;
  commits_url: string;
  compare_url: string;
  contents_url: string;
  contributors_url: string;
  deployments_url: string;
  downloads_url: string;
  events_url: string;
  forks_url: string;
  git_commits_url: string;
  git_refs_url: string;
  git_tags_url: string;
  git_url: string;
  issue_comment_url: string;
  issue_events_url: string;
  issues_url: string;
  keys_url: string;
  labels_url: string;
  languages_url: string;
  merges_url: string;
  milestones_url: string;
  notifications_url: string;
  pulls_url: string;
  releases_url: string;
  ssh_url: string;
  stargazers_url: string;
  statuses_url: string;
  subscribers_url: string;
  subscription_url: string;
  tags_url: string;
  teams_url: string;
  trees_url: string;
  clone_url: string;
  mirror_url: string | null;
  hooks_url: string;
  svn_url: string;
  homepage: string | null;
  language: string | null;
  forks_count: number;
  stargazers_count: number;
  watchers_count: number;
  size: number;
  default_branch: string;
  open_issues_count: number;
  is_template?: boolean;
  topics?: string[];
  has_issues: boolean;
  has_projects: boolean;
  has_wiki: boolean;
  has_pages: boolean;
  has_downloads: boolean;
  archived: boolean;
  disabled: boolean;
  visibility?: string;
  pushed_at: Date | null;
  created_at: Date | null;
  updated_at: Date | null;
  allow_rebase_merge?: boolean;
  template_repository?: any | null;
  temp_clone_token?: string;
  allow_squash_merge?: boolean;
  delete_branch_on_merge?: boolean;
  allow_merge_commit?: boolean;
  subscribers_count?: number;
  network_count?: number;
  open_issues: number;
  watchers: number;
  master_branch?: string;
};
export type ProjectCard = {
  url: string;
  id: number;
  node_id: string;
  note: string | null;
  creator: any;
  created_at: Date;
  updated_at: Date;
  archived?: boolean;
  column_url: string;
  content_url?: string;
  project_url: string;
};
export type ProjectColumn = {
  url: string;
  project_url: string;
  cards_url: string;
  id: number;
  node_id: string;
  name: string;
  created_at: Date;
  updated_at: Date;
};
export type RepositoryCollaboratorPermission = {
  permission: string;
  user: any;
};
export type RateLimit = {
  limit: number;
  remaining: number;
  reset: number;
};
export type RateLimitOverview = {
  resources: {
    core: RateLimit;
    graphql?: RateLimit;
    search: RateLimit;
    source_import?: RateLimit;
    integration_manifest?: RateLimit;
    code_scanning_upload?: RateLimit;
  };
  rate: RateLimit;
};
export type CodeOfConductSimple = {
  url: string;
  key: string;
  name: string;
  html_url: string | null;
};
export type FullRepository = {
  id: number;
  node_id: string;
  name: string;
  full_name: string;
  owner: any;
  private: boolean;
  html_url: string;
  description: string | null;
  fork: boolean;
  url: string;
  archive_url: string;
  assignees_url: string;
  blobs_url: string;
  branches_url: string;
  collaborators_url: string;
  comments_url: string;
  commits_url: string;
  compare_url: string;
  contents_url: string;
  contributors_url: string;
  deployments_url: string;
  downloads_url: string;
  events_url: string;
  forks_url: string;
  git_commits_url: string;
  git_refs_url: string;
  git_tags_url: string;
  git_url: string;
  issue_comment_url: string;
  issue_events_url: string;
  issues_url: string;
  keys_url: string;
  labels_url: string;
  languages_url: string;
  merges_url: string;
  milestones_url: string;
  notifications_url: string;
  pulls_url: string;
  releases_url: string;
  ssh_url: string;
  stargazers_url: string;
  statuses_url: string;
  subscribers_url: string;
  subscription_url: string;
  tags_url: string;
  teams_url: string;
  trees_url: string;
  clone_url: string;
  mirror_url: string | null;
  hooks_url: string;
  svn_url: string;
  homepage: string | null;
  language: string | null;
  forks_count: number;
  stargazers_count: number;
  watchers_count: number;
  size: number;
  default_branch: string;
  open_issues_count: number;
  is_template?: boolean;
  topics?: string[];
  has_issues: boolean;
  has_projects: boolean;
  has_wiki: boolean;
  has_pages: boolean;
  has_downloads: boolean;
  archived: boolean;
  disabled: boolean;
  visibility?: string;
  pushed_at: Date;
  created_at: Date;
  updated_at: Date;
  permissions?: {
    admin: boolean;
    pull: boolean;
    push: boolean;
  };
  allow_rebase_merge?: boolean;
  template_repository?: any | null;
  temp_clone_token?: string | null;
  allow_squash_merge?: boolean;
  delete_branch_on_merge?: boolean;
  allow_merge_commit?: boolean;
  subscribers_count: number;
  network_count: number;
  license: any;
  organization?: any;
  parent?: Repository;
  source?: Repository;
  forks: number;
  master_branch?: string;
  open_issues: number;
  watchers: number;
  anonymous_access_enabled?: boolean;
  code_of_conduct?: CodeOfConductSimple;
};
export type Artifact = {
  id: number;
  node_id: string;
  name: string;
  size_in_bytes: number;
  url: string;
  archive_download_url: string;
  expired: boolean;
  created_at: Date | null;
  expires_at: Date;
  updated_at: Date | null;
};
export type Job = {
  id: number;
  run_id: number;
  run_url: string;
  node_id: string;
  head_sha: string;
  url: string;
  html_url: string | null;
  status: 'queued' | 'in_progress' | 'completed';
  conclusion: string | null;
  started_at: Date;
  completed_at: Date | null;
  name: string;
  steps?: {
    status: 'queued' | 'in_progress' | 'completed';
    conclusion: string | null;
    name: string;
    number: number;
    started_at?: Date | null;
    completed_at?: Date | null;
  }[];
  check_run_url: string;
};
export type ActionsEnabled = boolean;
export type ActionsRepositoryPermissions = {
  enabled: ActionsEnabled;
  allowed_actions: AllowedActions;
  selected_actions_url?: SelectedActionsUrl;
};
export type PullRequestMinimal = {
  id: number;
  number: number;
  url: string;
  head: {
    ref: string;
    sha: string;
    repo: {
      id: number;
      url: string;
      name: string;
    };
  };
  base: {
    ref: string;
    sha: string;
    repo: {
      id: number;
      url: string;
      name: string;
    };
  };
};
export type SimpleCommit = {
  id: string;
  tree_id: string;
  message: string;
  timestamp: Date;
  author: {
    name: string;
    email: string;
  } | null;
  committer: {
    name: string;
    email: string;
  } | null;
};
export type WorkflowRun = {
  id: number;
  name?: string;
  node_id: string;
  head_branch: string | null;
  head_sha: string;
  run_number: number;
  event: string;
  status: string | null;
  conclusion: string | null;
  workflow_id: number;
  url: string;
  html_url: string;
  pull_requests: PullRequestMinimal[] | null;
  created_at: Date;
  updated_at: Date;
  jobs_url: string;
  logs_url: string;
  check_suite_url: string;
  artifacts_url: string;
  cancel_url: string;
  rerun_url: string;
  workflow_url: string;
  head_commit: SimpleCommit;
  repository: MinimalRepository;
  head_repository: MinimalRepository;
  head_repository_id?: number;
};
export type EnvironmentApprovals = {
  environments: {
    id?: number;
    node_id?: string;
    name?: string;
    url?: string;
    html_url?: string;
    created_at?: Date;
    updated_at?: Date;
  }[];
  state: 'approved' | 'rejected';
  user: SimpleUser;
  comment: string;
};
export type DeploymentReviewerType = 'User' | 'Team';
export type PendingDeployment = {
  environment: {
    id?: number;
    node_id?: string;
    name?: string;
    url?: string;
    html_url?: string;
  };
  wait_timer: number;
  wait_timer_started_at: Date | null;
  current_user_can_approve: boolean;
  reviewers: {
    type?: DeploymentReviewerType;
    reviewer?: SimpleUser | TeamSimple;
  }[];
};
export type Deployment = {
  url: string;
  id: number;
  node_id: string;
  sha: string;
  ref: string;
  task: string;
  payload: any;
  original_environment?: string;
  environment: string;
  description: string | null;
  creator: any;
  created_at: Date;
  updated_at: Date;
  statuses_url: string;
  repository_url: string;
  transient_environment?: boolean;
  production_environment?: boolean;
  performed_via_github_app?: any;
};
export type WorkflowRunUsage = {
  billable: {
    UBUNTU?: {
      total_ms: number;
      jobs: number;
    };
    MACOS?: {
      total_ms: number;
      jobs: number;
    };
    WINDOWS?: {
      total_ms: number;
      jobs: number;
    };
  };
  run_duration_ms: number;
};
export type ActionsSecret = {
  name: string;
  created_at: Date;
  updated_at: Date;
};
export type Workflow = {
  id: number;
  node_id: string;
  name: string;
  path: string;
  state: 'active' | 'deleted';
  created_at: Date;
  updated_at: Date;
  url: string;
  html_url: string;
  badge_url: string;
  deleted_at?: Date;
};
export type WorkflowUsage = {
  billable: {
    UBUNTU?: {
      total_ms?: number;
    };
    MACOS?: {
      total_ms?: number;
    };
    WINDOWS?: {
      total_ms?: number;
    };
  };
};
export type ProtectedBranchAdminEnforced = {
  url: string;
  enabled: boolean;
};
export type ProtectedBranchPullRequestReview = {
  url?: string;
  dismissal_restrictions?: {
    users?: SimpleUser[];
    teams?: Team[];
    url?: string;
    users_url?: string;
    teams_url?: string;
  };
  dismiss_stale_reviews: boolean;
  require_code_owner_reviews: boolean;
  required_approving_review_count?: number;
};
export type BranchRestrictionPolicy = {
  url: string;
  users_url: string;
  teams_url: string;
  apps_url: string;
  users: {
    login?: string;
    id?: number;
    node_id?: string;
    avatar_url?: string;
    gravatar_id?: string;
    url?: string;
    html_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    starred_url?: string;
    subscriptions_url?: string;
    organizations_url?: string;
    repos_url?: string;
    events_url?: string;
    received_events_url?: string;
    type?: string;
    site_admin?: boolean;
  }[];
  teams: {
    id?: number;
    node_id?: string;
    url?: string;
    html_url?: string;
    name?: string;
    slug?: string;
    description?: string | null;
    privacy?: string;
    permission?: string;
    members_url?: string;
    repositories_url?: string;
    parent?: string | null;
  }[];
  apps: {
    id?: number;
    slug?: string;
    node_id?: string;
    owner?: {
      login?: string;
      id?: number;
      node_id?: string;
      url?: string;
      repos_url?: string;
      events_url?: string;
      hooks_url?: string;
      issues_url?: string;
      members_url?: string;
      public_members_url?: string;
      avatar_url?: string;
      description?: string;
      gravatar_id?: string;
      html_url?: string;
      followers_url?: string;
      following_url?: string;
      gists_url?: string;
      starred_url?: string;
      subscriptions_url?: string;
      organizations_url?: string;
      received_events_url?: string;
      type?: string;
    };
    name?: string;
    description?: string;
    external_url?: string;
    html_url?: string;
    created_at?: string;
    updated_at?: string;
    permissions?: {
      metadata?: string;
      contents?: string;
      issues?: string;
      single_file?: string;
    };
    events?: string[];
  }[];
};
export type BranchProtection = {
  url?: string;
  required_status_checks: {
    url?: string;
    enforcement_level: string;
    contexts: string[];
    contexts_url?: string;
  };
  enforce_admins?: ProtectedBranchAdminEnforced;
  required_pull_request_reviews?: ProtectedBranchPullRequestReview;
  restrictions?: BranchRestrictionPolicy;
  required_linear_history?: {
    enabled?: boolean;
  };
  allow_force_pushes?: {
    enabled?: boolean;
  };
  allow_deletions?: {
    enabled?: boolean;
  };
  enabled: boolean;
  name?: string;
  protection_url?: string;
};
export type ShortBranch = {
  name: string;
  commit: {
    sha: string;
    url: string;
  };
  protected: boolean;
  protection?: BranchProtection;
  protection_url?: string;
};
export type GitUser = {
  name?: string;
  email?: string;
  date?: string;
};
export type Verification = {
  verified: boolean;
  reason: string;
  payload: string | null;
  signature: string | null;
};
export type Commit = {
  url: string;
  sha: string;
  node_id: string;
  html_url: string;
  comments_url: string;
  commit: {
    url: string;
    author: any;
    committer: any;
    message: string;
    comment_count: number;
    tree: {
      sha: string;
      url: string;
    };
    verification?: Verification;
  };
  author: any;
  committer: any;
  parents: {
    sha: string;
    url: string;
    html_url?: string;
  }[];
  stats?: {
    additions?: number;
    deletions?: number;
    total?: number;
  };
  files?: {
    filename?: string;
    additions?: number;
    deletions?: number;
    changes?: number;
    status?: string;
    raw_url?: string;
    blob_url?: string;
    patch?: string;
    sha?: string;
    contents_url?: string;
    previous_filename?: string;
  }[];
};
export type BranchWithProtection = {
  name: string;
  commit: Commit;
  _links: {
    html: string;
    self: string;
  };
  protected: boolean;
  protection: BranchProtection;
  protection_url: string;
  pattern?: string;
  required_approving_review_count?: number;
};
export type StatusCheckPolicy = {
  url: string;
  strict: boolean;
  contexts: string[];
  contexts_url: string;
};
export type ProtectedBranch = {
  url: string;
  required_status_checks?: StatusCheckPolicy;
  required_pull_request_reviews?: {
    url: string;
    dismiss_stale_reviews?: boolean;
    require_code_owner_reviews?: boolean;
    required_approving_review_count?: number;
    dismissal_restrictions?: {
      url: string;
      users_url: string;
      teams_url: string;
      users: SimpleUser[];
      teams: Team[];
    };
  };
  required_signatures?: {
    url: string;
    enabled: boolean;
  };
  enforce_admins?: {
    url: string;
    enabled: boolean;
  };
  required_linear_history?: {
    enabled: boolean;
  };
  allow_force_pushes?: {
    enabled: boolean;
  };
  allow_deletions?: {
    enabled: boolean;
  };
  restrictions?: BranchRestrictionPolicy;
};
export type DeploymentSimple = {
  url: string;
  id: number;
  node_id: string;
  task: string;
  original_environment?: string;
  environment: string;
  description: string | null;
  created_at: Date;
  updated_at: Date;
  statuses_url: string;
  repository_url: string;
  transient_environment?: boolean;
  production_environment?: boolean;
  performed_via_github_app?: any;
};
export type CheckRun = {
  id: number;
  head_sha: string;
  node_id: string;
  external_id: string | null;
  url: string;
  html_url: string | null;
  details_url: string | null;
  status: 'queued' | 'in_progress' | 'completed';
  conclusion:
    | (
        | 'success'
        | 'failure'
        | 'neutral'
        | 'cancelled'
        | 'skipped'
        | 'timed_out'
        | 'action_required'
      )
    | null;
  started_at: Date | null;
  completed_at: Date | null;
  output: {
    title: string | null;
    summary: string | null;
    text: string | null;
    annotations_count: number;
    annotations_url: string;
  };
  name: string;
  check_suite: {
    id: number;
  } | null;
  app: any;
  pull_requests: any;
  deployment?: DeploymentSimple;
};
export type CheckAnnotation = {
  path: string;
  start_line: number;
  end_line: number;
  start_column: number | null;
  end_column: number | null;
  annotation_level: string | null;
  title: string | null;
  message: string | null;
  raw_details: string | null;
  blob_href: string;
};
export type CheckSuite = {
  id: number;
  node_id: string;
  head_branch: string | null;
  head_sha: string;
  status: ('queued' | 'in_progress' | 'completed') | null;
  conclusion:
    | (
        | 'success'
        | 'failure'
        | 'neutral'
        | 'cancelled'
        | 'skipped'
        | 'timed_out'
        | 'action_required'
      )
    | null;
  url: string | null;
  before: string | null;
  after: string | null;
  pull_requests: PullRequestMinimal[] | null;
  app: any;
  repository: MinimalRepository;
  created_at: Date | null;
  updated_at: Date | null;
  head_commit: SimpleCommit;
  latest_check_runs_count: number;
  check_runs_url: string;
};
export type CheckSuitePreference = {
  preferences: {
    auto_trigger_checks?: {
      app_id: number;
      setting: boolean;
    }[];
  };
  repository: Repository;
};
export type CodeScanningAnalysisToolName = string;
export type CodeScanningAnalysisToolGuid = string | null;
export type CodeScanningRef = string;
export type CodeScanningAlertState = 'open' | 'closed' | 'dismissed' | 'fixed';
export type AlertNumber = number;
export type AlertCreatedAt = Date;
export type AlertUrl = string;
export type AlertHtmlUrl = string;
export type AlertInstancesUrl = string;
export type CodeScanningAlertDismissedAt = Date | null;
export type CodeScanningAlertDismissedReason = string | null;
export type CodeScanningAlertRuleSummary = {
  id?: string | null;
  name?: string;
  severity?: ('none' | 'note' | 'warning' | 'error') | null;
  description?: string;
};
export type CodeScanningAnalysisToolVersion = string | null;
export type CodeScanningAnalysisTool = {
  name?: CodeScanningAnalysisToolName;
  version?: CodeScanningAnalysisToolVersion;
  guid?: CodeScanningAnalysisToolGuid;
};
export type CodeScanningAnalysisAnalysisKey = string;
export type CodeScanningAlertEnvironment = string;
export type CodeScanningAlertLocation = {
  path?: string;
  start_line?: number;
  end_line?: number;
  start_column?: number;
  end_column?: number;
};
export type CodeScanningAlertClassification =
  | ('source' | 'generated' | 'test' | 'library')
  | null;
export type CodeScanningAlertInstance = {
  ref?: CodeScanningRef;
  analysis_key?: CodeScanningAnalysisAnalysisKey;
  environment?: CodeScanningAlertEnvironment;
  state?: CodeScanningAlertState;
  commit_sha?: string;
  message?: {
    text?: string;
  };
  location?: CodeScanningAlertLocation;
  html_url?: string;
  classifications?: CodeScanningAlertClassification[];
};
export type CodeScanningAlertItems = {
  number: AlertNumber;
  created_at: AlertCreatedAt;
  url: AlertUrl;
  html_url: AlertHtmlUrl;
  instances_url: AlertInstancesUrl;
  state: CodeScanningAlertState;
  dismissed_by: SimpleUser;
  dismissed_at: CodeScanningAlertDismissedAt;
  dismissed_reason: CodeScanningAlertDismissedReason;
  rule: CodeScanningAlertRuleSummary;
  tool: CodeScanningAnalysisTool;
  most_recent_instance: CodeScanningAlertInstance;
};
export type CodeScanningAlertRule = {
  id?: string | null;
  name?: string;
  severity?: ('none' | 'note' | 'warning' | 'error') | null;
  description?: string;
  full_description?: string;
  tags?: string[];
  help?: string;
};
export type CodeScanningAlert = {
  number: AlertNumber;
  created_at: AlertCreatedAt;
  url: AlertUrl;
  html_url: AlertHtmlUrl;
  instances_url: AlertInstancesUrl;
  state: CodeScanningAlertState;
  dismissed_by: SimpleUser;
  dismissed_at: CodeScanningAlertDismissedAt;
  dismissed_reason: CodeScanningAlertDismissedReason;
  rule: CodeScanningAlertRule;
  tool: CodeScanningAnalysisTool;
  most_recent_instance: CodeScanningAlertInstance;
};
export type CodeScanningAlertSetState = 'open' | 'dismissed';
export type CodeScanningAnalysisSarifId = string;
export type CodeScanningAnalysisCommitSha = string;
export type CodeScanningAnalysisEnvironment = string;
export type CodeScanningAnalysisCreatedAt = Date;
export type CodeScanningAnalysisUrl = string;
export type CodeScanningAnalysis = {
  ref: CodeScanningRef;
  commit_sha: CodeScanningAnalysisCommitSha;
  analysis_key: CodeScanningAnalysisAnalysisKey;
  environment: CodeScanningAnalysisEnvironment;
  error: string;
  created_at: CodeScanningAnalysisCreatedAt;
  results_count: number;
  rules_count: number;
  id: number;
  url: CodeScanningAnalysisUrl;
  sarif_id: CodeScanningAnalysisSarifId;
  tool: CodeScanningAnalysisTool;
  deletable: boolean;
};
export type CodeScanningAnalysisDeletion = {
  next_analysis_url: string | null;
  confirm_delete_url: string | null;
};
export type ScimError = {
  message?: string | null;
  documentation_url?: string | null;
  detail?: string | null;
  status?: number;
  scimType?: string | null;
  schemas?: string[];
};
export type CodeScanningAnalysisSarifFile = string;
export type CodeScanningSarifsReceipt = {
  id?: CodeScanningAnalysisSarifId;
  url?: string;
};
export type CodeScanningSarifsStatus = {
  processing_status?: 'pending' | 'complete';
  analyses_url?: string | null;
};
export type Collaborator = {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string | null;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: string;
  site_admin: boolean;
  permissions?: {
    pull: boolean;
    push: boolean;
    admin: boolean;
  };
};
export type RepositoryInvitation = {
  id: number;
  repository: MinimalRepository;
  invitee: any;
  inviter: any;
  permissions: 'read' | 'write' | 'admin';
  created_at: Date;
  expired?: boolean;
  url: string;
  html_url: string;
  node_id: string;
};
export type CommitComment = {
  html_url: string;
  url: string;
  id: number;
  node_id: string;
  body: string;
  path: string | null;
  position: number | null;
  line: number | null;
  commit_id: string;
  user: any;
  created_at: Date;
  updated_at: Date;
  author_association: Author_association;
  reactions?: ReactionRollup;
};
export type BranchShort = {
  name: string;
  commit: {
    sha: string;
    url: string;
  };
  protected: boolean;
};
export type Link = {
  href: string;
};
export type Auto_merge = {
  enabled_by: SimpleUser;
  merge_method: 'merge' | 'squash' | 'rebase';
  commit_title: string;
  commit_message: string;
} | null;
export type PullRequestSimple = {
  /**
   * A small description
   */
  url: string;
  id: number;
  node_id: string;
  html_url: string;
  diff_url: string;
  patch_url: string;
  issue_url: string;
  commits_url: string;
  review_comments_url: string;
  review_comment_url: string;
  comments_url: string;
  statuses_url: string;
  number: number;
  state: string;
  locked: boolean;
  title: string;
  user: any;
  body: string | null;
  labels: {
    id?: number;
    node_id?: string;
    url?: string;
    name?: string;
    description?: string;
    color?: string;
    default?: boolean;
  }[];
  milestone: any;
  active_lock_reason?: string | null;
  created_at: Date;
  updated_at: Date;
  closed_at: Date | null;
  merged_at: Date | null;
  merge_commit_sha: string | null;
  assignee: any;
  assignees?: SimpleUser[] | null;
  requested_reviewers?: SimpleUser[] | null;
  requested_teams?: TeamSimple[] | null;
  head: {
    label: string;
    ref: string;
    repo: Repository;
    sha: string;
    user: any;
  };
  base: {
    label: string;
    ref: string;
    repo: Repository;
    sha: string;
    user: any;
  };
  _links: {
    comments: Link;
    commits: Link;
    statuses: Link;
    html: Link;
    issue: Link;
    review_comments: Link;
    review_comment: Link;
    self: Link;
  };
  author_association: Author_association;
  auto_merge: Auto_merge;
  draft?: boolean;
};
export type SimpleCommitStatus = {
  description: string | null;
  id: number;
  node_id: string;
  state: string;
  context: string;
  target_url: string;
  required?: boolean | null;
  avatar_url: string | null;
  url: string;
  created_at: Date;
  updated_at: Date;
};
export type CombinedCommitStatus = {
  state: string;
  statuses: SimpleCommitStatus[];
  sha: string;
  total_count: number;
  repository: MinimalRepository;
  commit_url: string;
  url: string;
};
export type Status = {
  url: string;
  avatar_url: string | null;
  id: number;
  node_id: string;
  state: string;
  description: string;
  target_url: string;
  context: string;
  created_at: string;
  updated_at: string;
  creator: SimpleUser;
};
export type CommunityHealthFile = {
  url: string;
  html_url: string;
};
export type CommunityProfile = {
  health_percentage: number;
  description: string | null;
  documentation: string | null;
  files: {
    code_of_conduct: any;
    license: any;
    contributing: any;
    readme: any;
    issue_template: any;
    pull_request_template: any;
  };
  updated_at: Date | null;
  content_reports_enabled?: boolean;
};
export type DiffEntry = {
  sha: string;
  filename: string;
  status: string;
  additions: number;
  deletions: number;
  changes: number;
  blob_url: string;
  raw_url: string;
  contents_url: string;
  patch?: string;
  previous_filename?: string;
};
export type CommitComparison = {
  url: string;
  html_url: string;
  permalink_url: string;
  diff_url: string;
  patch_url: string;
  base_commit: Commit;
  merge_base_commit: Commit;
  status: 'diverged' | 'ahead' | 'behind' | 'identical';
  ahead_by: number;
  behind_by: number;
  total_commits: number;
  commits: Commit[];
  files: DiffEntry[];
};
export type ContentTree = {
  type: string;
  size: number;
  name: string;
  path: string;
  sha: string;
  url: string;
  git_url: string | null;
  html_url: string | null;
  download_url: string | null;
  entries?: {
    type: string;
    size: number;
    name: string;
    path: string;
    content?: string;
    sha: string;
    url: string;
    git_url: string | null;
    html_url: string | null;
    download_url: string | null;
    _links: {
      git: string | null;
      html: string | null;
      self: string;
    };
  }[];
  _links: {
    git: string | null;
    html: string | null;
    self: string;
  };
};
export type ContentDirectory = {
  type: string;
  size: number;
  name: string;
  path: string;
  content?: string;
  sha: string;
  url: string;
  git_url: string | null;
  html_url: string | null;
  download_url: string | null;
  _links: {
    git: string | null;
    html: string | null;
    self: string;
  };
}[];
export type ContentFile = {
  type: string;
  encoding: string;
  size: number;
  name: string;
  path: string;
  content: string;
  sha: string;
  url: string;
  git_url: string | null;
  html_url: string | null;
  download_url: string | null;
  _links: {
    git: string | null;
    html: string | null;
    self: string;
  };
  target?: string;
  submodule_git_url?: string;
};
export type ContentSymlink = {
  type: string;
  target: string;
  size: number;
  name: string;
  path: string;
  sha: string;
  url: string;
  git_url: string | null;
  html_url: string | null;
  download_url: string | null;
  _links: {
    git: string | null;
    html: string | null;
    self: string;
  };
};
export type ContentSubmodule = {
  type: string;
  submodule_git_url: string;
  size: number;
  name: string;
  path: string;
  sha: string;
  url: string;
  git_url: string | null;
  html_url: string | null;
  download_url: string | null;
  _links: {
    git: string | null;
    html: string | null;
    self: string;
  };
};
export type FileCommit = {
  content: {
    name?: string;
    path?: string;
    sha?: string;
    size?: number;
    url?: string;
    html_url?: string;
    git_url?: string;
    download_url?: string;
    type?: string;
    _links?: {
      self?: string;
      git?: string;
      html?: string;
    };
  } | null;
  commit: {
    sha?: string;
    node_id?: string;
    url?: string;
    html_url?: string;
    author?: {
      date?: string;
      name?: string;
      email?: string;
    };
    committer?: {
      date?: string;
      name?: string;
      email?: string;
    };
    message?: string;
    tree?: {
      url?: string;
      sha?: string;
    };
    parents?: {
      url?: string;
      html_url?: string;
      sha?: string;
    }[];
    verification?: {
      verified?: boolean;
      reason?: string;
      signature?: string | null;
      payload?: string | null;
    };
  };
};
export type Contributor = {
  login?: string;
  id?: number;
  node_id?: string;
  avatar_url?: string;
  gravatar_id?: string | null;
  url?: string;
  html_url?: string;
  followers_url?: string;
  following_url?: string;
  gists_url?: string;
  starred_url?: string;
  subscriptions_url?: string;
  organizations_url?: string;
  repos_url?: string;
  events_url?: string;
  received_events_url?: string;
  type: string;
  site_admin?: boolean;
  contributions: number;
  email?: string;
  name?: string;
};
export type DeploymentStatus = {
  url: string;
  id: number;
  node_id: string;
  state:
    | 'error'
    | 'failure'
    | 'inactive'
    | 'pending'
    | 'success'
    | 'queued'
    | 'in_progress';
  creator: any;
  description: string;
  environment?: string;
  target_url: string;
  created_at: Date;
  updated_at: Date;
  deployment_url: string;
  repository_url: string;
  environment_url?: string;
  log_url?: string;
  performed_via_github_app?: any;
};
export type WaitTimer = number;
export type Deployment_branch_policy = {
  protected_branches: boolean;
  custom_branch_policies: boolean;
} | null;
export type Environment = {
  id: number;
  node_id: string;
  name: string;
  url: string;
  html_url: string;
  created_at: Date;
  updated_at: Date;
  protection_rules?: (
    | {
        id: number;
        node_id: string;
        type: string;
        wait_timer?: WaitTimer;
      }
    | {
        id: number;
        node_id: string;
        type: string;
        reviewers?: {
          type?: DeploymentReviewerType;
          reviewer?: SimpleUser | TeamSimple;
        }[];
      }
    | {
        id: number;
        node_id: string;
        type: string;
      }
  )[];
  deployment_branch_policy?: Deployment_branch_policy;
};
export type ShortBlob = {
  url: string;
  sha: string;
};
export type Blob = {
  content: string;
  encoding: string;
  url: string;
  sha: string;
  size: number | null;
  node_id: string;
  highlighted_content?: string;
};
export type GitCommit = {
  sha: string;
  node_id: string;
  url: string;
  author: {
    date: Date;
    email: string;
    name: string;
  };
  committer: {
    date: Date;
    email: string;
    name: string;
  };
  message: string;
  tree: {
    sha: string;
    url: string;
  };
  parents: {
    sha: string;
    url: string;
    html_url: string;
  }[];
  verification: {
    verified: boolean;
    reason: string;
    signature: string | null;
    payload: string | null;
  };
  html_url: string;
};
export type GitRef = {
  ref: string;
  node_id: string;
  url: string;
  object: {
    type: string;
    sha: string;
    url: string;
  };
};
export type GitTag = {
  node_id: string;
  tag: string;
  sha: string;
  url: string;
  message: string;
  tagger: {
    date: string;
    email: string;
    name: string;
  };
  object: {
    sha: string;
    type: string;
    url: string;
  };
  verification?: Verification;
};
export type GitTree = {
  sha: string;
  url: string;
  truncated: boolean;
  tree: {
    path?: string;
    mode?: string;
    type?: string;
    sha?: string;
    size?: number;
    url?: string;
  }[];
};
export type HookResponse = {
  code: number | null;
  status: string | null;
  message: string | null;
};
export type Hook = {
  type: string;
  id: number;
  name: string;
  active: boolean;
  events: string[];
  config: {
    email?: string;
    password?: string;
    room?: string;
    subdomain?: string;
    url?: WebhookConfigUrl;
    insecure_ssl?: WebhookConfigInsecureSsl;
    content_type?: WebhookConfigContentType;
    digest?: string;
    secret?: WebhookConfigSecret;
    token?: string;
  };
  updated_at: Date;
  created_at: Date;
  url: string;
  test_url: string;
  ping_url: string;
  last_response: HookResponse;
};
export type Import = {
  vcs: string | null;
  use_lfs?: string;
  vcs_url: string;
  svc_root?: string;
  tfvc_project?: string;
  status:
    | 'auth'
    | 'error'
    | 'none'
    | 'detecting'
    | 'choose'
    | 'auth_failed'
    | 'importing'
    | 'mapping'
    | 'waiting_to_push'
    | 'pushing'
    | 'complete'
    | 'setup'
    | 'unknown'
    | 'detection_found_multiple'
    | 'detection_found_nothing'
    | 'detection_needs_auth';
  status_text?: string | null;
  failed_step?: string | null;
  error_message?: string | null;
  import_percent?: number | null;
  commit_count?: number | null;
  push_percent?: number | null;
  has_large_files?: boolean;
  large_files_size?: number;
  large_files_count?: number;
  project_choices?: {
    vcs?: string;
    tfvc_project?: string;
    human_name?: string;
  }[];
  message?: string;
  authors_count?: number | null;
  url: string;
  html_url: string;
  authors_url: string;
  repository_url: string;
  svn_root?: string;
};
export type PorterAuthor = {
  id: number;
  remote_id: string;
  remote_name: string;
  email: string;
  name: string;
  url: string;
  import_url: string;
};
export type PorterLargeFile = {
  ref_name: string;
  path: string;
  oid: string;
  size: number;
};
export type IssueEventLabel = {
  name: string | null;
  color: string | null;
};
export type IssueEventDismissedReview = {
  state: string;
  review_id: number;
  dismissal_message: string | null;
  dismissal_commit_id?: string | null;
};
export type IssueEventMilestone = {
  title: string;
};
export type IssueEventProjectCard = {
  url: string;
  id: number;
  project_url: string;
  project_id: number;
  column_name: string;
  previous_column_name?: string;
};
export type IssueEventRename = {
  from: string;
  to: string;
};
export type IssueEvent = {
  id: number;
  node_id: string;
  url: string;
  actor: any;
  event: string;
  commit_id: string | null;
  commit_url: string | null;
  created_at: Date;
  issue?: IssueSimple;
  label?: IssueEventLabel;
  assignee?: any;
  assigner?: any;
  review_requester?: any;
  requested_reviewer?: any;
  requested_team?: Team;
  dismissed_review?: IssueEventDismissedReview;
  milestone?: IssueEventMilestone;
  project_card?: IssueEventProjectCard;
  rename?: IssueEventRename;
  author_association?: Author_association;
  lock_reason?: string | null;
};
export type IssueEventForIssue = {
  id?: number;
  node_id?: string;
  url?: string;
  actor?: SimpleUser;
  event?: string;
  commit_id?: string | null;
  commit_url?: string | null;
  created_at?: string;
  sha?: string;
  html_url?: string;
  message?: string;
  issue_url?: string;
  updated_at?: string;
  author_association?: Author_association;
  body?: string;
  lock_reason?: string;
  submitted_at?: string;
  state?: string;
  pull_request_url?: string;
  body_html?: string;
  body_text?: string;
};
export type DeployKey = {
  id: number;
  key: string;
  url: string;
  title: string;
  verified: boolean;
  created_at: string;
  read_only: boolean;
};
export type Language = {
  [key: string]: number;
};
export type LicenseContent = {
  name: string;
  path: string;
  sha: string;
  size: number;
  url: string;
  html_url: string | null;
  git_url: string | null;
  download_url: string | null;
  type: string;
  content: string;
  encoding: string;
  _links: {
    git: string | null;
    html: string | null;
    self: string;
  };
  license: any;
};
export type PagesSourceHash = {
  branch: string;
  path: string;
};
export type Page = {
  url: string;
  status: ('built' | 'building' | 'errored') | null;
  cname: string | null;
  custom_404: boolean;
  html_url?: string;
  source?: PagesSourceHash;
  public: boolean;
};
export type PageBuild = {
  url: string;
  status: string;
  error: {
    message: string | null;
  };
  pusher: any;
  commit: string;
  duration: number;
  created_at: Date;
  updated_at: Date;
};
export type PageBuildStatus = {
  url: string;
  status: string;
};
export type PullRequest = {
  url: string;
  id: number;
  node_id: string;
  html_url: string;
  diff_url: string;
  patch_url: string;
  issue_url: string;
  commits_url: string;
  review_comments_url: string;
  review_comment_url: string;
  comments_url: string;
  statuses_url: string;
  number: number;
  state: 'open' | 'closed';
  locked: boolean;
  title: string;
  user: any;
  body: string | null;
  labels: {
    id?: number;
    node_id?: string;
    url?: string;
    name?: string;
    description?: string | null;
    color?: string;
    default?: boolean;
  }[];
  milestone: any;
  active_lock_reason?: string | null;
  created_at: Date;
  updated_at: Date;
  closed_at: Date | null;
  merged_at: Date | null;
  merge_commit_sha: string | null;
  assignee: any;
  assignees?: SimpleUser[] | null;
  requested_reviewers?: SimpleUser[] | null;
  requested_teams?: TeamSimple[] | null;
  head: {
    label: string;
    ref: string;
    repo: {
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      description: string | null;
      downloads_url: string;
      events_url: string;
      fork: boolean;
      forks_url: string;
      full_name: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      hooks_url: string;
      html_url: string;
      id: number;
      node_id: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      name: string;
      notifications_url: string;
      owner: {
        avatar_url: string;
        events_url: string;
        followers_url: string;
        following_url: string;
        gists_url: string;
        gravatar_id: string | null;
        html_url: string;
        id: number;
        node_id: string;
        login: string;
        organizations_url: string;
        received_events_url: string;
        repos_url: string;
        site_admin: boolean;
        starred_url: string;
        subscriptions_url: string;
        type: string;
        url: string;
      };
      private: boolean;
      pulls_url: string;
      releases_url: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      url: string;
      clone_url: string;
      default_branch: string;
      forks: number;
      forks_count: number;
      git_url: string;
      has_downloads: boolean;
      has_issues: boolean;
      has_projects: boolean;
      has_wiki: boolean;
      has_pages: boolean;
      homepage: string | null;
      language: string | null;
      master_branch?: string;
      archived: boolean;
      disabled: boolean;
      mirror_url: string | null;
      open_issues: number;
      open_issues_count: number;
      permissions?: {
        admin: boolean;
        pull: boolean;
        push: boolean;
      };
      temp_clone_token?: string;
      allow_merge_commit?: boolean;
      allow_squash_merge?: boolean;
      allow_rebase_merge?: boolean;
      license: {
        key: string;
        name: string;
        url: string | null;
        spdx_id: string | null;
        node_id: string;
      } | null;
      pushed_at: Date;
      size: number;
      ssh_url: string;
      stargazers_count: number;
      svn_url: string;
      topics?: string[];
      watchers: number;
      watchers_count: number;
      created_at: Date;
      updated_at: Date;
    };
    sha: string;
    user: {
      avatar_url: string;
      events_url: string;
      followers_url: string;
      following_url: string;
      gists_url: string;
      gravatar_id: string | null;
      html_url: string;
      id: number;
      node_id: string;
      login: string;
      organizations_url: string;
      received_events_url: string;
      repos_url: string;
      site_admin: boolean;
      starred_url: string;
      subscriptions_url: string;
      type: string;
      url: string;
    };
  };
  base: {
    label: string;
    ref: string;
    repo: {
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      description: string | null;
      downloads_url: string;
      events_url: string;
      fork: boolean;
      forks_url: string;
      full_name: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      hooks_url: string;
      html_url: string;
      id: number;
      node_id: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      name: string;
      notifications_url: string;
      owner: {
        avatar_url: string;
        events_url: string;
        followers_url: string;
        following_url: string;
        gists_url: string;
        gravatar_id: string | null;
        html_url: string;
        id: number;
        node_id: string;
        login: string;
        organizations_url: string;
        received_events_url: string;
        repos_url: string;
        site_admin: boolean;
        starred_url: string;
        subscriptions_url: string;
        type: string;
        url: string;
      };
      private: boolean;
      pulls_url: string;
      releases_url: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      url: string;
      clone_url: string;
      default_branch: string;
      forks: number;
      forks_count: number;
      git_url: string;
      has_downloads: boolean;
      has_issues: boolean;
      has_projects: boolean;
      has_wiki: boolean;
      has_pages: boolean;
      homepage: string | null;
      language: string | null;
      master_branch?: string;
      archived: boolean;
      disabled: boolean;
      mirror_url: string | null;
      open_issues: number;
      open_issues_count: number;
      permissions?: {
        admin: boolean;
        pull: boolean;
        push: boolean;
      };
      temp_clone_token?: string;
      allow_merge_commit?: boolean;
      allow_squash_merge?: boolean;
      allow_rebase_merge?: boolean;
      license: any;
      pushed_at: Date;
      size: number;
      ssh_url: string;
      stargazers_count: number;
      svn_url: string;
      topics?: string[];
      watchers: number;
      watchers_count: number;
      created_at: Date;
      updated_at: Date;
    };
    sha: string;
    user: {
      avatar_url: string;
      events_url: string;
      followers_url: string;
      following_url: string;
      gists_url: string;
      gravatar_id: string | null;
      html_url: string;
      id: number;
      node_id: string;
      login: string;
      organizations_url: string;
      received_events_url: string;
      repos_url: string;
      site_admin: boolean;
      starred_url: string;
      subscriptions_url: string;
      type: string;
      url: string;
    };
  };
  _links: {
    comments: Link;
    commits: Link;
    statuses: Link;
    html: Link;
    issue: Link;
    review_comments: Link;
    review_comment: Link;
    self: Link;
  };
  author_association: Author_association;
  auto_merge: Auto_merge;
  draft?: boolean;
  merged: boolean;
  mergeable: boolean | null;
  rebaseable?: boolean | null;
  mergeable_state: string;
  merged_by: any;
  comments: number;
  review_comments: number;
  maintainer_can_modify: boolean;
  commits: number;
  additions: number;
  deletions: number;
  changed_files: number;
};
export type PullRequestReviewComment = {
  url: string;
  pull_request_review_id: number | null;
  id: number;
  node_id: string;
  diff_hunk: string;
  path: string;
  position: number;
  original_position: number;
  commit_id: string;
  original_commit_id: string;
  in_reply_to_id?: number;
  user: SimpleUser;
  body: string;
  created_at: Date;
  updated_at: Date;
  html_url: string;
  pull_request_url: string;
  author_association: Author_association;
  _links: {
    self: {
      href: string;
    };
    html: {
      href: string;
    };
    pull_request: {
      href: string;
    };
  };
  start_line?: number | null;
  original_start_line?: number | null;
  start_side?: ('LEFT' | 'RIGHT') | null;
  line?: number;
  original_line?: number;
  side?: 'LEFT' | 'RIGHT';
  reactions?: ReactionRollup;
  body_html?: string;
  body_text?: string;
};
export type PullRequestMergeResult = {
  sha: string;
  merged: boolean;
  message: string;
};
export type PullRequestReviewRequest = {
  users: SimpleUser[];
  teams: TeamSimple[];
};
export type PullRequestReview = {
  id: number;
  node_id: string;
  user: any;
  body: string;
  state: string;
  html_url: string;
  pull_request_url: string;
  _links: {
    html: {
      href: string;
    };
    pull_request: {
      href: string;
    };
  };
  submitted_at?: Date;
  commit_id: string;
  body_html?: string;
  body_text?: string;
  author_association: Author_association;
};
export type ReviewComment = {
  url: string;
  pull_request_review_id: number | null;
  id: number;
  node_id: string;
  diff_hunk: string;
  path: string;
  position: number | null;
  original_position: number;
  commit_id: string;
  original_commit_id: string;
  in_reply_to_id?: number;
  user: any;
  body: string;
  created_at: Date;
  updated_at: Date;
  html_url: string;
  pull_request_url: string;
  author_association: Author_association;
  _links: {
    self: Link;
    html: Link;
    pull_request: Link;
  };
  body_text?: string;
  body_html?: string;
  side?: 'LEFT' | 'RIGHT';
  start_side?: ('LEFT' | 'RIGHT') | null;
  line?: number;
  original_line?: number;
  start_line?: number | null;
  original_start_line?: number | null;
};
export type ReleaseAsset = {
  url: string;
  browser_download_url: string;
  id: number;
  node_id: string;
  name: string;
  label: string | null;
  state: 'uploaded' | 'open';
  content_type: string;
  size: number;
  download_count: number;
  created_at: Date;
  updated_at: Date;
  uploader: any;
};
export type Release = {
  url: string;
  html_url: string;
  assets_url: string;
  upload_url: string;
  tarball_url: string | null;
  zipball_url: string | null;
  id: number;
  node_id: string;
  tag_name: string;
  target_commitish: string;
  name: string | null;
  body?: string | null;
  draft: boolean;
  prerelease: boolean;
  created_at: Date;
  published_at: Date | null;
  author: SimpleUser;
  assets: ReleaseAsset[];
  body_html?: string;
  body_text?: string;
};
export type SecretScanningAlertState = 'open' | 'resolved';
export type SecretScanningAlertResolution = string | null;
export type SecretScanningAlert = {
  number?: AlertNumber;
  created_at?: AlertCreatedAt;
  url?: AlertUrl;
  html_url?: AlertHtmlUrl;
  state?: SecretScanningAlertState;
  resolution?: SecretScanningAlertResolution;
  resolved_at?: Date | null;
  resolved_by?: SimpleUser;
  secret_type?: string;
  secret?: string;
};
export type Stargazer = {
  starred_at: Date;
  user: any;
};
export type CodeFrequencyStat = number[];
export type CommitActivity = {
  days: number[];
  total: number;
  week: number;
};
export type ContributorActivity = {
  author: any;
  total: number;
  weeks: {
    w?: string;
    a?: number;
    d?: number;
    c?: number;
  }[];
};
export type ParticipationStats = {
  all: number[];
  owner: number[];
};
export type RepositorySubscription = {
  subscribed: boolean;
  ignored: boolean;
  reason: string | null;
  created_at: Date;
  url: string;
  repository_url: string;
};
export type Tag = {
  name: string;
  commit: {
    sha: string;
    url: string;
  };
  zipball_url: string;
  tarball_url: string;
  node_id: string;
};
export type Topic = {
  names: string[];
};
export type Traffic = {
  timestamp: Date;
  uniques: number;
  count: number;
};
export type CloneTraffic = {
  count: number;
  uniques: number;
  clones: Traffic[];
};
export type ContentTraffic = {
  path: string;
  title: string;
  count: number;
  uniques: number;
};
export type ReferrerTraffic = {
  referrer: string;
  count: number;
  uniques: number;
};
export type ViewTraffic = {
  count: number;
  uniques: number;
  views: Traffic[];
};
export type ScimGroupListEnterprise = {
  schemas: string[];
  totalResults: number;
  itemsPerPage: number;
  startIndex: number;
  Resources: {
    schemas: string[];
    id: string;
    externalId?: string | null;
    displayName?: string;
    members?: {
      value?: string;
      $ref?: string;
      display?: string;
    }[];
    meta?: {
      resourceType?: string;
      created?: string;
      lastModified?: string;
      location?: string;
    };
  }[];
};
export type ScimEnterpriseGroup = {
  schemas: string[];
  id: string;
  externalId?: string | null;
  displayName?: string;
  members?: {
    value?: string;
    $ref?: string;
    display?: string;
  }[];
  meta?: {
    resourceType?: string;
    created?: string;
    lastModified?: string;
    location?: string;
  };
};
export type ScimUserListEnterprise = {
  schemas: string[];
  totalResults: number;
  itemsPerPage: number;
  startIndex: number;
  Resources: {
    schemas: string[];
    id: string;
    externalId?: string;
    userName?: string;
    name?: {
      givenName?: string;
      familyName?: string;
    };
    emails?: {
      value?: string;
      primary?: boolean;
      type?: string;
    }[];
    groups?: {
      value?: string;
    }[];
    active?: boolean;
    meta?: {
      resourceType?: string;
      created?: string;
      lastModified?: string;
      location?: string;
    };
  }[];
};
export type ScimEnterpriseUser = {
  schemas: string[];
  id: string;
  externalId?: string;
  userName?: string;
  name?: {
    givenName?: string;
    familyName?: string;
  };
  emails?: {
    value?: string;
    type?: string;
    primary?: boolean;
  }[];
  groups?: {
    value?: string;
  }[];
  active?: boolean;
  meta?: {
    resourceType?: string;
    created?: string;
    lastModified?: string;
    location?: string;
  };
};
export type ScimUser = {
  schemas: string[];
  id: string;
  externalId: string | null;
  userName: string | null;
  displayName?: string | null;
  name: {
    givenName: string | null;
    familyName: string | null;
    formatted?: string | null;
  };
  emails: {
    value: string;
    primary?: boolean;
  }[];
  active: boolean;
  meta: {
    resourceType?: string;
    created?: Date;
    lastModified?: Date;
    location?: string;
  };
  organization_id?: number;
  operations?: {
    op: 'add' | 'remove' | 'replace';
    path?: string;
    value?: string | any | any[];
  }[];
  groups?: any[];
};
export type ScimUserList = {
  schemas: string[];
  totalResults: number;
  itemsPerPage: number;
  startIndex: number;
  Resources: ScimUser[];
};
export type SearchResultTextMatches = {
  object_url?: string;
  object_type?: string | null;
  property?: string;
  fragment?: string;
  matches?: {
    text?: string;
    indices?: number[];
  }[];
}[];
export type CodeSearchResultItem = {
  name: string;
  path: string;
  sha: string;
  url: string;
  git_url: string;
  html_url: string;
  repository: MinimalRepository;
  score: number;
  file_size?: number;
  language?: string | null;
  last_modified_at?: Date;
  line_numbers?: string[];
  text_matches?: SearchResultTextMatches;
};
export type CommitSearchResultItem = {
  url: string;
  sha: string;
  html_url: string;
  comments_url: string;
  commit: {
    author: {
      name: string;
      email: string;
      date: Date;
    };
    committer: any;
    comment_count: number;
    message: string;
    tree: {
      sha: string;
      url: string;
    };
    url: string;
    verification?: Verification;
  };
  author: any;
  committer: any;
  parents: {
    url?: string;
    html_url?: string;
    sha?: string;
  }[];
  repository: MinimalRepository;
  score: number;
  node_id: string;
  text_matches?: SearchResultTextMatches;
};
export type IssueSearchResultItem = {
  url: string;
  repository_url: string;
  labels_url: string;
  comments_url: string;
  events_url: string;
  html_url: string;
  id: number;
  node_id: string;
  number: number;
  title: string;
  locked: boolean;
  active_lock_reason?: string | null;
  assignees?: SimpleUser[] | null;
  user: any;
  labels: {
    id?: number;
    node_id?: string;
    url?: string;
    name?: string;
    color?: string;
    default?: boolean;
    description?: string | null;
  }[];
  state: string;
  assignee: any;
  milestone: any;
  comments: number;
  created_at: Date;
  updated_at: Date;
  closed_at: Date | null;
  text_matches?: SearchResultTextMatches;
  pull_request?: {
    merged_at?: Date | null;
    diff_url: string | null;
    html_url: string | null;
    patch_url: string | null;
    url: string | null;
  };
  body?: string;
  score: number;
  author_association: Author_association;
  draft?: boolean;
  repository?: Repository;
  body_html?: string;
  body_text?: string;
  timeline_url?: string;
  performed_via_github_app?: any;
};
export type LabelSearchResultItem = {
  id: number;
  node_id: string;
  url: string;
  name: string;
  color: string;
  default: boolean;
  description: string | null;
  score: number;
  text_matches?: SearchResultTextMatches;
};
export type RepoSearchResultItem = {
  id: number;
  node_id: string;
  name: string;
  full_name: string;
  owner: any;
  private: boolean;
  html_url: string;
  description: string | null;
  fork: boolean;
  url: string;
  created_at: Date;
  updated_at: Date;
  pushed_at: Date;
  homepage: string | null;
  size: number;
  stargazers_count: number;
  watchers_count: number;
  language: string | null;
  forks_count: number;
  open_issues_count: number;
  master_branch?: string;
  default_branch: string;
  score: number;
  forks_url: string;
  keys_url: string;
  collaborators_url: string;
  teams_url: string;
  hooks_url: string;
  issue_events_url: string;
  events_url: string;
  assignees_url: string;
  branches_url: string;
  tags_url: string;
  blobs_url: string;
  git_tags_url: string;
  git_refs_url: string;
  trees_url: string;
  statuses_url: string;
  languages_url: string;
  stargazers_url: string;
  contributors_url: string;
  subscribers_url: string;
  subscription_url: string;
  commits_url: string;
  git_commits_url: string;
  comments_url: string;
  issue_comment_url: string;
  contents_url: string;
  compare_url: string;
  merges_url: string;
  archive_url: string;
  downloads_url: string;
  issues_url: string;
  pulls_url: string;
  milestones_url: string;
  notifications_url: string;
  labels_url: string;
  releases_url: string;
  deployments_url: string;
  git_url: string;
  ssh_url: string;
  clone_url: string;
  svn_url: string;
  forks: number;
  open_issues: number;
  watchers: number;
  topics?: string[];
  mirror_url: string | null;
  has_issues: boolean;
  has_projects: boolean;
  has_pages: boolean;
  has_wiki: boolean;
  has_downloads: boolean;
  archived: boolean;
  disabled: boolean;
  license: any;
  permissions?: {
    admin: boolean;
    pull: boolean;
    push: boolean;
  };
  text_matches?: SearchResultTextMatches;
  temp_clone_token?: string;
  allow_merge_commit?: boolean;
  allow_squash_merge?: boolean;
  allow_rebase_merge?: boolean;
  delete_branch_on_merge?: boolean;
};
export type TopicSearchResultItem = {
  name: string;
  display_name: string | null;
  short_description: string | null;
  description: string | null;
  created_by: string | null;
  released: string | null;
  created_at: Date;
  updated_at: Date;
  featured: boolean;
  curated: boolean;
  score: number;
  repository_count?: number | null;
  logo_url?: string | null;
  text_matches?: SearchResultTextMatches;
  related?:
    | {
        topic_relation?: {
          id?: number;
          name?: string;
          topic_id?: number;
          relation_type?: string;
        };
      }[]
    | null;
  aliases?:
    | {
        topic_relation?: {
          id?: number;
          name?: string;
          topic_id?: number;
          relation_type?: string;
        };
      }[]
    | null;
};
export type UserSearchResultItem = {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string | null;
  url: string;
  html_url: string;
  followers_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  received_events_url: string;
  type: string;
  score: number;
  following_url: string;
  gists_url: string;
  starred_url: string;
  events_url: string;
  public_repos?: number;
  public_gists?: number;
  followers?: number;
  following?: number;
  created_at?: Date;
  updated_at?: Date;
  name?: string | null;
  bio?: string | null;
  email?: string | null;
  location?: string | null;
  site_admin: boolean;
  hireable?: boolean | null;
  text_matches?: SearchResultTextMatches;
  blog?: string | null;
  company?: string | null;
  suspended_at?: Date | null;
};
export type PrivateUser = {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string | null;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: string;
  site_admin: boolean;
  name: string | null;
  company: string | null;
  blog: string | null;
  location: string | null;
  email: string | null;
  hireable: boolean | null;
  bio: string | null;
  twitter_username?: string | null;
  public_repos: number;
  public_gists: number;
  followers: number;
  following: number;
  created_at: Date;
  updated_at: Date;
  private_gists: number;
  total_private_repos: number;
  owned_private_repos: number;
  disk_usage: number;
  collaborators: number;
  two_factor_authentication: boolean;
  plan?: {
    collaborators: number;
    name: string;
    space: number;
    private_repos: number;
  };
  suspended_at?: Date | null;
  business_plus?: boolean;
  ldap_dn?: string;
};
export type PublicUser = {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string | null;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: string;
  site_admin: boolean;
  name: string | null;
  company: string | null;
  blog: string | null;
  location: string | null;
  email: string | null;
  hireable: boolean | null;
  bio: string | null;
  twitter_username?: string | null;
  public_repos: number;
  public_gists: number;
  followers: number;
  following: number;
  created_at: Date;
  updated_at: Date;
  plan?: {
    collaborators: number;
    name: string;
    space: number;
    private_repos: number;
  };
  suspended_at?: Date | null;
  private_gists?: number;
  total_private_repos?: number;
  owned_private_repos?: number;
  disk_usage?: number;
  collaborators?: number;
};
export type Email = {
  email: string;
  primary: boolean;
  verified: boolean;
  visibility: string | null;
};
export type GpgKey = {
  id: number;
  primary_key_id: number | null;
  key_id: string;
  public_key: string;
  emails: {
    email?: string;
    verified?: boolean;
  }[];
  subkeys: {
    id?: number;
    primary_key_id?: number;
    key_id?: string;
    public_key?: string;
    emails?: any[];
    subkeys?: any[];
    can_sign?: boolean;
    can_encrypt_comms?: boolean;
    can_encrypt_storage?: boolean;
    can_certify?: boolean;
    created_at?: string;
    expires_at?: string | null;
    raw_key?: string | null;
  }[];
  can_sign: boolean;
  can_encrypt_comms: boolean;
  can_encrypt_storage: boolean;
  can_certify: boolean;
  created_at: Date;
  expires_at: Date | null;
  raw_key: string | null;
};
export type Key = {
  key_id: string;
  key: string;
  id: number;
  url: string;
  title: string;
  created_at: Date;
  verified: boolean;
  read_only: boolean;
};
export type MarketplaceAccount = {
  url: string;
  id: number;
  type: string;
  node_id?: string;
  login: string;
  email?: string | null;
  organization_billing_email?: string | null;
};
export type UserMarketplacePurchase = {
  billing_cycle: string;
  next_billing_date: Date | null;
  unit_count: number | null;
  on_free_trial: boolean;
  free_trial_ends_on: Date | null;
  updated_at: Date | null;
  account: MarketplaceAccount;
  plan: MarketplaceListingPlan;
};
export type StarredRepository = {
  starred_at: Date;
  repo: Repository;
};
export type Hovercard = {
  contexts: {
    message: string;
    octicon: string;
  }[];
};
export type KeySimple = {
  id: number;
  key: string;
};
export class GithubClient {
  constructor(
    private server: r.BaseServerConfiguration,
    private http: r.HttpLibrary = new r.IsomorphicFetchHttpLibrary(),
    private resolver: r.SchemaRefResolver = new r.RefResolver(
      JSON.parse(
        '{"simple-user":{"title":"Simple User","description":"Simple User","type":"object","properties":{"login":{"type":"string","example":"octocat"},"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDQ6VXNlcjE="},"avatar_url":{"type":"string","format":"uri","example":"https://github.com/images/error/octocat_happy.gif"},"gravatar_id":{"type":"string","example":"41d064eb2195891e12d0413f63227ea7","nullable":true},"url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat"},"followers_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/followers"},"following_url":{"type":"string","example":"https://api.github.com/users/octocat/following{/other_user}"},"gists_url":{"type":"string","example":"https://api.github.com/users/octocat/gists{/gist_id}"},"starred_url":{"type":"string","example":"https://api.github.com/users/octocat/starred{/owner}{/repo}"},"subscriptions_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/subscriptions"},"organizations_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/orgs"},"repos_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/repos"},"events_url":{"type":"string","example":"https://api.github.com/users/octocat/events{/privacy}"},"received_events_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/received_events"},"type":{"type":"string","example":"User"},"site_admin":{"type":"boolean"},"starred_at":{"type":"string","example":"\\"2020-07-09T00:17:55Z\\""}},"required":["avatar_url","events_url","followers_url","following_url","gists_url","gravatar_id","html_url","id","node_id","login","organizations_url","received_events_url","repos_url","site_admin","starred_url","subscriptions_url","type","url"],"nullable":true},"integration":{"title":"GitHub app","description":"GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.","type":"object","properties":{"id":{"description":"Unique identifier of the GitHub app","example":37,"type":"integer"},"slug":{"description":"The slug name of the GitHub app","example":"probot-owners","type":"string"},"node_id":{"type":"string","example":"MDExOkludGVncmF0aW9uMQ=="},"owner":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"name":{"description":"The name of the GitHub app","example":"Probot Owners","type":"string"},"description":{"type":"string","example":"The description of the app.","nullable":true},"external_url":{"type":"string","format":"uri","example":"https://example.com"},"html_url":{"type":"string","format":"uri","example":"https://github.com/apps/super-ci"},"created_at":{"type":"string","format":"date-time","example":"2017-07-08T16:18:44-04:00"},"updated_at":{"type":"string","format":"date-time","example":"2017-07-08T16:18:44-04:00"},"permissions":{"description":"The set of permissions for the GitHub app","type":"object","properties":{"issues":{"type":"string"},"checks":{"type":"string"},"metadata":{"type":"string"},"contents":{"type":"string"},"deployments":{"type":"string"}},"additionalProperties":{"type":"string"},"example":{"issues":"read","deployments":"write"}},"events":{"description":"The list of events for the GitHub app","example":["label","deployment"],"type":"array","items":{"type":"string"}},"installations_count":{"description":"The number of installations associated with the GitHub app","example":5,"type":"integer"},"client_id":{"type":"string","example":"\\"Iv1.25b5d1e65ffc4022\\""},"client_secret":{"type":"string","example":"\\"1d4b2097ac622ba702d19de498f005747a8b21d3\\""},"webhook_secret":{"type":"string","example":"\\"6fba8f2fc8a7e8f2cca5577eddd82ca7586b3b6b\\""},"pem":{"type":"string","example":"\\"-----BEGIN RSA PRIVATE KEY-----\\\\nMIIEogIBAAKCAQEArYxrNYD/iT5CZVpRJu4rBKmmze3PVmT/gCo2ATUvDvZTPTey\\\\nxcGJ3vvrJXazKk06pN05TN29o98jrYz4cengG3YGsXPNEpKsIrEl8NhbnxapEnM9\\\\nJCMRe0P5JcPsfZlX6hmiT7136GRWiGOUba2X9+HKh8QJVLG5rM007TBER9/z9mWm\\\\nrJuNh+m5l320oBQY/Qq3A7wzdEfZw8qm/mIN0FCeoXH1L6B8xXWaAYBwhTEh6SSn\\\\nZHlO1Xu1JWDmAvBCi0RO5aRSKM8q9QEkvvHP4yweAtK3N8+aAbZ7ovaDhyGz8r6r\\\\nzhU1b8Uo0Z2ysf503WqzQgIajr7Fry7/kUwpgQIDAQABAoIBADwJp80Ko1xHPZDy\\\\nfcCKBDfIuPvkmSW6KumbsLMaQv1aGdHDwwTGv3t0ixSay8CGlxMRtRDyZPib6SvQ\\\\n6OH/lpfpbMdW2ErkksgtoIKBVrDilfrcAvrNZu7NxRNbhCSvN8q0s4ICecjbbVQh\\\\nnueSdlA6vGXbW58BHMq68uRbHkP+k+mM9U0mDJ1HMch67wlg5GbayVRt63H7R2+r\\\\nVxcna7B80J/lCEjIYZznawgiTvp3MSanTglqAYi+m1EcSsP14bJIB9vgaxS79kTu\\\\noiSo93leJbBvuGo8QEiUqTwMw4tDksmkLsoqNKQ1q9P7LZ9DGcujtPy4EZsamSJT\\\\ny8OJt0ECgYEA2lxOxJsQk2kI325JgKFjo92mQeUObIvPfSNWUIZQDTjniOI6Gv63\\\\nGLWVFrZcvQBWjMEQraJA9xjPbblV8PtfO87MiJGLWCHFxmPz2dzoedN+2Coxom8m\\\\nV95CLz8QUShuao6u/RYcvUaZEoYs5bHcTmy5sBK80JyEmafJPtCQVxMCgYEAy3ar\\\\nZr3yv4xRPEPMat4rseswmuMooSaK3SKub19WFI5IAtB/e7qR1Rj9JhOGcZz+OQrl\\\\nT78O2OFYlgOIkJPvRMrPpK5V9lslc7tz1FSh3BZMRGq5jSyD7ETSOQ0c8T2O/s7v\\\\nbeEPbVbDe4mwvM24XByH0GnWveVxaDl51ABD65sCgYB3ZAspUkOA5egVCh8kNpnd\\\\nSd6SnuQBE3ySRlT2WEnCwP9Ph6oPgn+oAfiPX4xbRqkL8q/k0BdHQ4h+zNwhk7+h\\\\nWtPYRAP1Xxnc/F+jGjb+DVaIaKGU18MWPg7f+FI6nampl3Q0KvfxwX0GdNhtio8T\\\\nTj1E+SnFwh56SRQuxSh2gwKBgHKjlIO5NtNSflsUYFM+hyQiPiqnHzddfhSG+/3o\\\\nm5nNaSmczJesUYreH5San7/YEy2UxAugvP7aSY2MxB+iGsiJ9WD2kZzTUlDZJ7RV\\\\nUzWsoqBR+eZfVJ2FUWWvy8TpSG6trh4dFxImNtKejCR1TREpSiTV3Zb1dmahK9GV\\\\nrK9NAoGAbBxRLoC01xfxCTgt5BDiBcFVh4fp5yYKwavJPLzHSpuDOrrI9jDn1oKN\\\\nonq5sDU1i391zfQvdrbX4Ova48BN+B7p63FocP/MK5tyyBoT8zQEk2+vWDOw7H/Z\\\\nu5dTCPxTIsoIwUw1I+7yIxqJzLPFgR2gVBwY1ra/8iAqCj+zeBw=\\\\n-----END RSA PRIVATE KEY-----\\\\n\\""}},"required":["id","node_id","owner","name","description","external_url","html_url","created_at","updated_at","permissions","events"],"additionalProperties":true},"basic-error":{"title":"Basic Error","description":"Basic Error","type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}},"validation-error-simple":{"title":"Validation Error Simple","description":"Validation Error Simple","type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"},"errors":{"type":"array","items":{"type":"string"}}}},"webhook-config-url":{"type":"string","description":"The URL to which the payloads will be delivered.","example":"https://example.com/webhook","format":"uri"},"webhook-config-content-type":{"type":"string","description":"The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.","example":"\\"json\\""},"webhook-config-secret":{"type":"string","description":"If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).","example":"\\"********\\""},"webhook-config-insecure-ssl":{"type":"string","description":"Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**","example":"\\"0\\""},"webhook-config":{"title":"Webhook Configuration","description":"Configuration object of the webhook","type":"object","properties":{"url":{"$ref":"#/components/schemas/webhook-config-url"},"content_type":{"$ref":"#/components/schemas/webhook-config-content-type"},"secret":{"$ref":"#/components/schemas/webhook-config-secret"},"insecure_ssl":{"$ref":"#/components/schemas/webhook-config-insecure-ssl"}}},"enterprise":{"title":"Enterprise","description":"An enterprise account","type":"object","properties":{"description":{"description":"A short description of the enterprise.","type":"string","nullable":true},"html_url":{"type":"string","format":"uri","example":"https://github.com/enterprises/octo-business"},"website_url":{"description":"The enterprise\'s website URL.","type":"string","nullable":true,"format":"uri"},"id":{"description":"Unique identifier of the enterprise","example":42,"type":"integer"},"node_id":{"type":"string","example":"MDEwOlJlcG9zaXRvcnkxMjk2MjY5"},"name":{"description":"The name of the enterprise.","type":"string","example":"Octo Business"},"slug":{"description":"The slug url identifier for the enterprise.","type":"string","example":"octo-business"},"created_at":{"type":"string","nullable":true,"format":"date-time","example":"2019-01-26T19:01:12Z"},"updated_at":{"type":"string","nullable":true,"format":"date-time","example":"2019-01-26T19:14:43Z"},"avatar_url":{"type":"string","format":"uri"}},"required":["id","node_id","name","slug","html_url","created_at","updated_at","avatar_url"]},"installation":{"title":"Installation","description":"Installation","type":"object","properties":{"id":{"description":"The ID of the installation.","type":"integer","example":1},"account":{"nullable":true,"anyOf":[{"$ref":"#/components/schemas/simple-user"},{"$ref":"#/components/schemas/enterprise"}]},"repository_selection":{"description":"Describe whether all repositories have been selected or there\'s a selection involved","type":"string","enum":["all","selected"]},"access_tokens_url":{"type":"string","format":"uri","example":"https://api.github.com/installations/1/access_tokens"},"repositories_url":{"type":"string","format":"uri","example":"https://api.github.com/installation/repositories"},"html_url":{"type":"string","format":"uri","example":"https://github.com/organizations/github/settings/installations/1"},"app_id":{"type":"integer","example":1},"target_id":{"description":"The ID of the user or organization this token is being scoped to.","type":"integer"},"target_type":{"type":"string","example":"Organization"},"permissions":{"type":"object","example":{"issues":"read","deployments":"write"},"properties":{"deployments":{"type":"string"},"checks":{"type":"string"},"metadata":{"type":"string"},"contents":{"type":"string"},"pull_requests":{"type":"string"},"statuses":{"type":"string"},"issues":{"type":"string","example":"\\"read\\""},"organization_administration":{"type":"string","example":"\\"read\\""}}},"events":{"type":"array","items":{"type":"string"}},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"single_file_name":{"type":"string","example":"config.yaml","nullable":true},"has_multiple_single_files":{"type":"boolean","example":true},"single_file_paths":{"type":"array","items":{"type":"string"},"example":["config.yml",".github/issue_TEMPLATE.md"]},"app_slug":{"type":"string","example":"github-actions"},"suspended_by":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"suspended_at":{"type":"string","format":"date-time","nullable":true},"contact_email":{"type":"string","example":"\\"test_13f1e99741e3e004@d7e1eb0bc0a1ba12.com\\"","nullable":true}},"required":["id","app_id","app_slug","target_id","target_type","single_file_name","repository_selection","access_tokens_url","html_url","repositories_url","events","account","permissions","created_at","updated_at"]},"app-permissions":{"title":"App Permissions","type":"object","description":"The permissions granted to the user-to-server access token.","properties":{"actions":{"type":"string","description":"The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts. Can be one of: `read` or `write`.","enum":["read","write"]},"administration":{"type":"string","description":"The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation. Can be one of: `read` or `write`.","enum":["read","write"]},"checks":{"type":"string","description":"The level of permission to grant the access token for checks on code. Can be one of: `read` or `write`.","enum":["read","write"]},"content_references":{"type":"string","description":"The level of permission to grant the access token for notification of content references and creation content attachments. Can be one of: `read` or `write`.","enum":["read","write"]},"contents":{"type":"string","description":"The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges. Can be one of: `read` or `write`.","enum":["read","write"]},"deployments":{"type":"string","description":"The level of permission to grant the access token for deployments and deployment statuses. Can be one of: `read` or `write`.","enum":["read","write"]},"environments":{"type":"string","description":"The level of permission to grant the access token for managing repository environments. Can be one of: `read` or `write`.","enum":["read","write"]},"issues":{"type":"string","description":"The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones. Can be one of: `read` or `write`.","enum":["read","write"]},"metadata":{"type":"string","description":"The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata. Can be one of: `read` or `write`.","enum":["read","write"]},"packages":{"type":"string","description":"The level of permission to grant the access token for packages published to GitHub Packages. Can be one of: `read` or `write`.","enum":["read","write"]},"pages":{"type":"string","description":"The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds. Can be one of: `read` or `write`.","enum":["read","write"]},"pull_requests":{"type":"string","description":"The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges. Can be one of: `read` or `write`.","enum":["read","write"]},"repository_hooks":{"type":"string","description":"The level of permission to grant the access token to manage the post-receive hooks for a repository. Can be one of: `read` or `write`.","enum":["read","write"]},"repository_projects":{"type":"string","description":"The level of permission to grant the access token to manage repository projects, columns, and cards. Can be one of: `read`, `write`, or `admin`.","enum":["read","write","admin"]},"secret_scanning_alerts":{"type":"string","description":"The level of permission to grant the access token to view and manage secret scanning alerts. Can be one of: `read` or `write`.","enum":["read","write"]},"secrets":{"type":"string","description":"The level of permission to grant the access token to manage repository secrets. Can be one of: `read` or `write`.","enum":["read","write"]},"security_events":{"type":"string","description":"The level of permission to grant the access token to view and manage security events like code scanning alerts. Can be one of: `read` or `write`.","enum":["read","write"]},"single_file":{"type":"string","description":"The level of permission to grant the access token to manage just a single file. Can be one of: `read` or `write`.","enum":["read","write"]},"statuses":{"type":"string","description":"The level of permission to grant the access token for commit statuses. Can be one of: `read` or `write`.","enum":["read","write"]},"vulnerability_alerts":{"type":"string","description":"The level of permission to grant the access token to retrieve Dependabot alerts. Can be one of: `read`.","enum":["read"]},"workflows":{"type":"string","description":"The level of permission to grant the access token to update GitHub Actions workflow files. Can be one of: `write`.","enum":["write"]},"members":{"type":"string","description":"The level of permission to grant the access token for organization teams and members. Can be one of: `read` or `write`.","enum":["read","write"]},"organization_administration":{"type":"string","description":"The level of permission to grant the access token to manage access to an organization. Can be one of: `read` or `write`.","enum":["read","write"]},"organization_hooks":{"type":"string","description":"The level of permission to grant the access token to manage the post-receive hooks for an organization. Can be one of: `read` or `write`.","enum":["read","write"]},"organization_plan":{"type":"string","description":"The level of permission to grant the access token for viewing an organization\'s plan. Can be one of: `read`.","enum":["read"]},"organization_projects":{"type":"string","description":"The level of permission to grant the access token to manage organization projects, columns, and cards. Can be one of: `read`, `write`, or `admin`.","enum":["read","write","admin"]},"organization_secrets":{"type":"string","description":"The level of permission to grant the access token to manage organization secrets. Can be one of: `read` or `write`.","enum":["read","write"]},"organization_self_hosted_runners":{"type":"string","description":"The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization. Can be one of: `read` or `write`.","enum":["read","write"]},"organization_user_blocking":{"type":"string","description":"The level of permission to grant the access token to view and manage users blocked by the organization. Can be one of: `read` or `write`.","enum":["read","write"]},"team_discussions":{"type":"string","description":"The level of permission to grant the access token to manage team discussions and related comments. Can be one of: `read` or `write`.","enum":["read","write"]}},"example":{"contents":"read","issues":"read","deployments":"write","single_file":"read"}},"license-simple":{"title":"License Simple","description":"License Simple","type":"object","properties":{"key":{"type":"string","example":"mit"},"name":{"type":"string","example":"MIT License"},"url":{"type":"string","nullable":true,"format":"uri","example":"https://api.github.com/licenses/mit"},"spdx_id":{"type":"string","nullable":true,"example":"MIT"},"node_id":{"type":"string","example":"MDc6TGljZW5zZW1pdA=="},"html_url":{"type":"string","format":"uri"}},"required":["key","name","url","spdx_id","node_id"]},"repository":{"title":"Repository","description":"A git repository","type":"object","properties":{"id":{"description":"Unique identifier of the repository","example":42,"type":"integer"},"node_id":{"type":"string","example":"MDEwOlJlcG9zaXRvcnkxMjk2MjY5"},"name":{"description":"The name of the repository.","type":"string","example":"Team Environment"},"full_name":{"type":"string","example":"octocat/Hello-World"},"license":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/license-simple"}]},"forks":{"type":"integer"},"permissions":{"type":"object","properties":{"admin":{"type":"boolean"},"pull":{"type":"boolean"},"triage":{"type":"boolean"},"push":{"type":"boolean"},"maintain":{"type":"boolean"}},"required":["admin","pull","push"]},"owner":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"private":{"description":"Whether the repository is private or public.","default":false,"type":"boolean"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World"},"description":{"type":"string","example":"This your first repo!","nullable":true},"fork":{"type":"boolean"},"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World"},"archive_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}"},"assignees_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/assignees{/user}"},"blobs_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}"},"branches_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/branches{/branch}"},"collaborators_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}"},"comments_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/comments{/number}"},"commits_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/commits{/sha}"},"compare_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}"},"contents_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/contents/{+path}"},"contributors_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/contributors"},"deployments_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/deployments"},"downloads_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/downloads"},"events_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/events"},"forks_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/forks"},"git_commits_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/commits{/sha}"},"git_refs_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/refs{/sha}"},"git_tags_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/tags{/sha}"},"git_url":{"type":"string","example":"git:github.com/octocat/Hello-World.git"},"issue_comment_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues/comments{/number}"},"issue_events_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues/events{/number}"},"issues_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues{/number}"},"keys_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/keys{/key_id}"},"labels_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/labels{/name}"},"languages_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/languages"},"merges_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/merges"},"milestones_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/milestones{/number}"},"notifications_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}"},"pulls_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/pulls{/number}"},"releases_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/releases{/id}"},"ssh_url":{"type":"string","example":"git@github.com:octocat/Hello-World.git"},"stargazers_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/stargazers"},"statuses_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/statuses/{sha}"},"subscribers_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/subscribers"},"subscription_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/subscription"},"tags_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/tags"},"teams_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/teams"},"trees_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/trees{/sha}"},"clone_url":{"type":"string","example":"https://github.com/octocat/Hello-World.git"},"mirror_url":{"type":"string","format":"uri","example":"git:git.example.com/octocat/Hello-World","nullable":true},"hooks_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/hooks"},"svn_url":{"type":"string","format":"uri","example":"https://svn.github.com/octocat/Hello-World"},"homepage":{"type":"string","format":"uri","example":"https://github.com","nullable":true},"language":{"type":"string","nullable":true},"forks_count":{"type":"integer","example":9},"stargazers_count":{"type":"integer","example":80},"watchers_count":{"type":"integer","example":80},"size":{"type":"integer","example":108},"default_branch":{"description":"The default branch of the repository.","type":"string","example":"master"},"open_issues_count":{"type":"integer","example":0},"is_template":{"description":"Whether this repository acts as a template that can be used to generate new repositories.","default":false,"type":"boolean","example":true},"topics":{"type":"array","items":{"type":"string"}},"has_issues":{"description":"Whether issues are enabled.","default":true,"type":"boolean","example":true},"has_projects":{"description":"Whether projects are enabled.","default":true,"type":"boolean","example":true},"has_wiki":{"description":"Whether the wiki is enabled.","default":true,"type":"boolean","example":true},"has_pages":{"type":"boolean"},"has_downloads":{"description":"Whether downloads are enabled.","default":true,"type":"boolean","example":true},"archived":{"description":"Whether the repository is archived.","default":false,"type":"boolean"},"disabled":{"type":"boolean","description":"Returns whether or not this repository disabled."},"visibility":{"description":"The repository visibility: public, private, or internal.","default":"public","type":"string"},"pushed_at":{"type":"string","format":"date-time","example":"2011-01-26T19:06:43Z","nullable":true},"created_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z","nullable":true},"updated_at":{"type":"string","format":"date-time","example":"2011-01-26T19:14:43Z","nullable":true},"allow_rebase_merge":{"description":"Whether to allow rebase merges for pull requests.","default":true,"type":"boolean","example":true},"template_repository":{"nullable":true,"type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"name":{"type":"string"},"full_name":{"type":"string"},"owner":{"type":"object","properties":{"login":{"type":"string"},"id":{"type":"integer"},"node_id":{"type":"string"},"avatar_url":{"type":"string"},"gravatar_id":{"type":"string"},"url":{"type":"string"},"html_url":{"type":"string"},"followers_url":{"type":"string"},"following_url":{"type":"string"},"gists_url":{"type":"string"},"starred_url":{"type":"string"},"subscriptions_url":{"type":"string"},"organizations_url":{"type":"string"},"repos_url":{"type":"string"},"events_url":{"type":"string"},"received_events_url":{"type":"string"},"type":{"type":"string"},"site_admin":{"type":"boolean"}}},"private":{"type":"boolean"},"html_url":{"type":"string"},"description":{"type":"string"},"fork":{"type":"boolean"},"url":{"type":"string"},"archive_url":{"type":"string"},"assignees_url":{"type":"string"},"blobs_url":{"type":"string"},"branches_url":{"type":"string"},"collaborators_url":{"type":"string"},"comments_url":{"type":"string"},"commits_url":{"type":"string"},"compare_url":{"type":"string"},"contents_url":{"type":"string"},"contributors_url":{"type":"string"},"deployments_url":{"type":"string"},"downloads_url":{"type":"string"},"events_url":{"type":"string"},"forks_url":{"type":"string"},"git_commits_url":{"type":"string"},"git_refs_url":{"type":"string"},"git_tags_url":{"type":"string"},"git_url":{"type":"string"},"issue_comment_url":{"type":"string"},"issue_events_url":{"type":"string"},"issues_url":{"type":"string"},"keys_url":{"type":"string"},"labels_url":{"type":"string"},"languages_url":{"type":"string"},"merges_url":{"type":"string"},"milestones_url":{"type":"string"},"notifications_url":{"type":"string"},"pulls_url":{"type":"string"},"releases_url":{"type":"string"},"ssh_url":{"type":"string"},"stargazers_url":{"type":"string"},"statuses_url":{"type":"string"},"subscribers_url":{"type":"string"},"subscription_url":{"type":"string"},"tags_url":{"type":"string"},"teams_url":{"type":"string"},"trees_url":{"type":"string"},"clone_url":{"type":"string"},"mirror_url":{"type":"string"},"hooks_url":{"type":"string"},"svn_url":{"type":"string"},"homepage":{"type":"string"},"language":{"type":"string"},"forks_count":{"type":"integer"},"stargazers_count":{"type":"integer"},"watchers_count":{"type":"integer"},"size":{"type":"integer"},"default_branch":{"type":"string"},"open_issues_count":{"type":"integer"},"is_template":{"type":"boolean"},"topics":{"type":"array","items":{"type":"string"}},"has_issues":{"type":"boolean"},"has_projects":{"type":"boolean"},"has_wiki":{"type":"boolean"},"has_pages":{"type":"boolean"},"has_downloads":{"type":"boolean"},"archived":{"type":"boolean"},"disabled":{"type":"boolean"},"visibility":{"type":"string"},"pushed_at":{"type":"string"},"created_at":{"type":"string"},"updated_at":{"type":"string"},"permissions":{"type":"object","properties":{"admin":{"type":"boolean"},"push":{"type":"boolean"},"pull":{"type":"boolean"}}},"allow_rebase_merge":{"type":"boolean"},"temp_clone_token":{"type":"string"},"allow_squash_merge":{"type":"boolean"},"delete_branch_on_merge":{"type":"boolean"},"allow_merge_commit":{"type":"boolean"},"subscribers_count":{"type":"integer"},"network_count":{"type":"integer"}}},"temp_clone_token":{"type":"string"},"allow_squash_merge":{"description":"Whether to allow squash merges for pull requests.","default":true,"type":"boolean","example":true},"delete_branch_on_merge":{"description":"Whether to delete head branches when pull requests are merged","default":false,"type":"boolean","example":false},"allow_merge_commit":{"description":"Whether to allow merge commits for pull requests.","default":true,"type":"boolean","example":true},"subscribers_count":{"type":"integer"},"network_count":{"type":"integer"},"open_issues":{"type":"integer"},"watchers":{"type":"integer"},"master_branch":{"type":"string"},"starred_at":{"type":"string","example":"\\"2020-07-09T00:17:42Z\\""}},"required":["archive_url","assignees_url","blobs_url","branches_url","collaborators_url","comments_url","commits_url","compare_url","contents_url","contributors_url","deployments_url","description","downloads_url","events_url","fork","forks_url","full_name","git_commits_url","git_refs_url","git_tags_url","hooks_url","html_url","id","node_id","issue_comment_url","issue_events_url","issues_url","keys_url","labels_url","languages_url","merges_url","milestones_url","name","notifications_url","owner","private","pulls_url","releases_url","stargazers_url","statuses_url","subscribers_url","subscription_url","tags_url","teams_url","trees_url","url","clone_url","default_branch","forks","forks_count","git_url","has_downloads","has_issues","has_projects","has_wiki","has_pages","homepage","language","archived","disabled","mirror_url","open_issues","open_issues_count","license","pushed_at","size","ssh_url","stargazers_count","svn_url","watchers","watchers_count","created_at","updated_at"]},"installation-token":{"title":"Installation Token","description":"Authentication token for a GitHub App installed on a user or org.","type":"object","properties":{"token":{"type":"string"},"expires_at":{"type":"string"},"permissions":{"type":"object","properties":{"issues":{"type":"string"},"contents":{"type":"string"},"metadata":{"type":"string","example":"read"},"single_file":{"type":"string","example":"read"}}},"repository_selection":{"type":"string","enum":["all","selected"]},"repositories":{"type":"array","items":{"$ref":"#/components/schemas/repository"}},"single_file":{"type":"string","example":"README.md"},"has_multiple_single_files":{"type":"boolean","example":true},"single_file_paths":{"type":"array","items":{"type":"string"},"example":["config.yml",".github/issue_TEMPLATE.md"]}},"required":["token","expires_at"]},"validation-error":{"title":"Validation Error","description":"Validation Error","type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"},"errors":{"type":"array","items":{"type":"object","required":["code"],"properties":{"resource":{"type":"string"},"field":{"type":"string"},"message":{"type":"string"},"code":{"type":"string"},"index":{"type":"integer"},"value":{"oneOf":[{"type":"string","nullable":true},{"type":"integer","nullable":true},{"type":"array","nullable":true,"items":{"type":"string"}}]}}}}}},"application-grant":{"title":"Application Grant","description":"The authorization associated with an OAuth Access.","type":"object","properties":{"id":{"type":"integer","example":1},"url":{"type":"string","format":"uri","example":"https://api.github.com/applications/grants/1"},"app":{"type":"object","properties":{"client_id":{"type":"string"},"name":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["client_id","name","url"]},"created_at":{"type":"string","format":"date-time","example":"2011-09-06T17:26:27Z"},"updated_at":{"type":"string","format":"date-time","example":"2011-09-06T20:39:23Z"},"scopes":{"type":"array","items":{"type":"string"},"example":["public_repo"]},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]}},"required":["app","id","scopes","url","created_at","updated_at"]},"scoped-installation":{"title":"Scoped Installation","type":"object","properties":{"permissions":{"$ref":"#/components/schemas/app-permissions"},"repository_selection":{"description":"Describe whether all repositories have been selected or there\'s a selection involved","type":"string","enum":["all","selected"]},"single_file_name":{"type":"string","example":"config.yaml","nullable":true},"has_multiple_single_files":{"type":"boolean","example":true},"single_file_paths":{"type":"array","items":{"type":"string"},"example":["config.yml",".github/issue_TEMPLATE.md"]},"repositories_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/repos"},"account":{"$ref":"#/components/schemas/simple-user"}},"required":["permissions","repository_selection","single_file_name","repositories_url","account"]},"authorization":{"title":"Authorization","description":"The authorization for an OAuth app, GitHub App, or a Personal Access Token.","type":"object","properties":{"id":{"type":"integer"},"url":{"type":"string","format":"uri"},"scopes":{"description":"A list of scopes that this authorization is in.","type":"array","items":{"type":"string"},"nullable":true},"token":{"type":"string"},"token_last_eight":{"type":"string","nullable":true},"hashed_token":{"type":"string","nullable":true},"app":{"type":"object","properties":{"client_id":{"type":"string"},"name":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["client_id","name","url"]},"note":{"type":"string","nullable":true},"note_url":{"type":"string","format":"uri","nullable":true},"updated_at":{"type":"string","format":"date-time"},"created_at":{"type":"string","format":"date-time"},"fingerprint":{"type":"string","nullable":true},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"installation":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/scoped-installation"}]}},"required":["app","id","note","note_url","scopes","token","hashed_token","token_last_eight","fingerprint","url","created_at","updated_at"]},"code-of-conduct":{"title":"Code Of Conduct","description":"Code Of Conduct","type":"object","properties":{"key":{"type":"string","example":"contributor_covenant"},"name":{"type":"string","example":"Contributor Covenant"},"url":{"type":"string","format":"uri","example":"https://api.github.com/codes_of_conduct/contributor_covenant"},"body":{"type":"string","example":"# Contributor Covenant Code of Conduct\\n\\n## Our Pledge\\n\\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\\n\\n## Our Standards\\n\\nExamples of behavior that contributes to creating a positive environment include:\\n\\n* Using welcoming and inclusive language\\n* Being respectful of differing viewpoints and experiences\\n* Gracefully accepting constructive criticism\\n* Focusing on what is best for the community\\n* Showing empathy towards other community members\\n\\nExamples of unacceptable behavior by participants include:\\n\\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\\n* Trolling, insulting/derogatory comments, and personal or political attacks\\n* Public or private harassment\\n* Publishing others\' private information, such as a physical or electronic address, without explicit permission\\n* Other conduct which could reasonably be considered inappropriate in a professional setting\\n\\n## Our Responsibilities\\n\\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response\\n                  to any instances of unacceptable behavior.\\n\\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\\n\\n## Scope\\n\\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address,\\n                  posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\\n\\n## Enforcement\\n\\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [EMAIL]. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\\n\\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\'s leadership.\\n\\n## Attribution\\n\\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\\n\\n[homepage]: http://contributor-covenant.org\\n[version]: http://contributor-covenant.org/version/1/4/\\n"},"html_url":{"type":"string","format":"uri","nullable":true}},"required":["url","html_url","key","name"]},"content-reference-attachment":{"title":"ContentReferenceAttachment","description":"Content Reference attachments allow you to provide context around URLs posted in comments","type":"object","properties":{"id":{"description":"The ID of the attachment","example":21,"type":"integer"},"title":{"description":"The title of the attachment","example":"Title of the attachment","type":"string","maxLength":1024},"body":{"description":"The body of the attachment","example":"Body of the attachment","type":"string","maxLength":262144},"node_id":{"description":"The node_id of the content attachment","example":"MDE3OkNvbnRlbnRBdHRhY2htZW50MjE=","type":"string"}},"required":["id","title","body"]},"enabled-organizations":{"type":"string","description":"The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.","enum":["all","none","selected"]},"allowed-actions":{"type":"string","description":"The permissions policy that controls the actions that are allowed to run. Can be one of: `all`, `local_only`, or `selected`.","enum":["all","local_only","selected"]},"selected-actions-url":{"type":"string","description":"The API URL to use to get or set the actions that are allowed to run, when `allowed_actions` is set to `selected`."},"actions-enterprise-permissions":{"type":"object","properties":{"enabled_organizations":{"$ref":"#/components/schemas/enabled-organizations"},"selected_organizations_url":{"type":"string","description":"The API URL to use to get or set the selected organizations that are allowed to run GitHub Actions, when `enabled_organizations` is set to `selected`."},"allowed_actions":{"$ref":"#/components/schemas/allowed-actions"},"selected_actions_url":{"$ref":"#/components/schemas/selected-actions-url"}},"required":["enabled_organizations","allowed_actions"]},"organization-simple":{"title":"Organization Simple","description":"Organization Simple","type":"object","properties":{"login":{"type":"string","example":"github"},"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDEyOk9yZ2FuaXphdGlvbjE="},"url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/github"},"repos_url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/github/repos"},"events_url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/github/events"},"hooks_url":{"type":"string","example":"https://api.github.com/orgs/github/hooks"},"issues_url":{"type":"string","example":"https://api.github.com/orgs/github/issues"},"members_url":{"type":"string","example":"https://api.github.com/orgs/github/members{/member}"},"public_members_url":{"type":"string","example":"https://api.github.com/orgs/github/public_members{/member}"},"avatar_url":{"type":"string","example":"https://github.com/images/error/octocat_happy.gif"},"description":{"type":"string","example":"A great organization","nullable":true}},"required":["login","url","id","node_id","repos_url","events_url","hooks_url","issues_url","members_url","public_members_url","avatar_url","description"]},"selected-actions":{"type":"object","properties":{"github_owned_allowed":{"type":"boolean","description":"Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization."},"verified_allowed":{"type":"boolean","description":"Whether actions in GitHub Marketplace from verified creators are allowed. Set to `true` to allow all GitHub Marketplace actions by verified creators."},"patterns_allowed":{"type":"array","description":"Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.\\"","items":{"type":"string"}}},"required":["github_owned_allowed","patterns_allowed","verified_allowed"]},"runner-groups-enterprise":{"type":"object","properties":{"id":{"type":"number"},"name":{"type":"string"},"visibility":{"type":"string"},"default":{"type":"boolean"},"selected_organizations_url":{"type":"string"},"runners_url":{"type":"string"},"allows_public_repositories":{"type":"boolean"}},"required":["id","name","visibility","allows_public_repositories","default","runners_url"]},"runner":{"title":"Self hosted runners","description":"A self hosted runner","type":"object","properties":{"id":{"description":"The id of the runner.","type":"integer","example":5},"name":{"description":"The name of the runner.","type":"string","example":"iMac"},"os":{"description":"The Operating System of the runner.","type":"string","example":"macos"},"status":{"description":"The status of the runner.","type":"string","example":"online"},"busy":{"type":"boolean"},"labels":{"type":"array","items":{"type":"object","properties":{"id":{"type":"integer","description":"Unique identifier of the label."},"name":{"type":"string","description":"Name of the label."},"type":{"type":"string","description":"The type of label. Read-only labels are applied automatically when the runner is configured.","enum":["read-only","custom"]}}}}},"required":["id","name","os","status","busy","labels"]},"runner-application":{"title":"Runner Application","description":"Runner Application","type":"object","properties":{"os":{"type":"string"},"architecture":{"type":"string"},"download_url":{"type":"string"},"filename":{"type":"string"}},"required":["os","architecture","download_url","filename"]},"authentication-token":{"title":"Authentication Token","description":"Authentication Token","type":"object","properties":{"token":{"description":"The token used for authentication","type":"string","example":"v1.1f699f1069f60xxx"},"expires_at":{"description":"The time this token expires","type":"string","format":"date-time","example":"2016-07-11T22:14:10Z"},"permissions":{"type":"object","example":{"issues":"read","deployments":"write"}},"repositories":{"description":"The repositories this token has access to","type":"array","items":{"$ref":"#/components/schemas/repository"}},"single_file":{"type":"string","example":"config.yaml","nullable":true},"repository_selection":{"description":"Describe whether all repositories have been selected or there\'s a selection involved","type":"string","enum":["all","selected"]}},"required":["token","expires_at"]},"audit-log-event":{"type":"object","properties":{"@timestamp":{"type":"integer","description":"The time the audit log event occurred, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time)."},"action":{"type":"string","description":"The name of the action that was performed, for example `user.login` or `repo.create`."},"active":{"type":"boolean"},"active_was":{"type":"boolean"},"actor":{"type":"string","description":"The actor who performed the action."},"blocked_user":{"type":"string","description":"The username of the account being blocked."},"business":{"type":"string"},"config":{"type":"array"},"config_was":{"type":"array"},"content_type":{"type":"string"},"created_at":{"type":"integer","description":"The time the audit log event was recorded, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time)."},"deploy_key_fingerprint":{"type":"string"},"emoji":{"type":"string"},"events":{"type":"array"},"events_were":{"type":"array"},"explanation":{"type":"string"},"fingerprint":{"type":"string"},"hook_id":{"type":"integer"},"limited_availability":{"type":"boolean"},"message":{"type":"string"},"name":{"type":"string"},"old_user":{"type":"string"},"openssh_public_key":{"type":"string"},"org":{"type":"string"},"previous_visibility":{"type":"string"},"read_only":{"type":"boolean"},"repo":{"type":"string","description":"The name of the repository."},"repository":{"type":"string","description":"The name of the repository."},"repository_public":{"type":"boolean"},"target_login":{"type":"string"},"team":{"type":"string"},"transport_protocol":{"type":"integer","description":"The type of protocol (for example, HTTP or SSH) used to transfer Git data."},"transport_protocol_name":{"type":"string","description":"A human readable name for the protocol (for example, HTTP or SSH) used to transfer Git data."},"user":{"type":"string","description":"The user that was affected by the action performed (if available)."},"visibility":{"type":"string","description":"The repository visibility, for example `public` or `private`."}}},"actions-billing-usage":{"type":"object","properties":{"total_minutes_used":{"type":"integer","description":"The sum of the free and paid GitHub Actions minutes used."},"total_paid_minutes_used":{"type":"integer","description":"The total paid GitHub Actions minutes used."},"included_minutes":{"type":"integer","description":"The amount of free GitHub Actions minutes available."},"minutes_used_breakdown":{"type":"object","properties":{"UBUNTU":{"type":"integer","description":"Total minutes used on Ubuntu runner machines."},"MACOS":{"type":"integer","description":"Total minutes used on macOS runner machines."},"WINDOWS":{"type":"integer","description":"Total minutes used on Windows runner machines."}}}},"required":["total_minutes_used","total_paid_minutes_used","included_minutes","minutes_used_breakdown"]},"packages-billing-usage":{"type":"object","properties":{"total_gigabytes_bandwidth_used":{"type":"integer","description":"Sum of the free and paid storage space (GB) for GitHuub Packages."},"total_paid_gigabytes_bandwidth_used":{"type":"integer","description":"Total paid storage space (GB) for GitHuub Packages."},"included_gigabytes_bandwidth":{"type":"integer","description":"Free storage space (GB) for GitHub Packages."}},"required":["total_gigabytes_bandwidth_used","total_paid_gigabytes_bandwidth_used","included_gigabytes_bandwidth"]},"combined-billing-usage":{"type":"object","properties":{"days_left_in_billing_cycle":{"type":"integer","description":"Numbers of days left in billing cycle."},"estimated_paid_storage_for_month":{"type":"integer","description":"Estimated storage space (GB) used in billing cycle."},"estimated_storage_for_month":{"type":"integer","description":"Estimated sum of free and paid storage space (GB) used in billing cycle."}},"required":["days_left_in_billing_cycle","estimated_paid_storage_for_month","estimated_storage_for_month"]},"actor":{"title":"Actor","description":"Actor","type":"object","properties":{"id":{"type":"integer"},"login":{"type":"string"},"display_login":{"type":"string"},"gravatar_id":{"type":"string","nullable":true},"url":{"type":"string","format":"uri"},"avatar_url":{"type":"string","format":"uri"}},"required":["id","login","gravatar_id","url","avatar_url"]},"label":{"title":"Label","description":"Color-coded labels help you categorize and filter your issues (just like labels in Gmail).","type":"object","properties":{"id":{"type":"integer","example":208045946},"node_id":{"type":"string","example":"MDU6TGFiZWwyMDgwNDU5NDY="},"url":{"description":"URL for the label","example":"https://api.github.com/repositories/42/labels/bug","type":"string","format":"uri"},"name":{"description":"The name of the label.","example":"bug","type":"string"},"description":{"type":"string","example":"Something isn\'t working","nullable":true},"color":{"description":"6-character hex code, without the leading #, identifying the color","example":"FFFFFF","type":"string"},"default":{"type":"boolean","example":true}},"required":["id","node_id","url","name","description","color","default"]},"milestone":{"title":"Milestone","description":"A collection of related issues and pull requests.","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/milestones/1"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/milestones/v1.0"},"labels_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/milestones/1/labels"},"id":{"type":"integer","example":1002604},"node_id":{"type":"string","example":"MDk6TWlsZXN0b25lMTAwMjYwNA=="},"number":{"description":"The number of the milestone.","type":"integer","example":42},"state":{"description":"The state of the milestone.","example":"open","type":"string","enum":["open","closed"],"default":"open"},"title":{"description":"The title of the milestone.","example":"v1.0","type":"string"},"description":{"type":"string","example":"Tracking milestone for version 1.0","nullable":true},"creator":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"open_issues":{"type":"integer","example":4},"closed_issues":{"type":"integer","example":8},"created_at":{"type":"string","format":"date-time","example":"2011-04-10T20:09:31Z"},"updated_at":{"type":"string","format":"date-time","example":"2014-03-03T18:58:10Z"},"closed_at":{"type":"string","format":"date-time","example":"2013-02-12T13:22:01Z","nullable":true},"due_on":{"type":"string","format":"date-time","example":"2012-10-09T23:39:01Z","nullable":true}},"required":["closed_issues","creator","description","due_on","closed_at","id","node_id","labels_url","html_url","number","open_issues","state","title","url","created_at","updated_at"]},"author_association":{"title":"author_association","type":"string","example":"OWNER","description":"How the author is associated with the repository.","enum":["COLLABORATOR","CONTRIBUTOR","FIRST_TIMER","FIRST_TIME_CONTRIBUTOR","MANNEQUIN","MEMBER","NONE","OWNER"]},"issue-simple":{"title":"Issue Simple","description":"Issue Simple","type":"object","properties":{"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDU6SXNzdWUx"},"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/issues/1347"},"repository_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World"},"labels_url":{"type":"string","example":"https://api.github.com/repos/octocat/Hello-World/issues/1347/labels{/name}"},"comments_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/issues/1347/comments"},"events_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/issues/1347/events"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/issues/1347"},"number":{"type":"integer","example":1347},"state":{"type":"string","example":"open"},"title":{"type":"string","example":"Found a bug"},"body":{"type":"string","example":"I\'m having a problem with this."},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"labels":{"type":"array","items":{"$ref":"#/components/schemas/label"}},"assignee":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"assignees":{"type":"array","items":{"$ref":"#/components/schemas/simple-user"},"nullable":true},"milestone":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/milestone"}]},"locked":{"type":"boolean","example":true},"active_lock_reason":{"type":"string","example":"too heated","nullable":true},"comments":{"type":"integer","example":0},"pull_request":{"type":"object","properties":{"merged_at":{"type":"string","format":"date-time","nullable":true},"diff_url":{"type":"string","format":"uri","nullable":true},"html_url":{"type":"string","format":"uri","nullable":true},"patch_url":{"type":"string","format":"uri","nullable":true},"url":{"type":"string","format":"uri","nullable":true}},"required":["diff_url","html_url","patch_url","url"]},"closed_at":{"type":"string","format":"date-time","nullable":true},"created_at":{"type":"string","format":"date-time","example":"2011-04-22T13:33:48Z"},"updated_at":{"type":"string","format":"date-time","example":"2011-04-22T13:33:48Z"},"author_association":{"$ref":"#/components/schemas/author_association"},"body_html":{"type":"string"},"body_text":{"type":"string"},"timeline_url":{"type":"string","format":"uri"},"repository":{"$ref":"#/components/schemas/repository"},"performed_via_github_app":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/integration"}]}},"required":["assignee","closed_at","comments","comments_url","events_url","html_url","id","node_id","labels","labels_url","milestone","number","repository_url","state","locked","title","url","user","author_association","created_at","updated_at"]},"reaction-rollup":{"title":"Reaction Rollup","type":"object","properties":{"url":{"type":"string","format":"uri"},"total_count":{"type":"integer"},"+1":{"type":"integer"},"-1":{"type":"integer"},"laugh":{"type":"integer"},"confused":{"type":"integer"},"heart":{"type":"integer"},"hooray":{"type":"integer"},"eyes":{"type":"integer"},"rocket":{"type":"integer"}},"required":["url","total_count","+1","-1","laugh","confused","heart","hooray","eyes","rocket"]},"issue-comment":{"title":"Issue Comment","description":"Comments provide a way for people to collaborate on an issue.","type":"object","properties":{"id":{"description":"Unique identifier of the issue comment","example":42,"type":"integer"},"node_id":{"type":"string"},"url":{"description":"URL for the issue comment","example":"https://api.github.com/repositories/42/issues/comments/1","type":"string","format":"uri"},"body":{"description":"Contents of the issue comment","example":"What version of Safari were you using when you observed this bug?","type":"string"},"body_text":{"type":"string"},"body_html":{"type":"string"},"html_url":{"type":"string","format":"uri"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"created_at":{"type":"string","format":"date-time","example":"2011-04-14T16:00:49Z"},"updated_at":{"type":"string","format":"date-time","example":"2011-04-14T16:00:49Z"},"issue_url":{"type":"string","format":"uri"},"author_association":{"$ref":"#/components/schemas/author_association"},"performed_via_github_app":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/integration"}]},"reactions":{"$ref":"#/components/schemas/reaction-rollup"}},"required":["id","node_id","html_url","issue_url","author_association","user","url","created_at","updated_at"]},"event":{"title":"Event","description":"Event","type":"object","properties":{"id":{"type":"string"},"type":{"type":"string","nullable":true},"actor":{"$ref":"#/components/schemas/actor"},"repo":{"type":"object","properties":{"id":{"type":"integer"},"name":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["id","name","url"]},"org":{"$ref":"#/components/schemas/actor"},"payload":{"type":"object","properties":{"action":{"type":"string"},"issue":{"$ref":"#/components/schemas/issue-simple"},"comment":{"$ref":"#/components/schemas/issue-comment"},"pages":{"type":"array","items":{"type":"object","properties":{"page_name":{"type":"string"},"title":{"type":"string"},"summary":{"type":"string","nullable":true},"action":{"type":"string"},"sha":{"type":"string"},"html_url":{"type":"string"}}}}},"required":["action"]},"public":{"type":"boolean"},"created_at":{"type":"string","format":"date-time","nullable":true}},"required":["id","type","actor","repo","payload","public","created_at"]},"link-with-type":{"title":"Link With Type","description":"Hypermedia Link with Type","type":"object","properties":{"href":{"type":"string"},"type":{"type":"string"}},"required":["href","type"]},"feed":{"title":"Feed","description":"Feed","type":"object","properties":{"timeline_url":{"type":"string","example":"https://github.com/timeline"},"user_url":{"type":"string","example":"https://github.com/{user}"},"current_user_public_url":{"type":"string","example":"https://github.com/octocat"},"current_user_url":{"type":"string","example":"https://github.com/octocat.private?token=abc123"},"current_user_actor_url":{"type":"string","example":"https://github.com/octocat.private.actor?token=abc123"},"current_user_organization_url":{"type":"string","example":"https://github.com/octocat-org"},"current_user_organization_urls":{"type":"array","example":["https://github.com/organizations/github/octocat.private.atom?token=abc123"],"items":{"type":"string","format":"uri"}},"security_advisories_url":{"type":"string","example":"https://github.com/security-advisories"},"_links":{"type":"object","properties":{"timeline":{"$ref":"#/components/schemas/link-with-type"},"user":{"$ref":"#/components/schemas/link-with-type"},"security_advisories":{"$ref":"#/components/schemas/link-with-type"},"current_user":{"$ref":"#/components/schemas/link-with-type"},"current_user_public":{"$ref":"#/components/schemas/link-with-type"},"current_user_actor":{"$ref":"#/components/schemas/link-with-type"},"current_user_organization":{"$ref":"#/components/schemas/link-with-type"},"current_user_organizations":{"type":"array","items":{"$ref":"#/components/schemas/link-with-type"}}},"required":["timeline","user"]}},"required":["_links","timeline_url","user_url"]},"base-gist":{"title":"Base Gist","description":"Base Gist","type":"object","properties":{"url":{"type":"string","format":"uri"},"forks_url":{"type":"string","format":"uri"},"commits_url":{"type":"string","format":"uri"},"id":{"type":"string"},"node_id":{"type":"string"},"git_pull_url":{"type":"string","format":"uri"},"git_push_url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"files":{"type":"object","additionalProperties":{"type":"object","properties":{"filename":{"type":"string"},"type":{"type":"string"},"language":{"type":"string"},"raw_url":{"type":"string"},"size":{"type":"integer"}}}},"public":{"type":"boolean"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"description":{"type":"string","nullable":true},"comments":{"type":"integer"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"comments_url":{"type":"string","format":"uri"},"owner":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"truncated":{"type":"boolean"},"forks":{"type":"array","items":{}},"history":{"type":"array","items":{}}},"required":["id","node_id","url","forks_url","commits_url","git_pull_url","git_push_url","html_url","comments_url","public","description","comments","user","files","created_at","updated_at"]},"gist-simple":{"title":"Gist Simple","description":"Gist Simple","type":"object","properties":{"url":{"type":"string"},"forks_url":{"type":"string"},"commits_url":{"type":"string"},"id":{"type":"string"},"node_id":{"type":"string"},"git_pull_url":{"type":"string"},"git_push_url":{"type":"string"},"html_url":{"type":"string"},"files":{"type":"object","additionalProperties":{"nullable":true,"type":"object","properties":{"filename":{"type":"string"},"type":{"type":"string"},"language":{"type":"string"},"raw_url":{"type":"string"},"size":{"type":"integer"},"truncated":{"type":"boolean"},"content":{"type":"string"}}}},"public":{"type":"boolean"},"created_at":{"type":"string"},"updated_at":{"type":"string"},"description":{"type":"string","nullable":true},"comments":{"type":"integer"},"user":{"type":"string","nullable":true},"comments_url":{"type":"string"},"owner":{"$ref":"#/components/schemas/simple-user"},"truncated":{"type":"boolean"}}},"gist-comment":{"title":"Gist Comment","description":"A comment made to a gist.","type":"object","properties":{"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDExOkdpc3RDb21tZW50MQ=="},"url":{"type":"string","format":"uri","example":"https://api.github.com/gists/a6db0bec360bb87e9418/comments/1"},"body":{"description":"The comment text.","type":"string","maxLength":65535,"example":"Body of the attachment"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"created_at":{"type":"string","format":"date-time","example":"2011-04-18T23:23:56Z"},"updated_at":{"type":"string","format":"date-time","example":"2011-04-18T23:23:56Z"},"author_association":{"$ref":"#/components/schemas/author_association"}},"required":["url","id","node_id","user","body","author_association","created_at","updated_at"]},"gist-commit":{"title":"Gist Commit","description":"Gist Commit","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/gists/aa5a315d61ae9438b18d/57a7f021a713b1c5a6a199b54cc514735d2d462f"},"version":{"type":"string","example":"57a7f021a713b1c5a6a199b54cc514735d2d462f"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"change_status":{"type":"object","properties":{"total":{"type":"integer"},"additions":{"type":"integer"},"deletions":{"type":"integer"}}},"committed_at":{"type":"string","format":"date-time","example":"2010-04-14T02:15:15Z"}},"required":["url","user","version","committed_at","change_status"]},"gitignore-template":{"title":"Gitignore Template","description":"Gitignore Template","type":"object","properties":{"name":{"type":"string","example":"C"},"source":{"type":"string","example":"# Object files\\n*.o\\n\\n# Libraries\\n*.lib\\n*.a\\n\\n# Shared objects (inc. Windows DLLs)\\n*.dll\\n*.so\\n*.so.*\\n*.dylib\\n\\n# Executables\\n*.exe\\n*.out\\n*.app\\n"}},"required":["name","source"]},"issue":{"title":"Issue","description":"Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.","type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"url":{"description":"URL for the issue","example":"https://api.github.com/repositories/42/issues/1","type":"string","format":"uri"},"repository_url":{"type":"string","format":"uri"},"labels_url":{"type":"string"},"comments_url":{"type":"string","format":"uri"},"events_url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"number":{"description":"Number uniquely identifying the issue within its repository","example":42,"type":"integer"},"state":{"description":"State of the issue; either \'open\' or \'closed\'","example":"open","type":"string"},"title":{"description":"Title of the issue","example":"Widget creation fails in Safari on OS X 10.8","type":"string"},"body":{"description":"Contents of the issue","example":"It looks like the new widget form is broken on Safari. When I try and create the widget, Safari crashes. This is reproducible on 10.8, but not 10.9. Maybe a browser bug?","type":"string"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"labels":{"description":"Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository","example":["bug","registration"],"type":"array","items":{"oneOf":[{"type":"string"},{"type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"url":{"type":"string","format":"uri"},"name":{"type":"string"},"description":{"type":"string","nullable":true},"color":{"type":"string","nullable":true},"default":{"type":"boolean"}}}]}},"assignee":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"assignees":{"type":"array","items":{"$ref":"#/components/schemas/simple-user"},"nullable":true},"milestone":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/milestone"}]},"locked":{"type":"boolean"},"active_lock_reason":{"type":"string","nullable":true},"comments":{"type":"integer"},"pull_request":{"type":"object","properties":{"merged_at":{"type":"string","format":"date-time","nullable":true},"diff_url":{"type":"string","format":"uri","nullable":true},"html_url":{"type":"string","format":"uri","nullable":true},"patch_url":{"type":"string","format":"uri","nullable":true},"url":{"type":"string","format":"uri","nullable":true}},"required":["diff_url","html_url","patch_url","url"]},"closed_at":{"type":"string","format":"date-time","nullable":true},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"closed_by":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"body_html":{"type":"string"},"body_text":{"type":"string"},"timeline_url":{"type":"string","format":"uri"},"repository":{"$ref":"#/components/schemas/repository"},"performed_via_github_app":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/integration"}]},"author_association":{"$ref":"#/components/schemas/author_association"},"reactions":{"$ref":"#/components/schemas/reaction-rollup"}},"required":["assignee","closed_at","comments","comments_url","events_url","html_url","id","node_id","labels","labels_url","milestone","number","repository_url","state","locked","title","url","user","author_association","created_at","updated_at"]},"license":{"title":"License","description":"License","type":"object","properties":{"key":{"type":"string","example":"mit"},"name":{"type":"string","example":"MIT License"},"spdx_id":{"type":"string","example":"MIT","nullable":true},"url":{"type":"string","format":"uri","example":"https://api.github.com/licenses/mit","nullable":true},"node_id":{"type":"string","example":"MDc6TGljZW5zZW1pdA=="},"html_url":{"type":"string","format":"uri","example":"http://choosealicense.com/licenses/mit/"},"description":{"type":"string","example":"A permissive license that is short and to the point. It lets people do anything with your code with proper attribution and without warranty."},"implementation":{"type":"string","example":"Create a text file (typically named LICENSE or LICENSE.txt) in the root of your source code and copy the text of the license into the file. Replace [year] with the current year and [fullname] with the name (or names) of the copyright holders."},"permissions":{"type":"array","example":["commercial-use","modifications","distribution","sublicense","private-use"],"items":{"type":"string"}},"conditions":{"type":"array","example":["include-copyright"],"items":{"type":"string"}},"limitations":{"type":"array","example":["no-liability"],"items":{"type":"string"}},"body":{"type":"string","example":"\\n\\nThe MIT License (MIT)\\n\\nCopyright (c) [year] [fullname]\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\"Software\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n"},"featured":{"type":"boolean","example":true}},"required":["key","name","url","spdx_id","node_id","html_url","description","implementation","permissions","conditions","limitations","body","featured"]},"marketplace-listing-plan":{"title":"Marketplace Listing Plan","description":"Marketplace Listing Plan","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/marketplace_listing/plans/1313"},"accounts_url":{"type":"string","format":"uri","example":"https://api.github.com/marketplace_listing/plans/1313/accounts"},"id":{"type":"integer","example":1313},"number":{"type":"integer","example":3},"name":{"type":"string","example":"Pro"},"description":{"type":"string","example":"A professional-grade CI solution"},"monthly_price_in_cents":{"type":"integer","example":1099},"yearly_price_in_cents":{"type":"integer","example":11870},"price_model":{"type":"string","example":"flat-rate"},"has_free_trial":{"type":"boolean","example":true},"unit_name":{"type":"string","nullable":true},"state":{"type":"string","example":"published"},"bullets":{"type":"array","items":{"type":"string"},"example":["Up to 25 private repositories","11 concurrent builds"]}},"required":["url","accounts_url","id","number","name","description","has_free_trial","price_model","unit_name","monthly_price_in_cents","state","yearly_price_in_cents","bullets"]},"marketplace-purchase":{"title":"Marketplace Purchase","description":"Marketplace Purchase","type":"object","properties":{"url":{"type":"string"},"type":{"type":"string"},"id":{"type":"integer"},"login":{"type":"string"},"organization_billing_email":{"type":"string"},"marketplace_pending_change":{"type":"object","properties":{"is_installed":{"type":"boolean"},"effective_date":{"type":"string"},"unit_count":{"type":"integer","nullable":true},"id":{"type":"integer"},"plan":{"$ref":"#/components/schemas/marketplace-listing-plan"}},"nullable":true},"marketplace_purchase":{"type":"object","properties":{"billing_cycle":{"type":"string"},"next_billing_date":{"type":"string","nullable":true},"is_installed":{"type":"boolean"},"unit_count":{"type":"integer","nullable":true},"on_free_trial":{"type":"boolean"},"free_trial_ends_on":{"type":"string","nullable":true},"updated_at":{"type":"string"},"plan":{"$ref":"#/components/schemas/marketplace-listing-plan"}}}},"required":["url","id","type","login","marketplace_purchase"]},"api-overview":{"title":"Api Overview","description":"Api Overview","type":"object","properties":{"verifiable_password_authentication":{"type":"boolean","example":true},"ssh_key_fingerprints":{"type":"object","properties":{"SHA256_RSA":{"type":"string"},"SHA256_DSA":{"type":"string"}}},"hooks":{"type":"array","items":{"type":"string"},"example":["127.0.0.1/32"]},"web":{"type":"array","items":{"type":"string"},"example":["127.0.0.1/32"]},"api":{"type":"array","items":{"type":"string"},"example":["127.0.0.1/32"]},"git":{"type":"array","items":{"type":"string"},"example":["127.0.0.1/32"]},"pages":{"type":"array","items":{"type":"string"},"example":["192.30.252.153/32","192.30.252.154/32"]},"importer":{"type":"array","items":{"type":"string"},"example":["54.158.161.132","54.226.70.38"]},"actions":{"type":"array","items":{"type":"string"},"example":["13.64.0.0/16","13.65.0.0/16"]}},"required":["verifiable_password_authentication"]},"minimal-repository":{"title":"Minimal Repository","description":"Minimal Repository","type":"object","properties":{"id":{"type":"integer","example":1296269},"node_id":{"type":"string","example":"MDEwOlJlcG9zaXRvcnkxMjk2MjY5"},"name":{"type":"string","example":"Hello-World"},"full_name":{"type":"string","example":"octocat/Hello-World"},"owner":{"type":"object","nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"private":{"type":"boolean"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World"},"description":{"type":"string","example":"This your first repo!","nullable":true},"fork":{"type":"boolean"},"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World"},"archive_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}"},"assignees_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/assignees{/user}"},"blobs_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}"},"branches_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/branches{/branch}"},"collaborators_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}"},"comments_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/comments{/number}"},"commits_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/commits{/sha}"},"compare_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}"},"contents_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/contents/{+path}"},"contributors_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/contributors"},"deployments_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/deployments"},"downloads_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/downloads"},"events_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/events"},"forks_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/forks"},"git_commits_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/commits{/sha}"},"git_refs_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/refs{/sha}"},"git_tags_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/tags{/sha}"},"git_url":{"type":"string"},"issue_comment_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues/comments{/number}"},"issue_events_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues/events{/number}"},"issues_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues{/number}"},"keys_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/keys{/key_id}"},"labels_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/labels{/name}"},"languages_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/languages"},"merges_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/merges"},"milestones_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/milestones{/number}"},"notifications_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}"},"pulls_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/pulls{/number}"},"releases_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/releases{/id}"},"ssh_url":{"type":"string"},"stargazers_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/stargazers"},"statuses_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/statuses/{sha}"},"subscribers_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/subscribers"},"subscription_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/subscription"},"tags_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/tags"},"teams_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/teams"},"trees_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/trees{/sha}"},"clone_url":{"type":"string"},"mirror_url":{"type":"string","nullable":true},"hooks_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/hooks"},"svn_url":{"type":"string"},"homepage":{"type":"string","nullable":true},"language":{"type":"string","nullable":true},"forks_count":{"type":"integer"},"stargazers_count":{"type":"integer"},"watchers_count":{"type":"integer"},"size":{"type":"integer"},"default_branch":{"type":"string"},"open_issues_count":{"type":"integer"},"is_template":{"type":"boolean"},"topics":{"type":"array","items":{"type":"string"}},"has_issues":{"type":"boolean"},"has_projects":{"type":"boolean"},"has_wiki":{"type":"boolean"},"has_pages":{"type":"boolean"},"has_downloads":{"type":"boolean"},"archived":{"type":"boolean"},"disabled":{"type":"boolean"},"visibility":{"type":"string"},"pushed_at":{"type":"string","format":"date-time","example":"2011-01-26T19:06:43Z","nullable":true},"created_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z","nullable":true},"updated_at":{"type":"string","format":"date-time","example":"2011-01-26T19:14:43Z","nullable":true},"permissions":{"type":"object","properties":{"admin":{"type":"boolean"},"push":{"type":"boolean"},"pull":{"type":"boolean"}}},"template_repository":{"nullable":true,"type":"object","allOf":[{"$ref":"#/components/schemas/repository"}]},"temp_clone_token":{"type":"string"},"delete_branch_on_merge":{"type":"boolean"},"subscribers_count":{"type":"integer"},"network_count":{"type":"integer"},"license":{"type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"spdx_id":{"type":"string"},"url":{"type":"string"},"node_id":{"type":"string"}},"nullable":true},"forks":{"type":"integer","example":0},"open_issues":{"type":"integer","example":0},"watchers":{"type":"integer","example":0}},"required":["archive_url","assignees_url","blobs_url","branches_url","collaborators_url","comments_url","commits_url","compare_url","contents_url","contributors_url","deployments_url","description","downloads_url","events_url","fork","forks_url","full_name","git_commits_url","git_refs_url","git_tags_url","hooks_url","html_url","id","node_id","issue_comment_url","issue_events_url","issues_url","keys_url","labels_url","languages_url","merges_url","milestones_url","name","notifications_url","owner","private","pulls_url","releases_url","stargazers_url","statuses_url","subscribers_url","subscription_url","tags_url","teams_url","trees_url","url"]},"thread":{"title":"Thread","description":"Thread","type":"object","properties":{"id":{"type":"string"},"repository":{"$ref":"#/components/schemas/minimal-repository"},"subject":{"type":"object","properties":{"title":{"type":"string"},"url":{"type":"string"},"latest_comment_url":{"type":"string"},"type":{"type":"string"}},"required":["title","url","latest_comment_url","type"]},"reason":{"type":"string"},"unread":{"type":"boolean"},"updated_at":{"type":"string"},"last_read_at":{"type":"string","nullable":true},"url":{"type":"string"},"subscription_url":{"type":"string","example":"https://api.github.com/notifications/threads/2/subscription"}},"required":["id","unread","reason","updated_at","last_read_at","subject","repository","url","subscription_url"]},"thread-subscription":{"title":"Thread Subscription","description":"Thread Subscription","type":"object","properties":{"subscribed":{"type":"boolean","example":true},"ignored":{"type":"boolean"},"reason":{"type":"string","nullable":true},"created_at":{"type":"string","format":"date-time","example":"2012-10-06T21:34:12Z","nullable":true},"url":{"type":"string","format":"uri","example":"https://api.github.com/notifications/threads/1/subscription"},"thread_url":{"type":"string","format":"uri","example":"https://api.github.com/notifications/threads/1"},"repository_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/1"}},"required":["created_at","ignored","reason","url","subscribed"]},"organization-full":{"title":"Organization Full","description":"Organization Full","type":"object","properties":{"login":{"type":"string","example":"github"},"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDEyOk9yZ2FuaXphdGlvbjE="},"url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/github"},"repos_url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/github/repos"},"events_url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/github/events"},"hooks_url":{"type":"string","example":"https://api.github.com/orgs/github/hooks"},"issues_url":{"type":"string","example":"https://api.github.com/orgs/github/issues"},"members_url":{"type":"string","example":"https://api.github.com/orgs/github/members{/member}"},"public_members_url":{"type":"string","example":"https://api.github.com/orgs/github/public_members{/member}"},"avatar_url":{"type":"string","example":"https://github.com/images/error/octocat_happy.gif"},"description":{"type":"string","example":"A great organization","nullable":true},"name":{"type":"string","example":"github"},"company":{"type":"string","example":"GitHub"},"blog":{"type":"string","format":"uri","example":"https://github.com/blog"},"location":{"type":"string","example":"San Francisco"},"email":{"type":"string","format":"email","example":"octocat@github.com"},"twitter_username":{"type":"string","example":"github","nullable":true},"is_verified":{"type":"boolean","example":true},"has_organization_projects":{"type":"boolean","example":true},"has_repository_projects":{"type":"boolean","example":true},"public_repos":{"type":"integer","example":2},"public_gists":{"type":"integer","example":1},"followers":{"type":"integer","example":20},"following":{"type":"integer","example":0},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat"},"created_at":{"type":"string","format":"date-time","example":"2008-01-14T04:33:35Z"},"type":{"type":"string","example":"Organization"},"total_private_repos":{"type":"integer","example":100},"owned_private_repos":{"type":"integer","example":100},"private_gists":{"type":"integer","example":81,"nullable":true},"disk_usage":{"type":"integer","example":10000,"nullable":true},"collaborators":{"type":"integer","example":8,"nullable":true},"billing_email":{"type":"string","format":"email","example":"org@example.com","nullable":true},"plan":{"type":"object","properties":{"name":{"type":"string"},"space":{"type":"integer"},"private_repos":{"type":"integer"},"filled_seats":{"type":"integer"},"seats":{"type":"integer"}},"required":["name","space","private_repos"]},"default_repository_permission":{"type":"string","nullable":true},"members_can_create_repositories":{"type":"boolean","example":true,"nullable":true},"two_factor_requirement_enabled":{"type":"boolean","example":true,"nullable":true},"members_allowed_repository_creation_type":{"type":"string","example":"all"},"members_can_create_public_repositories":{"type":"boolean","example":true},"members_can_create_private_repositories":{"type":"boolean","example":true},"members_can_create_internal_repositories":{"type":"boolean","example":true},"members_can_create_pages":{"type":"boolean","example":true},"updated_at":{"type":"string","format":"date-time"}},"required":["login","url","id","node_id","repos_url","events_url","hooks_url","issues_url","members_url","public_members_url","avatar_url","description","html_url","has_organization_projects","has_repository_projects","public_repos","public_gists","followers","following","type","created_at","updated_at"]},"enabled-repositories":{"type":"string","description":"The policy that controls the repositories in the organization that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.","enum":["all","none","selected"]},"actions-organization-permissions":{"type":"object","properties":{"enabled_repositories":{"$ref":"#/components/schemas/enabled-repositories"},"selected_repositories_url":{"type":"string","description":"The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`."},"allowed_actions":{"$ref":"#/components/schemas/allowed-actions"},"selected_actions_url":{"$ref":"#/components/schemas/selected-actions-url"}},"required":["enabled_repositories","allowed_actions"]},"runner-groups-org":{"type":"object","properties":{"id":{"type":"number"},"name":{"type":"string"},"visibility":{"type":"string"},"default":{"type":"boolean"},"selected_repositories_url":{"description":"Link to the selected repositories resource for this runner group. Not present unless visibility was set to `selected`","type":"string"},"runners_url":{"type":"string"},"inherited":{"type":"boolean"},"inherited_allows_public_repositories":{"type":"boolean"},"allows_public_repositories":{"type":"boolean"}},"required":["id","name","visibility","default","runners_url","inherited","allows_public_repositories"]},"organization-actions-secret":{"title":"Actions Secret for an Organization","description":"Secrets for GitHub Actions for an organization.","type":"object","properties":{"name":{"description":"The name of the secret.","example":"SECRET_TOKEN","type":"string"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"visibility":{"description":"Visibility of a secret","enum":["all","private","selected"],"type":"string"},"selected_repositories_url":{"type":"string","format":"uri","example":"https://api.github.com/organizations/org/secrets/my_secret/repositories"}},"required":["name","created_at","updated_at","visibility"]},"actions-public-key":{"title":"ActionsPublicKey","description":"The public key used for setting Actions Secrets.","type":"object","properties":{"key_id":{"description":"The identifier for the key.","type":"string","example":"1234567"},"key":{"description":"The Base64 encoded public key.","type":"string","example":"hBT5WZEj8ZoOv6TYJsfWq7MxTEQopZO5/IT3ZCVQPzs="},"id":{"type":"integer","example":2},"url":{"type":"string","example":"https://api.github.com/user/keys/2"},"title":{"type":"string","example":"ssh-rsa AAAAB3NzaC1yc2EAAA"},"created_at":{"type":"string","example":"2011-01-26T19:01:12Z"}},"required":["key_id","key"]},"credential-authorization":{"title":"Credential Authorization","description":"Credential Authorization","type":"object","properties":{"login":{"type":"string","example":"monalisa","description":"User login that owns the underlying credential."},"credential_id":{"type":"integer","example":1,"description":"Unique identifier for the credential."},"credential_type":{"type":"string","example":"SSH Key","description":"Human-readable description of the credential type."},"token_last_eight":{"type":"string","example":"12345678","description":"Last eight characters of the credential. Only included in responses with credential_type of personal access token."},"credential_authorized_at":{"type":"string","format":"date-time","example":"2011-01-26T19:06:43Z","description":"Date when the credential was authorized for use."},"scopes":{"type":"array","example":["user","repo"],"description":"List of oauth scopes the token has been granted.","items":{"type":"string"}},"fingerprint":{"type":"string","example":"jklmnop12345678","description":"Unique string to distinguish the credential. Only included in responses with credential_type of SSH Key."},"credential_accessed_at":{"type":"string","format":"date-time","example":"2011-01-26T19:06:43Z","description":"Date when the credential was last accessed. May be null if it was never accessed","nullable":true},"authorized_credential_id":{"type":"integer","nullable":true,"example":12345678},"authorized_credential_title":{"type":"string","nullable":true,"example":"my ssh key","description":"The title given to the ssh key. This will only be present when the credential is an ssh key."},"authorized_credential_note":{"type":"string","nullable":true,"example":"my token","description":"The note given to the token. This will only be present when the credential is a token."}},"required":["login","credential_id","credential_type","credential_authorized_at"]},"organization-invitation":{"title":"Organization Invitation","description":"Organization Invitation","type":"object","properties":{"id":{"type":"integer"},"login":{"type":"string","nullable":true},"email":{"type":"string","nullable":true},"role":{"type":"string"},"created_at":{"type":"string"},"failed_at":{"type":"string"},"failed_reason":{"type":"string"},"inviter":{"$ref":"#/components/schemas/simple-user"},"team_count":{"type":"integer"},"invitation_team_url":{"type":"string"},"node_id":{"type":"string","example":"\\"MDIyOk9yZ2FuaXphdGlvbkludml0YXRpb24x\\""},"invitation_teams_url":{"type":"string","example":"\\"https://api.github.com/organizations/16/invitations/1/teams\\""}},"required":["id","login","email","role","created_at","inviter","team_count","invitation_team_url","node_id"]},"org-hook":{"title":"Org Hook","description":"Org Hook","type":"object","properties":{"id":{"type":"integer","example":1},"url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/octocat/hooks/1"},"ping_url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/octocat/hooks/1/pings"},"name":{"type":"string","example":"web"},"events":{"type":"array","example":["push","pull_request"],"items":{"type":"string"}},"active":{"type":"boolean","example":true},"config":{"type":"object","properties":{"url":{"type":"string","example":"\\"http://example.com/2\\""},"insecure_ssl":{"type":"string","example":"\\"0\\""},"content_type":{"type":"string","example":"\\"form\\""},"secret":{"type":"string","example":"\\"********\\""}}},"updated_at":{"type":"string","format":"date-time","example":"2011-09-06T20:39:23Z"},"created_at":{"type":"string","format":"date-time","example":"2011-09-06T17:26:27Z"},"type":{"type":"string"}},"required":["id","url","type","name","active","events","config","ping_url","created_at","updated_at"]},"interaction-group":{"type":"string","description":"The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect. Can be one of: `existing_users`, `contributors_only`, `collaborators_only`.","example":"collaborators_only","enum":["existing_users","contributors_only","collaborators_only"]},"interaction-limit-response":{"title":"Interaction Limits","description":"Interaction limit settings.","type":"object","properties":{"limit":{"$ref":"#/components/schemas/interaction-group"},"origin":{"type":"string","example":"repository"},"expires_at":{"type":"string","format":"date-time","example":"2018-08-17T04:18:39Z"}},"required":["limit","origin","expires_at"]},"interaction-expiry":{"type":"string","description":"The duration of the interaction restriction. Can be one of: `one_day`, `three_days`, `one_week`, `one_month`, `six_months`. Default: `one_day`.","example":"one_month","enum":["one_day","three_days","one_week","one_month","six_months"]},"interaction-limit":{"title":"Interaction Restrictions","description":"Limit interactions to a specific type of user for a specified duration","type":"object","properties":{"limit":{"$ref":"#/components/schemas/interaction-group"},"expiry":{"$ref":"#/components/schemas/interaction-expiry"}},"required":["limit"]},"team-simple":{"title":"Team Simple","description":"Groups of organization members that gives permissions on specified repositories.","type":"object","properties":{"id":{"description":"Unique identifier of the team","type":"integer","example":1},"node_id":{"type":"string","example":"MDQ6VGVhbTE="},"url":{"description":"URL for the team","type":"string","format":"uri","example":"https://api.github.com/organizations/1/team/1"},"members_url":{"type":"string","example":"https://api.github.com/organizations/1/team/1/members{/member}"},"name":{"description":"Name of the team","type":"string","example":"Justice League"},"description":{"description":"Description of the team","type":"string","nullable":true,"example":"A great team."},"permission":{"description":"Permission that the team will have for its repositories","type":"string","example":"admin"},"privacy":{"description":"The level of privacy this team should have","type":"string","example":"closed"},"html_url":{"type":"string","format":"uri","example":"https://github.com/orgs/rails/teams/core"},"repositories_url":{"type":"string","format":"uri","example":"https://api.github.com/organizations/1/team/1/repos"},"slug":{"type":"string","example":"justice-league"},"ldap_dn":{"description":"Distinguished Name (DN) that team maps to within LDAP environment","example":"uid=example,ou=users,dc=github,dc=com","type":"string"}},"required":["id","node_id","url","members_url","name","description","permission","html_url","repositories_url","slug"],"nullable":true},"team":{"title":"Team","description":"Groups of organization members that gives permissions on specified repositories.","type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"name":{"type":"string"},"slug":{"type":"string"},"description":{"type":"string","nullable":true},"privacy":{"type":"string"},"permission":{"type":"string"},"url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri","example":"https://github.com/orgs/rails/teams/core"},"members_url":{"type":"string"},"repositories_url":{"type":"string","format":"uri"},"parent":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/team-simple"}]}},"required":["id","node_id","url","members_url","name","description","permission","html_url","repositories_url","slug"]},"org-membership":{"title":"Org Membership","description":"Org Membership","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/octocat/memberships/defunkt"},"state":{"type":"string","example":"active"},"role":{"type":"string","example":"admin"},"organization_url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/octocat"},"organization":{"$ref":"#/components/schemas/organization-simple"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"permissions":{"type":"object","properties":{"can_create_repository":{"type":"boolean"}},"required":["can_create_repository"]}},"required":["state","role","organization_url","url","organization","user"]},"migration":{"title":"Migration","description":"A migration.","type":"object","properties":{"id":{"type":"integer","example":79},"owner":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"guid":{"type":"string","example":"0b989ba4-242f-11e5-81e1-c7b6966d2516"},"state":{"type":"string","example":"pending"},"lock_repositories":{"type":"boolean","example":true},"exclude_attachments":{"type":"boolean"},"repositories":{"type":"array","items":{"$ref":"#/components/schemas/repository"}},"url":{"type":"string","format":"uri","example":"https://api.github.com/orgs/octo-org/migrations/79"},"created_at":{"type":"string","format":"date-time","example":"2015-07-06T15:33:38-07:00"},"updated_at":{"type":"string","format":"date-time","example":"2015-07-06T15:33:38-07:00"},"node_id":{"type":"string"},"archive_url":{"type":"string","format":"uri"},"exclude":{"type":"array","items":{}}},"required":["id","node_id","owner","guid","state","lock_repositories","exclude_attachments","repositories","url","created_at","updated_at"]},"package":{"title":"Package","description":"A software package","type":"object","properties":{"id":{"description":"Unique identifier of the package.","type":"integer","example":1},"name":{"description":"The name of the package.","type":"string","example":"super-linter"},"package_type":{"type":"string","example":"docker","enum":["npm","maven","rubygems","docker","nuget","container"]},"url":{"type":"string","example":"https://api.github.com/orgs/github/packages/container/super-linter"},"html_url":{"type":"string","example":"https://github.com/orgs/github/packages/container/package/super-linter"},"version_count":{"description":"The number of versions of the package.","type":"integer","example":1},"visibility":{"type":"string","example":"private","enum":["private","public"]},"owner":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"repository":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/minimal-repository"}]},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"}},"required":["id","name","package_type","visibility","url","html_url","version_count","created_at","updated_at"]},"package-version":{"title":"Package Version","description":"A version of a software package","type":"object","properties":{"id":{"description":"Unique identifier of the package version.","type":"integer","example":1},"name":{"description":"The name of the package version.","type":"string","example":"latest"},"url":{"type":"string","example":"https://api.github.com/orgs/github/packages/container/super-linter/versions/786068"},"package_html_url":{"type":"string","example":"https://github.com/orgs/github/packages/container/package/super-linter"},"html_url":{"type":"string","example":"https://github.com/orgs/github/packages/container/super-linter/786068"},"license":{"type":"string","example":"MIT"},"description":{"type":"string"},"created_at":{"type":"string","format":"date-time","example":"2011-04-10T20:09:31Z"},"updated_at":{"type":"string","format":"date-time","example":"2014-03-03T18:58:10Z"},"deleted_at":{"type":"string","format":"date-time","example":"2014-03-03T18:58:10Z"},"metadata":{"type":"object","title":"Package Version Metadata","properties":{"package_type":{"type":"string","example":"docker","enum":["npm","maven","rubygems","docker","nuget","container"]},"container":{"type":"object","title":"Container Metadata","properties":{"tags":{"type":"array"}},"required":["tags"]},"docker":{"type":"object","title":"Docker Metadata","properties":{"tag":{"type":"array"}},"required":["tags"]}},"required":["package_type"]}},"required":["id","name","url","package_html_url","created_at","updated_at"]},"project":{"title":"Project","description":"Projects are a way to organize columns and cards of work.","type":"object","properties":{"owner_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/api-playground/projects-test"},"url":{"type":"string","format":"uri","example":"https://api.github.com/projects/1002604"},"html_url":{"type":"string","format":"uri","example":"https://github.com/api-playground/projects-test/projects/12"},"columns_url":{"type":"string","format":"uri","example":"https://api.github.com/projects/1002604/columns"},"id":{"type":"integer","example":1002604},"node_id":{"type":"string","example":"MDc6UHJvamVjdDEwMDI2MDQ="},"name":{"description":"Name of the project","example":"Week One Sprint","type":"string"},"body":{"description":"Body of the project","example":"This project represents the sprint of the first week in January","type":"string","nullable":true},"number":{"type":"integer","example":1},"state":{"description":"State of the project; either \'open\' or \'closed\'","example":"open","type":"string"},"creator":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"created_at":{"type":"string","format":"date-time","example":"2011-04-10T20:09:31Z"},"updated_at":{"type":"string","format":"date-time","example":"2014-03-03T18:58:10Z"},"organization_permission":{"description":"The baseline permission that all organization members have on this project. Only present if owner is an organization.","type":"string","enum":["read","write","admin","none"]},"private":{"description":"Whether or not this project can be seen by everyone. Only present if owner is an organization.","type":"boolean"}},"required":["id","node_id","number","name","body","state","url","html_url","owner_url","creator","columns_url","created_at","updated_at"]},"group-mapping":{"title":"GroupMapping","description":"External Groups to be mapped to a team for membership","type":"object","properties":{"groups":{"description":"Array of groups to be mapped to this team","example":[{"group_id":"111a1a11-aaa1-1aaa-11a1-a1a1a1a1a1aa","group_name":"saml-azuread-test","group_description":"A group of Developers working on AzureAD SAML SSO"},{"group_id":"2bb2bb2b-bb22-22bb-2bb2-bb2bbb2bb2b2","group_name":"saml-azuread-test2","group_description":"Another group of Developers working on AzureAD SAML SSO"}],"type":"array","items":{"type":"object","required":["group_id","group_name","group_description"],"properties":{"group_id":{"description":"The ID of the group","example":"111a1a11-aaa1-1aaa-11a1-a1a1a1a1a1aa","type":"string"},"group_name":{"description":"The name of the group","example":"saml-azuread-test","type":"string"},"group_description":{"description":"a description of the group","example":"A group of Developers working on AzureAD SAML SSO","type":"string"},"status":{"description":"synchronization status for this group mapping","example":"unsynced","type":"string"},"synced_at":{"description":"the time of the last sync for this group-mapping","example":"2019-06-03 22:27:15:000 -700","type":"string"}}}}}},"team-full":{"title":"Full Team","description":"Groups of organization members that gives permissions on specified repositories.","type":"object","properties":{"id":{"description":"Unique identifier of the team","example":42,"type":"integer"},"node_id":{"type":"string","example":"MDQ6VGVhbTE="},"url":{"description":"URL for the team","example":"https://api.github.com/organizations/1/team/1","type":"string","format":"uri"},"html_url":{"type":"string","format":"uri","example":"https://github.com/orgs/rails/teams/core"},"name":{"description":"Name of the team","example":"Developers","type":"string"},"slug":{"type":"string","example":"justice-league"},"description":{"type":"string","example":"A great team.","nullable":true},"privacy":{"description":"The level of privacy this team should have","type":"string","enum":["closed","secret"],"example":"closed"},"permission":{"description":"Permission that the team will have for its repositories","example":"push","type":"string"},"members_url":{"type":"string","example":"https://api.github.com/organizations/1/team/1/members{/member}"},"repositories_url":{"type":"string","format":"uri","example":"https://api.github.com/organizations/1/team/1/repos"},"parent":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/team-simple"}]},"members_count":{"type":"integer","example":3},"repos_count":{"type":"integer","example":10},"created_at":{"type":"string","format":"date-time","example":"2017-07-14T16:53:42Z"},"updated_at":{"type":"string","format":"date-time","example":"2017-08-17T12:37:15Z"},"organization":{"$ref":"#/components/schemas/organization-full"},"ldap_dn":{"description":"Distinguished Name (DN) that team maps to within LDAP environment","example":"uid=example,ou=users,dc=github,dc=com","type":"string"}},"required":["id","node_id","url","members_url","name","description","permission","html_url","repositories_url","slug","created_at","updated_at","members_count","repos_count","organization"]},"team-discussion":{"title":"Team Discussion","description":"A team discussion is a persistent record of a free-form conversation within a team.","type":"object","properties":{"author":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"body":{"description":"The main text of the discussion.","example":"Please suggest improvements to our workflow in comments.","type":"string"},"body_html":{"type":"string","example":"<p>Hi! This is an area for us to collaborate as a team</p>"},"body_version":{"description":"The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.","example":"0307116bbf7ced493b8d8a346c650b71","type":"string"},"comments_count":{"type":"integer","example":0},"comments_url":{"type":"string","format":"uri","example":"https://api.github.com/organizations/1/team/2343027/discussions/1/comments"},"created_at":{"type":"string","format":"date-time","example":"2018-01-25T18:56:31Z"},"last_edited_at":{"type":"string","format":"date-time","nullable":true},"html_url":{"type":"string","format":"uri","example":"https://github.com/orgs/github/teams/justice-league/discussions/1"},"node_id":{"type":"string","example":"MDE0OlRlYW1EaXNjdXNzaW9uMQ=="},"number":{"description":"The unique sequence number of a team discussion.","example":42,"type":"integer"},"pinned":{"description":"Whether or not this discussion should be pinned for easy retrieval.","example":true,"type":"boolean"},"private":{"description":"Whether or not this discussion should be restricted to team members and organization administrators.","example":true,"type":"boolean"},"team_url":{"type":"string","format":"uri","example":"https://api.github.com/organizations/1/team/2343027"},"title":{"description":"The title of the discussion.","example":"How can we improve our workflow?","type":"string"},"updated_at":{"type":"string","format":"date-time","example":"2018-01-25T18:56:31Z"},"url":{"type":"string","format":"uri","example":"https://api.github.com/organizations/1/team/2343027/discussions/1"},"reactions":{"$ref":"#/components/schemas/reaction-rollup"}},"required":["author","body","body_html","body_version","comments_count","comments_url","created_at","last_edited_at","html_url","pinned","private","node_id","number","team_url","title","updated_at","url"]},"team-discussion-comment":{"title":"Team Discussion Comment","description":"A reply to a discussion within a team.","type":"object","properties":{"author":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"body":{"description":"The main text of the comment.","example":"I agree with this suggestion.","type":"string"},"body_html":{"type":"string","example":"<p>Do you like apples?</p>"},"body_version":{"description":"The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.","example":"0307116bbf7ced493b8d8a346c650b71","type":"string"},"created_at":{"type":"string","format":"date-time","example":"2018-01-15T23:53:58Z"},"last_edited_at":{"type":"string","format":"date-time","nullable":true},"discussion_url":{"type":"string","format":"uri","example":"https://api.github.com/organizations/1/team/2403582/discussions/1"},"html_url":{"type":"string","format":"uri","example":"https://github.com/orgs/github/teams/justice-league/discussions/1/comments/1"},"node_id":{"type":"string","example":"MDIxOlRlYW1EaXNjdXNzaW9uQ29tbWVudDE="},"number":{"description":"The unique sequence number of a team discussion comment.","example":42,"type":"integer"},"updated_at":{"type":"string","format":"date-time","example":"2018-01-15T23:53:58Z"},"url":{"type":"string","format":"uri","example":"https://api.github.com/organizations/1/team/2403582/discussions/1/comments/1"},"reactions":{"$ref":"#/components/schemas/reaction-rollup"}},"required":["author","body","body_html","body_version","created_at","last_edited_at","discussion_url","html_url","node_id","number","updated_at","url"]},"reaction":{"title":"Reaction","description":"Reactions to conversations provide a way to help people express their feelings more simply and effectively.","type":"object","properties":{"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDg6UmVhY3Rpb24x"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"content":{"description":"The reaction to use","example":"heart","type":"string","enum":["+1","-1","laugh","confused","heart","hooray","rocket","eyes"]},"created_at":{"type":"string","format":"date-time","example":"2016-05-20T20:09:31Z"}},"required":["id","node_id","user","content","created_at"]},"team-membership":{"title":"Team Membership","description":"Team Membership","type":"object","properties":{"url":{"type":"string","format":"uri"},"role":{"description":"The role of the user in the team.","enum":["member","maintainer"],"default":"member","example":"member","type":"string"},"state":{"type":"string"}},"required":["role","state","url"]},"team-project":{"title":"Team Project","description":"A team\'s access to a project.","type":"object","properties":{"owner_url":{"type":"string"},"url":{"type":"string"},"html_url":{"type":"string"},"columns_url":{"type":"string"},"id":{"type":"integer"},"node_id":{"type":"string"},"name":{"type":"string"},"body":{"type":"string","nullable":true},"number":{"type":"integer"},"state":{"type":"string"},"creator":{"$ref":"#/components/schemas/simple-user"},"created_at":{"type":"string"},"updated_at":{"type":"string"},"organization_permission":{"description":"The organization permission for this project. Only present when owner is an organization.","type":"string"},"private":{"description":"Whether the project is private or not. Only present when owner is an organization.","type":"boolean"},"permissions":{"type":"object","properties":{"read":{"type":"boolean"},"write":{"type":"boolean"},"admin":{"type":"boolean"}},"required":["read","write","admin"]}},"required":["owner_url","url","html_url","columns_url","id","node_id","name","body","number","state","creator","created_at","updated_at","permissions"]},"team-repository":{"title":"Team Repository","description":"A team\'s access to a repository.","type":"object","properties":{"id":{"description":"Unique identifier of the repository","example":42,"type":"integer"},"node_id":{"type":"string","example":"MDEwOlJlcG9zaXRvcnkxMjk2MjY5"},"name":{"description":"The name of the repository.","type":"string","example":"Team Environment"},"full_name":{"type":"string","example":"octocat/Hello-World"},"license":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/license-simple"}]},"forks":{"type":"integer"},"permissions":{"type":"object","properties":{"admin":{"type":"boolean"},"pull":{"type":"boolean"},"triage":{"type":"boolean"},"push":{"type":"boolean"},"maintain":{"type":"boolean"}},"required":["admin","pull","push"]},"owner":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"private":{"description":"Whether the repository is private or public.","default":false,"type":"boolean"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World"},"description":{"type":"string","example":"This your first repo!","nullable":true},"fork":{"type":"boolean"},"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World"},"archive_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}"},"assignees_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/assignees{/user}"},"blobs_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}"},"branches_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/branches{/branch}"},"collaborators_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}"},"comments_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/comments{/number}"},"commits_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/commits{/sha}"},"compare_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}"},"contents_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/contents/{+path}"},"contributors_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/contributors"},"deployments_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/deployments"},"downloads_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/downloads"},"events_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/events"},"forks_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/forks"},"git_commits_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/commits{/sha}"},"git_refs_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/refs{/sha}"},"git_tags_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/tags{/sha}"},"git_url":{"type":"string","example":"git:github.com/octocat/Hello-World.git"},"issue_comment_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues/comments{/number}"},"issue_events_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues/events{/number}"},"issues_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues{/number}"},"keys_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/keys{/key_id}"},"labels_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/labels{/name}"},"languages_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/languages"},"merges_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/merges"},"milestones_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/milestones{/number}"},"notifications_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}"},"pulls_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/pulls{/number}"},"releases_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/releases{/id}"},"ssh_url":{"type":"string","example":"git@github.com:octocat/Hello-World.git"},"stargazers_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/stargazers"},"statuses_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/statuses/{sha}"},"subscribers_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/subscribers"},"subscription_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/subscription"},"tags_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/tags"},"teams_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/teams"},"trees_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/trees{/sha}"},"clone_url":{"type":"string","example":"https://github.com/octocat/Hello-World.git"},"mirror_url":{"type":"string","format":"uri","example":"git:git.example.com/octocat/Hello-World","nullable":true},"hooks_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/hooks"},"svn_url":{"type":"string","format":"uri","example":"https://svn.github.com/octocat/Hello-World"},"homepage":{"type":"string","format":"uri","example":"https://github.com","nullable":true},"language":{"type":"string","nullable":true},"forks_count":{"type":"integer","example":9},"stargazers_count":{"type":"integer","example":80},"watchers_count":{"type":"integer","example":80},"size":{"type":"integer","example":108},"default_branch":{"description":"The default branch of the repository.","type":"string","example":"master"},"open_issues_count":{"type":"integer","example":0},"is_template":{"description":"Whether this repository acts as a template that can be used to generate new repositories.","default":false,"type":"boolean","example":true},"topics":{"type":"array","items":{"type":"string"}},"has_issues":{"description":"Whether issues are enabled.","default":true,"type":"boolean","example":true},"has_projects":{"description":"Whether projects are enabled.","default":true,"type":"boolean","example":true},"has_wiki":{"description":"Whether the wiki is enabled.","default":true,"type":"boolean","example":true},"has_pages":{"type":"boolean"},"has_downloads":{"description":"Whether downloads are enabled.","default":true,"type":"boolean","example":true},"archived":{"description":"Whether the repository is archived.","default":false,"type":"boolean"},"disabled":{"type":"boolean","description":"Returns whether or not this repository disabled."},"visibility":{"description":"The repository visibility: public, private, or internal.","default":"public","type":"string"},"pushed_at":{"type":"string","format":"date-time","example":"2011-01-26T19:06:43Z","nullable":true},"created_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z","nullable":true},"updated_at":{"type":"string","format":"date-time","example":"2011-01-26T19:14:43Z","nullable":true},"allow_rebase_merge":{"description":"Whether to allow rebase merges for pull requests.","default":true,"type":"boolean","example":true},"template_repository":{"type":"object","nullable":true,"allOf":[{"$ref":"#/components/schemas/repository"}]},"temp_clone_token":{"type":"string"},"allow_squash_merge":{"description":"Whether to allow squash merges for pull requests.","default":true,"type":"boolean","example":true},"delete_branch_on_merge":{"description":"Whether to delete head branches when pull requests are merged","default":false,"type":"boolean","example":false},"allow_merge_commit":{"description":"Whether to allow merge commits for pull requests.","default":true,"type":"boolean","example":true},"subscribers_count":{"type":"integer"},"network_count":{"type":"integer"},"open_issues":{"type":"integer"},"watchers":{"type":"integer"},"master_branch":{"type":"string"}},"required":["archive_url","assignees_url","blobs_url","branches_url","collaborators_url","comments_url","commits_url","compare_url","contents_url","contributors_url","deployments_url","description","downloads_url","events_url","fork","forks_url","full_name","git_commits_url","git_refs_url","git_tags_url","hooks_url","html_url","id","node_id","issue_comment_url","issue_events_url","issues_url","keys_url","labels_url","languages_url","merges_url","milestones_url","name","notifications_url","owner","private","pulls_url","releases_url","stargazers_url","statuses_url","subscribers_url","subscription_url","tags_url","teams_url","trees_url","url","clone_url","default_branch","forks","forks_count","git_url","has_downloads","has_issues","has_projects","has_wiki","has_pages","homepage","language","archived","disabled","mirror_url","open_issues","open_issues_count","license","pushed_at","size","ssh_url","stargazers_count","svn_url","watchers","watchers_count","created_at","updated_at"]},"project-card":{"title":"Project Card","description":"Project cards represent a scope of work.","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/projects/columns/cards/1478"},"id":{"description":"The project card\'s ID","example":42,"type":"integer"},"node_id":{"type":"string","example":"MDExOlByb2plY3RDYXJkMTQ3OA=="},"note":{"type":"string","example":"Add payload for delete Project column","nullable":true},"creator":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"created_at":{"type":"string","format":"date-time","example":"2016-09-05T14:21:06Z"},"updated_at":{"type":"string","format":"date-time","example":"2016-09-05T14:20:22Z"},"archived":{"description":"Whether or not the card is archived","example":false,"type":"boolean"},"column_url":{"type":"string","format":"uri","example":"https://api.github.com/projects/columns/367"},"content_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/api-playground/projects-test/issues/3"},"project_url":{"type":"string","format":"uri","example":"https://api.github.com/projects/120"}},"required":["id","node_id","note","url","column_url","project_url","creator","created_at","updated_at"]},"project-column":{"title":"Project Column","description":"Project columns contain cards of work.","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/projects/columns/367"},"project_url":{"type":"string","format":"uri","example":"https://api.github.com/projects/120"},"cards_url":{"type":"string","format":"uri","example":"https://api.github.com/projects/columns/367/cards"},"id":{"description":"The unique identifier of the project column","example":42,"type":"integer"},"node_id":{"type":"string","example":"MDEzOlByb2plY3RDb2x1bW4zNjc="},"name":{"description":"Name of the project column","example":"Remaining tasks","type":"string"},"created_at":{"type":"string","format":"date-time","example":"2016-09-05T14:18:44Z"},"updated_at":{"type":"string","format":"date-time","example":"2016-09-05T14:22:28Z"}},"required":["id","node_id","url","project_url","cards_url","name","created_at","updated_at"]},"repository-collaborator-permission":{"title":"Repository Collaborator Permission","description":"Repository Collaborator Permission","type":"object","properties":{"permission":{"type":"string"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]}},"required":["permission","user"]},"rate-limit":{"title":"Rate Limit","type":"object","properties":{"limit":{"type":"integer"},"remaining":{"type":"integer"},"reset":{"type":"integer"}},"required":["limit","remaining","reset"]},"rate-limit-overview":{"title":"Rate Limit Overview","description":"Rate Limit Overview","type":"object","properties":{"resources":{"type":"object","properties":{"core":{"$ref":"#/components/schemas/rate-limit"},"graphql":{"$ref":"#/components/schemas/rate-limit"},"search":{"$ref":"#/components/schemas/rate-limit"},"source_import":{"$ref":"#/components/schemas/rate-limit"},"integration_manifest":{"$ref":"#/components/schemas/rate-limit"},"code_scanning_upload":{"$ref":"#/components/schemas/rate-limit"}},"required":["core","search"]},"rate":{"$ref":"#/components/schemas/rate-limit"}},"required":["rate","resources"]},"code-of-conduct-simple":{"title":"Code Of Conduct Simple","description":"Code of Conduct Simple","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/github/docs/community/code_of_conduct"},"key":{"type":"string","example":"citizen_code_of_conduct"},"name":{"type":"string","example":"Citizen Code of Conduct"},"html_url":{"type":"string","nullable":true,"format":"uri","example":"https://github.com/github/docs/blob/main/CODE_OF_CONDUCT.md"}},"required":["url","key","name","html_url"]},"full-repository":{"title":"Full Repository","description":"Full Repository","type":"object","properties":{"id":{"type":"integer","example":1296269},"node_id":{"type":"string","example":"MDEwOlJlcG9zaXRvcnkxMjk2MjY5"},"name":{"type":"string","example":"Hello-World"},"full_name":{"type":"string","example":"octocat/Hello-World"},"owner":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"private":{"type":"boolean"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World"},"description":{"type":"string","example":"This your first repo!","nullable":true},"fork":{"type":"boolean"},"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World"},"archive_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}"},"assignees_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/assignees{/user}"},"blobs_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}"},"branches_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/branches{/branch}"},"collaborators_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}"},"comments_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/comments{/number}"},"commits_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/commits{/sha}"},"compare_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}"},"contents_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/contents/{+path}"},"contributors_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/contributors"},"deployments_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/deployments"},"downloads_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/downloads"},"events_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/events"},"forks_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/forks"},"git_commits_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/commits{/sha}"},"git_refs_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/refs{/sha}"},"git_tags_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/tags{/sha}"},"git_url":{"type":"string","example":"git:github.com/octocat/Hello-World.git"},"issue_comment_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues/comments{/number}"},"issue_events_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues/events{/number}"},"issues_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/issues{/number}"},"keys_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/keys{/key_id}"},"labels_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/labels{/name}"},"languages_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/languages"},"merges_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/merges"},"milestones_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/milestones{/number}"},"notifications_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}"},"pulls_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/pulls{/number}"},"releases_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/releases{/id}"},"ssh_url":{"type":"string","example":"git@github.com:octocat/Hello-World.git"},"stargazers_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/stargazers"},"statuses_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/statuses/{sha}"},"subscribers_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/subscribers"},"subscription_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/subscription"},"tags_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/tags"},"teams_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/teams"},"trees_url":{"type":"string","example":"http://api.github.com/repos/octocat/Hello-World/git/trees{/sha}"},"clone_url":{"type":"string","example":"https://github.com/octocat/Hello-World.git"},"mirror_url":{"type":"string","format":"uri","example":"git:git.example.com/octocat/Hello-World","nullable":true},"hooks_url":{"type":"string","format":"uri","example":"http://api.github.com/repos/octocat/Hello-World/hooks"},"svn_url":{"type":"string","format":"uri","example":"https://svn.github.com/octocat/Hello-World"},"homepage":{"type":"string","format":"uri","example":"https://github.com","nullable":true},"language":{"type":"string","nullable":true},"forks_count":{"type":"integer","example":9},"stargazers_count":{"type":"integer","example":80},"watchers_count":{"type":"integer","example":80},"size":{"type":"integer","example":108},"default_branch":{"type":"string","example":"master"},"open_issues_count":{"type":"integer","example":0},"is_template":{"type":"boolean","example":true},"topics":{"type":"array","items":{"type":"string"},"example":["octocat","atom","electron","API"]},"has_issues":{"type":"boolean","example":true},"has_projects":{"type":"boolean","example":true},"has_wiki":{"type":"boolean","example":true},"has_pages":{"type":"boolean"},"has_downloads":{"type":"boolean","example":true},"archived":{"type":"boolean"},"disabled":{"type":"boolean","description":"Returns whether or not this repository disabled."},"visibility":{"description":"The repository visibility: public, private, or internal.","type":"string","example":"public"},"pushed_at":{"type":"string","format":"date-time","example":"2011-01-26T19:06:43Z"},"created_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z"},"updated_at":{"type":"string","format":"date-time","example":"2011-01-26T19:14:43Z"},"permissions":{"type":"object","properties":{"admin":{"type":"boolean"},"pull":{"type":"boolean"},"push":{"type":"boolean"}},"required":["admin","pull","push"]},"allow_rebase_merge":{"type":"boolean","example":true},"template_repository":{"nullable":true,"type":"object","allOf":[{"$ref":"#/components/schemas/repository"}]},"temp_clone_token":{"type":"string","nullable":true},"allow_squash_merge":{"type":"boolean","example":true},"delete_branch_on_merge":{"type":"boolean","example":false},"allow_merge_commit":{"type":"boolean","example":true},"subscribers_count":{"type":"integer","example":42},"network_count":{"type":"integer","example":0},"license":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/license-simple"}]},"organization":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"parent":{"$ref":"#/components/schemas/repository"},"source":{"$ref":"#/components/schemas/repository"},"forks":{"type":"integer"},"master_branch":{"type":"string"},"open_issues":{"type":"integer"},"watchers":{"type":"integer"},"anonymous_access_enabled":{"description":"Whether anonymous git access is allowed.","default":true,"type":"boolean"},"code_of_conduct":{"$ref":"#/components/schemas/code-of-conduct-simple"}},"required":["archive_url","assignees_url","blobs_url","branches_url","collaborators_url","comments_url","commits_url","compare_url","contents_url","contributors_url","deployments_url","description","downloads_url","events_url","fork","forks_url","full_name","git_commits_url","git_refs_url","git_tags_url","hooks_url","html_url","id","node_id","issue_comment_url","issue_events_url","issues_url","keys_url","labels_url","languages_url","merges_url","milestones_url","name","notifications_url","owner","private","pulls_url","releases_url","stargazers_url","statuses_url","subscribers_url","subscription_url","tags_url","teams_url","trees_url","url","clone_url","default_branch","forks","forks_count","git_url","has_downloads","has_issues","has_projects","has_wiki","has_pages","homepage","language","archived","disabled","mirror_url","open_issues","open_issues_count","license","pushed_at","size","ssh_url","stargazers_count","svn_url","watchers","watchers_count","created_at","updated_at","network_count","subscribers_count"]},"artifact":{"title":"Artifact","description":"An artifact","type":"object","properties":{"id":{"type":"integer","example":5},"node_id":{"type":"string","example":"MDEwOkNoZWNrU3VpdGU1"},"name":{"description":"The name of the artifact.","type":"string","example":"AdventureWorks.Framework"},"size_in_bytes":{"description":"The size in bytes of the artifact.","type":"integer","example":12345},"url":{"type":"string","example":"https://api.github.com/repos/github/hello-world/actions/artifacts/5"},"archive_download_url":{"type":"string","example":"https://api.github.com/repos/github/hello-world/actions/artifacts/5/zip"},"expired":{"description":"Whether or not the artifact has expired.","type":"boolean"},"created_at":{"type":"string","format":"date-time","nullable":true},"expires_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time","nullable":true}},"required":["id","node_id","name","size_in_bytes","url","archive_download_url","expired","created_at","expires_at","updated_at"]},"job":{"title":"Job","description":"Information of a job execution in a workflow run","type":"object","properties":{"id":{"description":"The id of the job.","example":21,"type":"integer"},"run_id":{"description":"The id of the associated workflow run.","example":5,"type":"integer"},"run_url":{"type":"string","example":"https://api.github.com/repos/github/hello-world/actions/runs/5"},"node_id":{"type":"string","example":"MDg6Q2hlY2tSdW40"},"head_sha":{"description":"The SHA of the commit that is being run.","example":"009b8a3a9ccbb128af87f9b1c0f4c62e8a304f6d","type":"string"},"url":{"type":"string","example":"https://api.github.com/repos/github/hello-world/actions/jobs/21"},"html_url":{"type":"string","example":"https://github.com/github/hello-world/runs/4","nullable":true},"status":{"description":"The phase of the lifecycle that the job is currently in.","example":"queued","type":"string","enum":["queued","in_progress","completed"]},"conclusion":{"description":"The outcome of the job.","example":"success","type":"string","nullable":true},"started_at":{"description":"The time that the job started, in ISO 8601 format.","example":"2019-08-08T08:00:00-07:00","format":"date-time","type":"string"},"completed_at":{"description":"The time that the job finished, in ISO 8601 format.","example":"2019-08-08T08:00:00-07:00","format":"date-time","type":"string","nullable":true},"name":{"description":"The name of the job.","example":"test-coverage","type":"string"},"steps":{"description":"Steps in this job.","type":"array","items":{"type":"object","required":["name","status","conclusion","number"],"properties":{"status":{"description":"The phase of the lifecycle that the job is currently in.","example":"queued","type":"string","enum":["queued","in_progress","completed"]},"conclusion":{"description":"The outcome of the job.","example":"success","type":"string","nullable":true},"name":{"description":"The name of the job.","example":"test-coverage","type":"string"},"number":{"type":"integer","example":1},"started_at":{"description":"The time that the step started, in ISO 8601 format.","example":"2019-08-08T08:00:00-07:00","format":"date-time","type":"string","nullable":true},"completed_at":{"description":"The time that the job finished, in ISO 8601 format.","example":"2019-08-08T08:00:00-07:00","format":"date-time","type":"string","nullable":true}}}},"check_run_url":{"type":"string","example":"https://api.github.com/repos/github/hello-world/check-runs/4"}},"required":["id","node_id","run_id","run_url","head_sha","name","url","html_url","status","conclusion","started_at","completed_at","check_run_url"]},"actions-enabled":{"type":"boolean","description":"Whether GitHub Actions is enabled on the repository."},"actions-repository-permissions":{"type":"object","properties":{"enabled":{"$ref":"#/components/schemas/actions-enabled"},"allowed_actions":{"$ref":"#/components/schemas/allowed-actions"},"selected_actions_url":{"$ref":"#/components/schemas/selected-actions-url"}},"required":["enabled","allowed_actions"]},"pull-request-minimal":{"title":"Pull Request Minimal","type":"object","properties":{"id":{"type":"integer"},"number":{"type":"integer"},"url":{"type":"string"},"head":{"type":"object","properties":{"ref":{"type":"string"},"sha":{"type":"string"},"repo":{"type":"object","properties":{"id":{"type":"integer"},"url":{"type":"string"},"name":{"type":"string"}},"required":["id","url","name"]}},"required":["ref","sha","repo"]},"base":{"type":"object","properties":{"ref":{"type":"string"},"sha":{"type":"string"},"repo":{"type":"object","properties":{"id":{"type":"integer"},"url":{"type":"string"},"name":{"type":"string"}},"required":["id","url","name"]}},"required":["ref","sha","repo"]}},"required":["id","number","url","head","base"]},"simple-commit":{"title":"Simple Commit","description":"Simple Commit","type":"object","properties":{"id":{"type":"string"},"tree_id":{"type":"string"},"message":{"type":"string"},"timestamp":{"type":"string","format":"date-time"},"author":{"type":"object","properties":{"name":{"type":"string"},"email":{"type":"string"}},"required":["name","email"],"nullable":true},"committer":{"type":"object","properties":{"name":{"type":"string"},"email":{"type":"string"}},"required":["name","email"],"nullable":true}},"required":["id","tree_id","message","timestamp","author","committer"]},"workflow-run":{"title":"Workflow Run","description":"An invocation of a workflow","type":"object","properties":{"id":{"type":"integer","description":"The ID of the workflow run.","example":5},"name":{"type":"string","description":"The name of the workflow run.","example":"Build"},"node_id":{"type":"string","example":"MDEwOkNoZWNrU3VpdGU1"},"head_branch":{"type":"string","nullable":true,"example":"master"},"head_sha":{"description":"The SHA of the head commit that points to the version of the worflow being run.","example":"009b8a3a9ccbb128af87f9b1c0f4c62e8a304f6d","type":"string"},"run_number":{"type":"integer","description":"The auto incrementing run number for the workflow run.","example":106},"event":{"type":"string","example":"push"},"status":{"type":"string","nullable":true,"example":"completed"},"conclusion":{"type":"string","nullable":true,"example":"neutral"},"workflow_id":{"type":"integer","description":"The ID of the parent workflow.","example":5},"url":{"type":"string","description":"The URL to the workflow run.","example":"https://api.github.com/repos/github/hello-world/actions/runs/5"},"html_url":{"type":"string","example":"https://github.com/github/hello-world/suites/4"},"pull_requests":{"type":"array","nullable":true,"items":{"$ref":"#/components/schemas/pull-request-minimal"}},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"jobs_url":{"description":"The URL to the jobs for the workflow run.","type":"string","example":"https://api.github.com/repos/github/hello-world/actions/runs/5/jobs"},"logs_url":{"description":"The URL to download the logs for the workflow run.","type":"string","example":"https://api.github.com/repos/github/hello-world/actions/runs/5/logs"},"check_suite_url":{"description":"The URL to the associated check suite.","type":"string","example":"https://api.github.com/repos/github/hello-world/check-suites/12"},"artifacts_url":{"description":"The URL to the artifacts for the workflow run.","type":"string","example":"https://api.github.com/repos/github/hello-world/actions/runs/5/rerun/artifacts"},"cancel_url":{"description":"The URL to cancel the workflow run.","type":"string","example":"https://api.github.com/repos/github/hello-world/actions/runs/5/cancel"},"rerun_url":{"description":"The URL to rerun the workflow run.","type":"string","example":"https://api.github.com/repos/github/hello-world/actions/runs/5/rerun"},"workflow_url":{"description":"The URL to the workflow.","type":"string","example":"https://api.github.com/repos/github/hello-world/actions/workflows/main.yaml"},"head_commit":{"$ref":"#/components/schemas/simple-commit"},"repository":{"$ref":"#/components/schemas/minimal-repository"},"head_repository":{"$ref":"#/components/schemas/minimal-repository"},"head_repository_id":{"type":"integer","example":5}},"required":["id","node_id","head_branch","run_number","event","status","conclusion","head_sha","workflow_id","url","html_url","created_at","updated_at","head_commit","head_repository","repository","jobs_url","logs_url","check_suite_url","cancel_url","rerun_url","artifacts_url","workflow_url","pull_requests"]},"environment-approvals":{"title":"Environment Approval","description":"An entry in the reviews log for environment deployments","type":"object","properties":{"environments":{"description":"The list of environments that were approved or rejected","type":"array","items":{"type":"object","properties":{"id":{"description":"The id of the environment.","example":56780428,"type":"integer"},"node_id":{"type":"string","example":"MDExOkVudmlyb25tZW50NTY3ODA0Mjg="},"name":{"description":"The name of the environment.","example":"staging","type":"string"},"url":{"type":"string","example":"https://api.github.com/repos/github/hello-world/environments/staging"},"html_url":{"type":"string","example":"https://github.com/github/hello-world/deployments/activity_log?environments_filter=staging"},"created_at":{"description":"The time that the environment was created, in ISO 8601 format.","example":"2020-11-23T22:00:40Z","format":"date-time","type":"string"},"updated_at":{"description":"The time that the environment was last updated, in ISO 8601 format.","example":"2020-11-23T22:00:40Z","format":"date-time","type":"string"}}}},"state":{"description":"Whether deployment to the environment(s) was approved or rejected","enum":["approved","rejected"],"example":"approved","type":"string"},"user":{"$ref":"#/components/schemas/simple-user"},"comment":{"type":"string","description":"The comment submitted with the deployment review","example":"Ship it!"}},"required":["environments","state","user","comment"]},"deployment-reviewer-type":{"type":"string","description":"The type of reviewer. Must be one of: `User` or `Team`","enum":["User","Team"],"example":"User"},"pending-deployment":{"title":"Pending Deployment","description":"Details of a deployment that is waiting for protection rules to pass","type":"object","properties":{"environment":{"type":"object","properties":{"id":{"description":"The id of the environment.","example":56780428,"type":"integer"},"node_id":{"type":"string","example":"MDExOkVudmlyb25tZW50NTY3ODA0Mjg="},"name":{"description":"The name of the environment.","example":"staging","type":"string"},"url":{"type":"string","example":"https://api.github.com/repos/github/hello-world/environments/staging"},"html_url":{"type":"string","example":"https://github.com/github/hello-world/deployments/activity_log?environments_filter=staging"}}},"wait_timer":{"type":"integer","description":"The set duration of the wait timer","example":30},"wait_timer_started_at":{"description":"The time that the wait timer began.","example":"2020-11-23T22:00:40Z","format":"date-time","type":"string","nullable":true},"current_user_can_approve":{"description":"Whether the currently authenticated user can approve the deployment","type":"boolean","example":true},"reviewers":{"type":"array","description":"The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.","items":{"type":"object","properties":{"type":{"$ref":"#/components/schemas/deployment-reviewer-type"},"reviewer":{"anyOf":[{"$ref":"#/components/schemas/simple-user"},{"$ref":"#/components/schemas/team-simple"}]}}}}},"required":["environment","wait_timer","wait_timer_started_at","current_user_can_approve","reviewers"]},"deployment":{"title":"Deployment","description":"A request for a specific ref(branch,sha,tag) to be deployed","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example/deployments/1"},"id":{"description":"Unique identifier of the deployment","example":42,"type":"integer"},"node_id":{"type":"string","example":"MDEwOkRlcGxveW1lbnQx"},"sha":{"type":"string","example":"a84d88e7554fc1fa21bcbc4efae3c782a70d2b9d"},"ref":{"description":"The ref to deploy. This can be a branch, tag, or sha.","example":"topic-branch","type":"string"},"task":{"description":"Parameter to specify a task to execute","example":"deploy","type":"string"},"payload":{"type":"object","properties":{}},"original_environment":{"type":"string","example":"staging"},"environment":{"description":"Name for the target deployment environment.","example":"production","type":"string"},"description":{"type":"string","example":"Deploy request from hubot","nullable":true},"creator":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"created_at":{"type":"string","format":"date-time","example":"2012-07-20T01:19:13Z"},"updated_at":{"type":"string","format":"date-time","example":"2012-07-20T01:19:13Z"},"statuses_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example/deployments/1/statuses"},"repository_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example"},"transient_environment":{"description":"Specifies if the given environment is will no longer exist at some point in the future. Default: false.","example":true,"type":"boolean"},"production_environment":{"description":"Specifies if the given environment is one that end-users directly interact with. Default: false.","example":true,"type":"boolean"},"performed_via_github_app":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/integration"}]}},"required":["id","node_id","sha","ref","task","environment","creator","payload","description","statuses_url","repository_url","url","created_at","updated_at"]},"workflow-run-usage":{"title":"Workflow Run Usage","description":"Workflow Run Usage","type":"object","properties":{"billable":{"type":"object","properties":{"UBUNTU":{"type":"object","required":["total_ms","jobs"],"properties":{"total_ms":{"type":"integer"},"jobs":{"type":"integer"}}},"MACOS":{"type":"object","required":["total_ms","jobs"],"properties":{"total_ms":{"type":"integer"},"jobs":{"type":"integer"}}},"WINDOWS":{"type":"object","required":["total_ms","jobs"],"properties":{"total_ms":{"type":"integer"},"jobs":{"type":"integer"}}}}},"run_duration_ms":{"type":"integer"}},"required":["billable","run_duration_ms"]},"actions-secret":{"title":"Actions Secret","description":"Set secrets for GitHub Actions.","type":"object","properties":{"name":{"description":"The name of the secret.","example":"SECRET_TOKEN","type":"string"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"}},"required":["name","created_at","updated_at"]},"workflow":{"title":"Workflow","description":"A GitHub Actions workflow","type":"object","properties":{"id":{"type":"integer","example":5},"node_id":{"type":"string","example":"MDg6V29ya2Zsb3cxMg=="},"name":{"type":"string","example":"CI"},"path":{"type":"string","example":"ruby.yaml"},"state":{"type":"string","example":"active","enum":["active","deleted"]},"created_at":{"type":"string","format":"date-time","example":"2019-12-06T14:20:20.000Z"},"updated_at":{"type":"string","format":"date-time","example":"2019-12-06T14:20:20.000Z"},"url":{"type":"string","example":"https://api.github.com/repos/actions/setup-ruby/workflows/5"},"html_url":{"type":"string","example":"https://github.com/actions/setup-ruby/blob/master/.github/workflows/ruby.yaml"},"badge_url":{"type":"string","example":"https://github.com/actions/setup-ruby/workflows/CI/badge.svg"},"deleted_at":{"type":"string","format":"date-time","example":"2019-12-06T14:20:20.000Z"}},"required":["id","node_id","name","path","state","url","html_url","badge_url","created_at","updated_at"]},"workflow-usage":{"title":"Workflow Usage","description":"Workflow Usage","type":"object","properties":{"billable":{"type":"object","properties":{"UBUNTU":{"type":"object","properties":{"total_ms":{"type":"integer"}}},"MACOS":{"type":"object","properties":{"total_ms":{"type":"integer"}}},"WINDOWS":{"type":"object","properties":{"total_ms":{"type":"integer"}}}}}},"required":["billable"]},"protected-branch-admin-enforced":{"title":"Protected Branch Admin Enforced","description":"Protected Branch Admin Enforced","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/enforce_admins"},"enabled":{"type":"boolean","example":true}},"required":["url","enabled"]},"protected-branch-pull-request-review":{"title":"Protected Branch Pull Request Review","description":"Protected Branch Pull Request Review","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/dismissal_restrictions"},"dismissal_restrictions":{"type":"object","properties":{"users":{"description":"The list of users with review dismissal access.","type":"array","items":{"$ref":"#/components/schemas/simple-user"}},"teams":{"description":"The list of teams with review dismissal access.","type":"array","items":{"$ref":"#/components/schemas/team"}},"url":{"type":"string","example":"\\"https://api.github.com/repos/the-org/an-org-repo/branches/master/protection/dismissal_restrictions\\""},"users_url":{"type":"string","example":"\\"https://api.github.com/repos/the-org/an-org-repo/branches/master/protection/dismissal_restrictions/users\\""},"teams_url":{"type":"string","example":"\\"https://api.github.com/repos/the-org/an-org-repo/branches/master/protection/dismissal_restrictions/teams\\""}}},"dismiss_stale_reviews":{"type":"boolean","example":true},"require_code_owner_reviews":{"type":"boolean","example":true},"required_approving_review_count":{"type":"integer","minimum":1,"maximum":6,"example":2}},"required":["dismiss_stale_reviews","require_code_owner_reviews"]},"branch-restriction-policy":{"title":"Branch Restriction Policy","description":"Branch Restriction Policy","type":"object","properties":{"url":{"type":"string","format":"uri"},"users_url":{"type":"string","format":"uri"},"teams_url":{"type":"string","format":"uri"},"apps_url":{"type":"string","format":"uri"},"users":{"type":"array","items":{"type":"object","properties":{"login":{"type":"string"},"id":{"type":"integer"},"node_id":{"type":"string"},"avatar_url":{"type":"string"},"gravatar_id":{"type":"string"},"url":{"type":"string"},"html_url":{"type":"string"},"followers_url":{"type":"string"},"following_url":{"type":"string"},"gists_url":{"type":"string"},"starred_url":{"type":"string"},"subscriptions_url":{"type":"string"},"organizations_url":{"type":"string"},"repos_url":{"type":"string"},"events_url":{"type":"string"},"received_events_url":{"type":"string"},"type":{"type":"string"},"site_admin":{"type":"boolean"}}}},"teams":{"type":"array","items":{"type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"url":{"type":"string"},"html_url":{"type":"string"},"name":{"type":"string"},"slug":{"type":"string"},"description":{"type":"string","nullable":true},"privacy":{"type":"string"},"permission":{"type":"string"},"members_url":{"type":"string"},"repositories_url":{"type":"string"},"parent":{"type":"string","nullable":true}}}},"apps":{"type":"array","items":{"type":"object","properties":{"id":{"type":"integer"},"slug":{"type":"string"},"node_id":{"type":"string"},"owner":{"type":"object","properties":{"login":{"type":"string"},"id":{"type":"integer"},"node_id":{"type":"string"},"url":{"type":"string"},"repos_url":{"type":"string"},"events_url":{"type":"string"},"hooks_url":{"type":"string"},"issues_url":{"type":"string"},"members_url":{"type":"string"},"public_members_url":{"type":"string"},"avatar_url":{"type":"string"},"description":{"type":"string"},"gravatar_id":{"type":"string","example":"\\"\\""},"html_url":{"type":"string","example":"\\"https://github.com/testorg-ea8ec76d71c3af4b\\""},"followers_url":{"type":"string","example":"\\"https://api.github.com/users/testorg-ea8ec76d71c3af4b/followers\\""},"following_url":{"type":"string","example":"\\"https://api.github.com/users/testorg-ea8ec76d71c3af4b/following{/other_user}\\""},"gists_url":{"type":"string","example":"\\"https://api.github.com/users/testorg-ea8ec76d71c3af4b/gists{/gist_id}\\""},"starred_url":{"type":"string","example":"\\"https://api.github.com/users/testorg-ea8ec76d71c3af4b/starred{/owner}{/repo}\\""},"subscriptions_url":{"type":"string","example":"\\"https://api.github.com/users/testorg-ea8ec76d71c3af4b/subscriptions\\""},"organizations_url":{"type":"string","example":"\\"https://api.github.com/users/testorg-ea8ec76d71c3af4b/orgs\\""},"received_events_url":{"type":"string","example":"\\"https://api.github.com/users/testorg-ea8ec76d71c3af4b/received_events\\""},"type":{"type":"string","example":"\\"Organization\\""}}},"name":{"type":"string"},"description":{"type":"string"},"external_url":{"type":"string"},"html_url":{"type":"string"},"created_at":{"type":"string"},"updated_at":{"type":"string"},"permissions":{"type":"object","properties":{"metadata":{"type":"string"},"contents":{"type":"string"},"issues":{"type":"string"},"single_file":{"type":"string"}}},"events":{"type":"array","items":{"type":"string"}}}}}},"required":["url","users_url","teams_url","apps_url","users","teams","apps"]},"branch-protection":{"title":"Branch Protection","description":"Branch Protection","type":"object","properties":{"url":{"type":"string"},"required_status_checks":{"type":"object","properties":{"url":{"type":"string"},"enforcement_level":{"type":"string"},"contexts":{"type":"array","items":{"type":"string"}},"contexts_url":{"type":"string"}},"required":["enforcement_level","contexts"]},"enforce_admins":{"$ref":"#/components/schemas/protected-branch-admin-enforced"},"required_pull_request_reviews":{"$ref":"#/components/schemas/protected-branch-pull-request-review"},"restrictions":{"$ref":"#/components/schemas/branch-restriction-policy"},"required_linear_history":{"type":"object","properties":{"enabled":{"type":"boolean"}}},"allow_force_pushes":{"type":"object","properties":{"enabled":{"type":"boolean"}}},"allow_deletions":{"type":"object","properties":{"enabled":{"type":"boolean"}}},"enabled":{"type":"boolean"},"name":{"type":"string","example":"\\"branch/with/protection\\""},"protection_url":{"type":"string","example":"\\"https://api.github.com/repos/owner-79e94e2d36b3fd06a32bb213/AAA_Public_Repo/branches/branch/with/protection/protection\\""}},"required":["enabled","required_status_checks"]},"short-branch":{"title":"Short Branch","description":"Short Branch","type":"object","properties":{"name":{"type":"string"},"commit":{"type":"object","properties":{"sha":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["sha","url"]},"protected":{"type":"boolean"},"protection":{"$ref":"#/components/schemas/branch-protection"},"protection_url":{"type":"string","format":"uri"}},"required":["name","commit","protected"]},"git-user":{"title":"Git User","description":"Metaproperties for Git author/committer information.","type":"object","properties":{"name":{"type":"string","example":"\\"Chris Wanstrath\\""},"email":{"type":"string","example":"\\"chris@ozmm.org\\""},"date":{"type":"string","example":"\\"2007-10-29T02:42:39.000-07:00\\""}}},"verification":{"title":"Verification","type":"object","properties":{"verified":{"type":"boolean"},"reason":{"type":"string"},"payload":{"type":"string","nullable":true},"signature":{"type":"string","nullable":true}},"required":["verified","reason","payload","signature"]},"commit":{"title":"Commit","description":"Commit","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e"},"sha":{"type":"string","example":"6dcb09b5b57875f334f61aebed695e2e4193db5e"},"node_id":{"type":"string","example":"MDY6Q29tbWl0NmRjYjA5YjViNTc4NzVmMzM0ZjYxYWViZWQ2OTVlMmU0MTkzZGI1ZQ=="},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/commit/6dcb09b5b57875f334f61aebed695e2e4193db5e"},"comments_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e/comments"},"commit":{"type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e"},"author":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/git-user"}]},"committer":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/git-user"}]},"message":{"type":"string","example":"Fix all the bugs"},"comment_count":{"type":"integer","example":0},"tree":{"type":"object","properties":{"sha":{"type":"string","example":"827efc6d56897b048c772eb4087f854f46256132"},"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/tree/827efc6d56897b048c772eb4087f854f46256132"}},"required":["sha","url"]},"verification":{"$ref":"#/components/schemas/verification"}},"required":["author","committer","comment_count","message","tree","url"]},"author":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"committer":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"parents":{"type":"array","items":{"type":"object","properties":{"sha":{"type":"string","example":"7638417db6d59f3c431d3e1f261cc637155684cd"},"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/commits/7638417db6d59f3c431d3e1f261cc637155684cd"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/commit/7638417db6d59f3c431d3e1f261cc637155684cd"}},"required":["sha","url"]}},"stats":{"type":"object","properties":{"additions":{"type":"integer"},"deletions":{"type":"integer"},"total":{"type":"integer"}}},"files":{"type":"array","items":{"type":"object","properties":{"filename":{"type":"string"},"additions":{"type":"integer"},"deletions":{"type":"integer"},"changes":{"type":"integer"},"status":{"type":"string"},"raw_url":{"type":"string"},"blob_url":{"type":"string"},"patch":{"type":"string"},"sha":{"type":"string","example":"\\"1e8e60ce9733d5283f7836fa602b6365a66b2567\\""},"contents_url":{"type":"string","example":"\\"https://api.github.com/repos/owner-3d68404b07d25daeb2d4a6bf/AAA_Public_Repo/contents/geometry.js?ref=c3956841a7cb7e8ba4a6fd923568d86958f01573\\""},"previous_filename":{"type":"string","example":"\\"subdir/before_name.txt\\""}}}}},"required":["url","sha","node_id","html_url","comments_url","commit","author","committer","parents"]},"branch-with-protection":{"title":"Branch With Protection","description":"Branch With Protection","type":"object","properties":{"name":{"type":"string"},"commit":{"$ref":"#/components/schemas/commit"},"_links":{"type":"object","properties":{"html":{"type":"string"},"self":{"type":"string","format":"uri"}},"required":["html","self"]},"protected":{"type":"boolean"},"protection":{"$ref":"#/components/schemas/branch-protection"},"protection_url":{"type":"string","format":"uri"},"pattern":{"type":"string","example":"\\"mas*\\""},"required_approving_review_count":{"type":"integer","example":1}},"required":["name","commit","_links","protection","protected","protection_url"]},"status-check-policy":{"title":"Status Check Policy","description":"Status Check Policy","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_status_checks"},"strict":{"type":"boolean","example":true},"contexts":{"type":"array","example":["continuous-integration/travis-ci"],"items":{"type":"string"}},"contexts_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_status_checks/contexts"}},"required":["url","contexts_url","strict","contexts"]},"protected-branch":{"title":"Protected Branch","description":"Branch protections protect branches","type":"object","properties":{"url":{"type":"string","format":"uri"},"required_status_checks":{"$ref":"#/components/schemas/status-check-policy"},"required_pull_request_reviews":{"type":"object","properties":{"url":{"type":"string","format":"uri"},"dismiss_stale_reviews":{"type":"boolean"},"require_code_owner_reviews":{"type":"boolean"},"required_approving_review_count":{"type":"integer"},"dismissal_restrictions":{"type":"object","properties":{"url":{"type":"string","format":"uri"},"users_url":{"type":"string","format":"uri"},"teams_url":{"type":"string","format":"uri"},"users":{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}},"teams":{"type":"array","items":{"$ref":"#/components/schemas/team"}}},"required":["url","users_url","teams_url","users","teams"]}},"required":["url"]},"required_signatures":{"type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_signatures"},"enabled":{"type":"boolean","example":true}},"required":["url","enabled"]},"enforce_admins":{"type":"object","properties":{"url":{"type":"string","format":"uri"},"enabled":{"type":"boolean"}},"additionalProperties":false,"required":["url","enabled"]},"required_linear_history":{"type":"object","properties":{"enabled":{"type":"boolean"}},"additionalProperties":false,"required":["enabled"]},"allow_force_pushes":{"type":"object","properties":{"enabled":{"type":"boolean"}},"additionalProperties":false,"required":["enabled"]},"allow_deletions":{"type":"object","properties":{"enabled":{"type":"boolean"}},"additionalProperties":false,"required":["enabled"]},"restrictions":{"$ref":"#/components/schemas/branch-restriction-policy"}},"required":["url"]},"deployment-simple":{"title":"Deployment","description":"A deployment created as the result of an Actions check run from a workflow that references an environment","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example/deployments/1"},"id":{"description":"Unique identifier of the deployment","example":42,"type":"integer"},"node_id":{"type":"string","example":"MDEwOkRlcGxveW1lbnQx"},"task":{"description":"Parameter to specify a task to execute","example":"deploy","type":"string"},"original_environment":{"type":"string","example":"staging"},"environment":{"description":"Name for the target deployment environment.","example":"production","type":"string"},"description":{"type":"string","example":"Deploy request from hubot","nullable":true},"created_at":{"type":"string","format":"date-time","example":"2012-07-20T01:19:13Z"},"updated_at":{"type":"string","format":"date-time","example":"2012-07-20T01:19:13Z"},"statuses_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example/deployments/1/statuses"},"repository_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example"},"transient_environment":{"description":"Specifies if the given environment is will no longer exist at some point in the future. Default: false.","example":true,"type":"boolean"},"production_environment":{"description":"Specifies if the given environment is one that end-users directly interact with. Default: false.","example":true,"type":"boolean"},"performed_via_github_app":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/integration"}]}},"required":["id","node_id","task","environment","description","statuses_url","repository_url","url","created_at","updated_at"]},"check-run":{"title":"CheckRun","description":"A check performed on the code of a given code change","type":"object","properties":{"id":{"description":"The id of the check.","example":21,"type":"integer"},"head_sha":{"description":"The SHA of the commit that is being checked.","example":"009b8a3a9ccbb128af87f9b1c0f4c62e8a304f6d","type":"string"},"node_id":{"type":"string","example":"MDg6Q2hlY2tSdW40"},"external_id":{"type":"string","example":"42","nullable":true},"url":{"type":"string","example":"https://api.github.com/repos/github/hello-world/check-runs/4"},"html_url":{"type":"string","example":"https://github.com/github/hello-world/runs/4","nullable":true},"details_url":{"type":"string","example":"https://example.com","nullable":true},"status":{"description":"The phase of the lifecycle that the check is currently in.","example":"queued","type":"string","enum":["queued","in_progress","completed"]},"conclusion":{"type":"string","example":"neutral","enum":["success","failure","neutral","cancelled","skipped","timed_out","action_required"],"nullable":true},"started_at":{"type":"string","format":"date-time","example":"2018-05-04T01:14:52Z","nullable":true},"completed_at":{"type":"string","format":"date-time","example":"2018-05-04T01:14:52Z","nullable":true},"output":{"type":"object","properties":{"title":{"type":"string","nullable":true},"summary":{"type":"string","nullable":true},"text":{"type":"string","nullable":true},"annotations_count":{"type":"integer"},"annotations_url":{"type":"string","format":"uri"}},"required":["title","summary","text","annotations_count","annotations_url"]},"name":{"description":"The name of the check.","example":"test-coverage","type":"string"},"check_suite":{"type":"object","properties":{"id":{"type":"integer"}},"required":["id"],"nullable":true},"app":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/integration"}]},"pull_requests":{"items":{"$ref":"#/components/schemas/pull-request-minimal"}},"deployment":{"$ref":"#/components/schemas/deployment-simple"}},"required":["id","node_id","head_sha","name","url","html_url","details_url","status","conclusion","started_at","completed_at","external_id","check_suite","output","app","pull_requests"]},"check-annotation":{"title":"Check Annotation","description":"Check Annotation","type":"object","properties":{"path":{"type":"string","example":"README.md"},"start_line":{"type":"integer","example":2},"end_line":{"type":"integer","example":2},"start_column":{"type":"integer","example":5,"nullable":true},"end_column":{"type":"integer","example":10,"nullable":true},"annotation_level":{"type":"string","example":"warning","nullable":true},"title":{"type":"string","example":"Spell Checker","nullable":true},"message":{"type":"string","example":"Check your spelling for \'banaas\'.","nullable":true},"raw_details":{"type":"string","example":"Do you mean \'bananas\' or \'banana\'?","nullable":true},"blob_href":{"type":"string"}},"required":["path","blob_href","start_line","end_line","start_column","end_column","annotation_level","title","message","raw_details"]},"check-suite":{"title":"CheckSuite","description":"A suite of checks performed on the code of a given code change","type":"object","properties":{"id":{"type":"integer","example":5},"node_id":{"type":"string","example":"MDEwOkNoZWNrU3VpdGU1"},"head_branch":{"type":"string","example":"master","nullable":true},"head_sha":{"description":"The SHA of the head commit that is being checked.","example":"009b8a3a9ccbb128af87f9b1c0f4c62e8a304f6d","type":"string"},"status":{"type":"string","example":"completed","enum":["queued","in_progress","completed"],"nullable":true},"conclusion":{"type":"string","example":"neutral","enum":["success","failure","neutral","cancelled","skipped","timed_out","action_required"],"nullable":true},"url":{"type":"string","example":"https://api.github.com/repos/github/hello-world/check-suites/5","nullable":true},"before":{"type":"string","example":"146e867f55c26428e5f9fade55a9bbf5e95a7912","nullable":true},"after":{"type":"string","example":"d6fde92930d4715a2b49857d24b940956b26d2d3","nullable":true},"pull_requests":{"type":"array","items":{"$ref":"#/components/schemas/pull-request-minimal"},"nullable":true},"app":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/integration"}]},"repository":{"$ref":"#/components/schemas/minimal-repository"},"created_at":{"type":"string","format":"date-time","nullable":true},"updated_at":{"type":"string","format":"date-time","nullable":true},"head_commit":{"$ref":"#/components/schemas/simple-commit"},"latest_check_runs_count":{"type":"integer"},"check_runs_url":{"type":"string"}},"required":["id","node_id","head_branch","status","conclusion","head_sha","url","before","after","created_at","updated_at","app","head_commit","repository","latest_check_runs_count","check_runs_url","pull_requests"]},"check-suite-preference":{"title":"Check Suite Preference","description":"Check suite configuration preferences for a repository.","type":"object","required":["preferences","repository"],"properties":{"preferences":{"type":"object","properties":{"auto_trigger_checks":{"type":"array","items":{"type":"object","properties":{"app_id":{"type":"integer"},"setting":{"type":"boolean"}},"required":["app_id","setting"]}}}},"repository":{"$ref":"#/components/schemas/repository"}}},"code-scanning-analysis-tool-name":{"type":"string","description":"The name of the tool used to generate the code scanning analysis."},"code-scanning-analysis-tool-guid":{"nullable":true,"type":"string","description":"The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data."},"code-scanning-ref":{"type":"string","description":"The full Git reference, formatted as `refs/heads/<branch name>`,\\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`."},"code-scanning-alert-state":{"type":"string","description":"State of a code scanning alert.","enum":["open","closed","dismissed","fixed"]},"alert-number":{"type":"integer","description":"The security alert number.","readOnly":true,"nullable":false},"alert-created-at":{"type":"string","description":"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.","format":"date-time","readOnly":true,"nullable":false},"alert-url":{"type":"string","description":"The REST API URL of the alert resource.","format":"uri","readOnly":true,"nullable":false},"alert-html-url":{"type":"string","description":"The GitHub URL of the alert resource.","format":"uri","readOnly":true,"nullable":false},"alert-instances-url":{"type":"string","description":"The REST API URL for fetching the list of instances for an alert.","format":"uri","readOnly":true,"nullable":false},"code-scanning-alert-dismissed-at":{"type":"string","description":"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.","format":"date-time","readOnly":true,"nullable":true},"code-scanning-alert-dismissed-reason":{"type":"string","description":"**Required when the state is dismissed.** The reason for dismissing or closing the alert. Can be one of: `false positive`, `won\'t fix`, and `used in tests`.","nullable":true,"oneOf":[{"enum":["false positive","won\'t fix","used in tests"]},{"enum":[null]}]},"code-scanning-alert-rule-summary":{"type":"object","properties":{"id":{"nullable":true,"type":"string","description":"A unique identifier for the rule used to detect the alert."},"name":{"type":"string","description":"The name of the rule used to detect the alert."},"severity":{"nullable":true,"type":"string","description":"The severity of the alert.","enum":["none","note","warning","error"]},"description":{"type":"string","description":"A short description of the rule used to detect the alert."}}},"code-scanning-analysis-tool-version":{"nullable":true,"type":"string","description":"The version of the tool used to generate the code scanning analysis."},"code-scanning-analysis-tool":{"type":"object","properties":{"name":{"$ref":"#/components/schemas/code-scanning-analysis-tool-name"},"version":{"$ref":"#/components/schemas/code-scanning-analysis-tool-version"},"guid":{"$ref":"#/components/schemas/code-scanning-analysis-tool-guid"}}},"code-scanning-analysis-analysis-key":{"type":"string","description":"Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."},"code-scanning-alert-environment":{"type":"string","description":"Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."},"code-scanning-alert-location":{"type":"object","description":"Describe a region within a file for the alert.","properties":{"path":{"type":"string"},"start_line":{"type":"integer"},"end_line":{"type":"integer"},"start_column":{"type":"integer"},"end_column":{"type":"integer"}}},"code-scanning-alert-classification":{"type":"string","description":"A classification of the file. For example to identify it as generated.","nullable":true,"enum":["source","generated","test","library"]},"code-scanning-alert-instance":{"type":"object","properties":{"ref":{"$ref":"#/components/schemas/code-scanning-ref"},"analysis_key":{"$ref":"#/components/schemas/code-scanning-analysis-analysis-key"},"environment":{"$ref":"#/components/schemas/code-scanning-alert-environment"},"state":{"$ref":"#/components/schemas/code-scanning-alert-state"},"commit_sha":{"type":"string"},"message":{"type":"object","properties":{"text":{"type":"string"}}},"location":{"$ref":"#/components/schemas/code-scanning-alert-location"},"html_url":{"type":"string"},"classifications":{"type":"array","description":"Classifications that have been applied to the file that triggered the alert.\\nFor example identifying it as documentation, or a generated file.","items":{"$ref":"#/components/schemas/code-scanning-alert-classification"}}}},"code-scanning-alert-items":{"type":"object","properties":{"number":{"$ref":"#/components/schemas/alert-number"},"created_at":{"$ref":"#/components/schemas/alert-created-at"},"url":{"$ref":"#/components/schemas/alert-url"},"html_url":{"$ref":"#/components/schemas/alert-html-url"},"instances_url":{"$ref":"#/components/schemas/alert-instances-url"},"state":{"$ref":"#/components/schemas/code-scanning-alert-state"},"dismissed_by":{"$ref":"#/components/schemas/simple-user"},"dismissed_at":{"$ref":"#/components/schemas/code-scanning-alert-dismissed-at"},"dismissed_reason":{"$ref":"#/components/schemas/code-scanning-alert-dismissed-reason"},"rule":{"$ref":"#/components/schemas/code-scanning-alert-rule-summary"},"tool":{"$ref":"#/components/schemas/code-scanning-analysis-tool"},"most_recent_instance":{"$ref":"#/components/schemas/code-scanning-alert-instance"}},"required":["number","created_at","url","html_url","instances_url","state","dismissed_by","dismissed_at","dismissed_reason","rule","tool","most_recent_instance"]},"code-scanning-alert-rule":{"type":"object","properties":{"id":{"nullable":true,"type":"string","description":"A unique identifier for the rule used to detect the alert."},"name":{"type":"string","description":"The name of the rule used to detect the alert."},"severity":{"nullable":true,"type":"string","description":"The severity of the alert.","enum":["none","note","warning","error"]},"description":{"type":"string","description":"A short description of the rule used to detect the alert."},"full_description":{"type":"string","description":"description of the rule used to detect the alert."},"tags":{"type":"array","description":"A set of tags applicable for the rule.","items":{"type":"string"}},"help":{"type":"string","description":"Detailed documentation for the rule as GitHub Flavored Markdown."}}},"code-scanning-alert":{"type":"object","properties":{"number":{"$ref":"#/components/schemas/alert-number"},"created_at":{"$ref":"#/components/schemas/alert-created-at"},"url":{"$ref":"#/components/schemas/alert-url"},"html_url":{"$ref":"#/components/schemas/alert-html-url"},"instances_url":{"$ref":"#/components/schemas/alert-instances-url"},"state":{"$ref":"#/components/schemas/code-scanning-alert-state"},"dismissed_by":{"$ref":"#/components/schemas/simple-user"},"dismissed_at":{"$ref":"#/components/schemas/code-scanning-alert-dismissed-at"},"dismissed_reason":{"$ref":"#/components/schemas/code-scanning-alert-dismissed-reason"},"rule":{"$ref":"#/components/schemas/code-scanning-alert-rule"},"tool":{"$ref":"#/components/schemas/code-scanning-analysis-tool"},"most_recent_instance":{"$ref":"#/components/schemas/code-scanning-alert-instance"}},"required":["number","created_at","url","html_url","instances_url","state","dismissed_by","dismissed_at","dismissed_reason","rule","tool","most_recent_instance"]},"code-scanning-alert-set-state":{"description":"Sets the state of the code scanning alert. Can be one of `open` or `dismissed`. You must provide `dismissed_reason` when you set the state to `dismissed`.","type":"string","enum":["open","dismissed"]},"code-scanning-analysis-sarif-id":{"type":"string","description":"An identifier for the upload.","example":"6c81cd8e-b078-4ac3-a3be-1dad7dbd0b53","nullable":false},"code-scanning-analysis-commit-sha":{"description":"The SHA of the commit to which the analysis you are uploading relates.","type":"string","minLength":40,"maxLength":40,"pattern":"^[0-9a-fA-F]+$"},"code-scanning-analysis-environment":{"type":"string","description":"Identifies the variable values associated with the environment in which this analysis was performed."},"code-scanning-analysis-created-at":{"type":"string","description":"The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.","format":"date-time","readOnly":true,"nullable":false},"code-scanning-analysis-url":{"type":"string","description":"The REST API URL of the analysis resource.","format":"uri","readOnly":true,"nullable":false},"code-scanning-analysis":{"type":"object","properties":{"ref":{"$ref":"#/components/schemas/code-scanning-ref"},"commit_sha":{"$ref":"#/components/schemas/code-scanning-analysis-commit-sha"},"analysis_key":{"$ref":"#/components/schemas/code-scanning-analysis-analysis-key"},"environment":{"$ref":"#/components/schemas/code-scanning-analysis-environment"},"error":{"type":"string","example":"error reading field xyz"},"created_at":{"$ref":"#/components/schemas/code-scanning-analysis-created-at"},"results_count":{"type":"integer","description":"The total number of results in the analysis."},"rules_count":{"type":"integer","description":"The total number of rules used in the analysis."},"id":{"type":"integer","description":"Unique identifier for this analysis."},"url":{"$ref":"#/components/schemas/code-scanning-analysis-url"},"sarif_id":{"$ref":"#/components/schemas/code-scanning-analysis-sarif-id"},"tool":{"$ref":"#/components/schemas/code-scanning-analysis-tool"},"deletable":{"type":"boolean"}},"required":["ref","commit_sha","analysis_key","environment","error","created_at","results_count","rules_count","id","url","sarif_id","tool","deletable"]},"code-scanning-analysis-deletion":{"title":"Analysis deletion","description":"Successful deletion of a code scanning analysis","type":"object","properties":{"next_analysis_url":{"type":"string","description":"Next deletable analysis in chain, without last analysis deletion confirmation","format":"uri","readOnly":true,"nullable":true},"confirm_delete_url":{"type":"string","description":"Next deletable analysis in chain, with last analysis deletion confirmation","format":"uri","readOnly":true,"nullable":true}},"required":["next_analysis_url","confirm_delete_url"]},"scim-error":{"title":"Scim Error","description":"Scim Error","type":"object","properties":{"message":{"type":"string","nullable":true},"documentation_url":{"type":"string","nullable":true},"detail":{"type":"string","nullable":true},"status":{"type":"integer"},"scimType":{"type":"string","nullable":true},"schemas":{"type":"array","items":{"type":"string"}}}},"code-scanning-analysis-sarif-file":{"description":"A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see \\"[SARIF support for code scanning](https://docs.github.com/github/finding-security-vulnerabilities-and-errors-in-your-code/sarif-support-for-code-scanning).\\"","type":"string"},"code-scanning-sarifs-receipt":{"type":"object","properties":{"id":{"$ref":"#/components/schemas/code-scanning-analysis-sarif-id"},"url":{"type":"string","description":"The REST API URL for checking the status of the upload.","format":"uri","readOnly":true,"nullable":false}}},"code-scanning-sarifs-status":{"type":"object","properties":{"processing_status":{"type":"string","enum":["pending","complete"],"description":"`pending` files have not yet been processed, while `complete` means all results in the SARIF have been stored."},"analyses_url":{"type":"string","description":"The REST API URL for getting the analyses associated with the upload.","format":"uri","readOnly":true,"nullable":true}}},"collaborator":{"title":"Collaborator","description":"Collaborator","type":"object","properties":{"login":{"type":"string","example":"octocat"},"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDQ6VXNlcjE="},"avatar_url":{"type":"string","format":"uri","example":"https://github.com/images/error/octocat_happy.gif"},"gravatar_id":{"type":"string","example":"41d064eb2195891e12d0413f63227ea7","nullable":true},"url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat"},"followers_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/followers"},"following_url":{"type":"string","example":"https://api.github.com/users/octocat/following{/other_user}"},"gists_url":{"type":"string","example":"https://api.github.com/users/octocat/gists{/gist_id}"},"starred_url":{"type":"string","example":"https://api.github.com/users/octocat/starred{/owner}{/repo}"},"subscriptions_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/subscriptions"},"organizations_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/orgs"},"repos_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/repos"},"events_url":{"type":"string","example":"https://api.github.com/users/octocat/events{/privacy}"},"received_events_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/received_events"},"type":{"type":"string","example":"User"},"site_admin":{"type":"boolean"},"permissions":{"type":"object","properties":{"pull":{"type":"boolean"},"push":{"type":"boolean"},"admin":{"type":"boolean"}},"required":["pull","push","admin"]}},"required":["avatar_url","events_url","followers_url","following_url","gists_url","gravatar_id","html_url","id","node_id","login","organizations_url","received_events_url","repos_url","site_admin","starred_url","subscriptions_url","type","url"]},"repository-invitation":{"title":"Repository Invitation","description":"Repository invitations let you manage who you collaborate with.","type":"object","properties":{"id":{"description":"Unique identifier of the repository invitation.","example":42,"type":"integer"},"repository":{"$ref":"#/components/schemas/minimal-repository"},"invitee":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"inviter":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"permissions":{"description":"The permission associated with the invitation.","example":"read","type":"string","enum":["read","write","admin"]},"created_at":{"type":"string","format":"date-time","example":"2016-06-13T14:52:50-05:00"},"expired":{"description":"Whether or not the invitation has expired","type":"boolean"},"url":{"description":"URL for the repository invitation","example":"https://api.github.com/user/repository-invitations/1","type":"string"},"html_url":{"type":"string","example":"https://github.com/octocat/Hello-World/invitations"},"node_id":{"type":"string"}},"required":["id","node_id","permissions","inviter","invitee","repository","url","html_url","created_at"]},"commit-comment":{"title":"Commit Comment","description":"Commit Comment","type":"object","properties":{"html_url":{"type":"string","format":"uri"},"url":{"type":"string","format":"uri"},"id":{"type":"integer"},"node_id":{"type":"string"},"body":{"type":"string"},"path":{"type":"string","nullable":true},"position":{"type":"integer","nullable":true},"line":{"type":"integer","nullable":true},"commit_id":{"type":"string"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"author_association":{"$ref":"#/components/schemas/author_association"},"reactions":{"$ref":"#/components/schemas/reaction-rollup"}},"required":["url","html_url","id","node_id","user","position","line","path","commit_id","body","author_association","created_at","updated_at"]},"branch-short":{"title":"Branch Short","description":"Branch Short","type":"object","properties":{"name":{"type":"string"},"commit":{"type":"object","properties":{"sha":{"type":"string"},"url":{"type":"string"}},"required":["sha","url"]},"protected":{"type":"boolean"}},"required":["name","commit","protected"]},"link":{"title":"Link","description":"Hypermedia Link","type":"object","properties":{"href":{"type":"string"}},"required":["href"]},"auto_merge":{"title":"Auto merge","description":"The status of auto merging a pull request.","type":"object","properties":{"enabled_by":{"$ref":"#/components/schemas/simple-user"},"merge_method":{"type":"string","description":"The merge method to use.","enum":["merge","squash","rebase"]},"commit_title":{"type":"string","description":"Title for the merge commit message."},"commit_message":{"type":"string","description":"Commit message for the merge commit."}},"required":["enabled_by","merge_method","commit_title","commit_message"],"nullable":true},"pull-request-simple":{"title":"Pull Request Simple","description":"Pull Request Simple","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/1347"},"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDExOlB1bGxSZXF1ZXN0MQ=="},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/pull/1347"},"diff_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/pull/1347.diff"},"patch_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/pull/1347.patch"},"issue_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/issues/1347"},"commits_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/1347/commits"},"review_comments_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/1347/comments"},"review_comment_url":{"type":"string","example":"https://api.github.com/repos/octocat/Hello-World/pulls/comments{/number}"},"comments_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/issues/1347/comments"},"statuses_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e"},"number":{"type":"integer","example":1347},"state":{"type":"string","example":"open"},"locked":{"type":"boolean","example":true},"title":{"type":"string","example":"new-feature"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"body":{"type":"string","example":"Please pull these awesome changes","nullable":true},"labels":{"type":"array","items":{"type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"url":{"type":"string"},"name":{"type":"string"},"description":{"type":"string"},"color":{"type":"string"},"default":{"type":"boolean"}}}},"milestone":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/milestone"}]},"active_lock_reason":{"type":"string","example":"too heated","nullable":true},"created_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z"},"updated_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z"},"closed_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z","nullable":true},"merged_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z","nullable":true},"merge_commit_sha":{"type":"string","example":"e5bd3914e2e596debea16f433f57875b5b90bcd6","nullable":true},"assignee":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"assignees":{"type":"array","items":{"$ref":"#/components/schemas/simple-user"},"nullable":true},"requested_reviewers":{"type":"array","items":{"$ref":"#/components/schemas/simple-user"},"nullable":true},"requested_teams":{"type":"array","items":{"$ref":"#/components/schemas/team-simple"},"nullable":true},"head":{"type":"object","properties":{"label":{"type":"string"},"ref":{"type":"string"},"repo":{"$ref":"#/components/schemas/repository"},"sha":{"type":"string"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]}},"required":["label","ref","repo","sha","user"]},"base":{"type":"object","properties":{"label":{"type":"string"},"ref":{"type":"string"},"repo":{"$ref":"#/components/schemas/repository"},"sha":{"type":"string"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]}},"required":["label","ref","repo","sha","user"]},"_links":{"type":"object","properties":{"comments":{"$ref":"#/components/schemas/link"},"commits":{"$ref":"#/components/schemas/link"},"statuses":{"$ref":"#/components/schemas/link"},"html":{"$ref":"#/components/schemas/link"},"issue":{"$ref":"#/components/schemas/link"},"review_comments":{"$ref":"#/components/schemas/link"},"review_comment":{"$ref":"#/components/schemas/link"},"self":{"$ref":"#/components/schemas/link"}},"required":["comments","commits","statuses","html","issue","review_comments","review_comment","self"]},"author_association":{"$ref":"#/components/schemas/author_association"},"auto_merge":{"$ref":"#/components/schemas/auto_merge"},"draft":{"description":"Indicates whether or not the pull request is a draft.","example":false,"type":"boolean"}},"required":["_links","assignee","labels","base","body","closed_at","comments_url","commits_url","created_at","diff_url","head","html_url","id","node_id","issue_url","merge_commit_sha","merged_at","milestone","number","patch_url","review_comment_url","review_comments_url","statuses_url","state","locked","title","updated_at","url","user","author_association","auto_merge"]},"simple-commit-status":{"title":"Simple Commit Status","type":"object","properties":{"description":{"type":"string","nullable":true},"id":{"type":"integer"},"node_id":{"type":"string"},"state":{"type":"string"},"context":{"type":"string"},"target_url":{"type":"string","format":"uri"},"required":{"type":"boolean","nullable":true},"avatar_url":{"type":"string","nullable":true,"format":"uri"},"url":{"type":"string","format":"uri"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"}},"required":["description","id","node_id","state","context","target_url","avatar_url","url","created_at","updated_at"]},"combined-commit-status":{"title":"Combined Commit Status","description":"Combined Commit Status","type":"object","properties":{"state":{"type":"string"},"statuses":{"type":"array","items":{"$ref":"#/components/schemas/simple-commit-status"}},"sha":{"type":"string"},"total_count":{"type":"integer"},"repository":{"$ref":"#/components/schemas/minimal-repository"},"commit_url":{"type":"string","format":"uri"},"url":{"type":"string","format":"uri"}},"required":["state","sha","total_count","statuses","repository","commit_url","url"]},"status":{"title":"Status","description":"The status of a commit.","type":"object","properties":{"url":{"type":"string"},"avatar_url":{"type":"string","nullable":true},"id":{"type":"integer"},"node_id":{"type":"string"},"state":{"type":"string"},"description":{"type":"string"},"target_url":{"type":"string"},"context":{"type":"string"},"created_at":{"type":"string"},"updated_at":{"type":"string"},"creator":{"$ref":"#/components/schemas/simple-user"}},"required":["url","avatar_url","id","node_id","state","description","target_url","context","created_at","updated_at","creator"]},"community-health-file":{"title":"Community Health File","type":"object","properties":{"url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"}},"required":["url","html_url"]},"community-profile":{"title":"Community Profile","description":"Community Profile","type":"object","properties":{"health_percentage":{"type":"integer","example":100},"description":{"type":"string","example":"My first repository on GitHub!","nullable":true},"documentation":{"type":"string","example":"example.com","nullable":true},"files":{"type":"object","properties":{"code_of_conduct":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/code-of-conduct-simple"}]},"license":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/license-simple"}]},"contributing":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/community-health-file"}]},"readme":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/community-health-file"}]},"issue_template":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/community-health-file"}]},"pull_request_template":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/community-health-file"}]}},"required":["code_of_conduct","license","contributing","readme","issue_template","pull_request_template"]},"updated_at":{"type":"string","format":"date-time","example":"2017-02-28T19:09:29Z","nullable":true},"content_reports_enabled":{"type":"boolean","example":true}},"required":["health_percentage","description","documentation","files","updated_at"]},"diff-entry":{"title":"Diff Entry","description":"Diff Entry","type":"object","properties":{"sha":{"type":"string","example":"bbcd538c8e72b8c175046e27cc8f907076331401"},"filename":{"type":"string","example":"file1.txt"},"status":{"type":"string","example":"added"},"additions":{"type":"integer","example":103},"deletions":{"type":"integer","example":21},"changes":{"type":"integer","example":124},"blob_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/blob/6dcb09b5b57875f334f61aebed695e2e4193db5e/file1.txt"},"raw_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/raw/6dcb09b5b57875f334f61aebed695e2e4193db5e/file1.txt"},"contents_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/contents/file1.txt?ref=6dcb09b5b57875f334f61aebed695e2e4193db5e"},"patch":{"type":"string","example":"@@ -132,7 +132,7 @@ module Test @@ -1000,7 +1000,7 @@ module Test"},"previous_filename":{"type":"string","example":"file.txt"}},"required":["additions","blob_url","changes","contents_url","deletions","filename","raw_url","sha","status"]},"commit-comparison":{"title":"Commit Comparison","description":"Commit Comparison","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/compare/master...topic"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/compare/master...topic"},"permalink_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/compare/octocat:bbcd538c8e72b8c175046e27cc8f907076331401...octocat:0328041d1152db8ae77652d1618a02e57f745f17"},"diff_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/compare/master...topic.diff"},"patch_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/compare/master...topic.patch"},"base_commit":{"$ref":"#/components/schemas/commit"},"merge_base_commit":{"$ref":"#/components/schemas/commit"},"status":{"type":"string","enum":["diverged","ahead","behind","identical"],"example":"ahead"},"ahead_by":{"type":"integer","example":4},"behind_by":{"type":"integer","example":5},"total_commits":{"type":"integer","example":6},"commits":{"type":"array","items":{"$ref":"#/components/schemas/commit"}},"files":{"type":"array","items":{"$ref":"#/components/schemas/diff-entry"}}},"required":["url","html_url","permalink_url","diff_url","patch_url","base_commit","merge_base_commit","status","ahead_by","behind_by","total_commits","commits","files"]},"content-tree":{"title":"Content Tree","description":"Content Tree","type":"object","properties":{"type":{"type":"string"},"size":{"type":"integer"},"name":{"type":"string"},"path":{"type":"string"},"sha":{"type":"string"},"url":{"type":"string","format":"uri"},"git_url":{"type":"string","format":"uri","nullable":true},"html_url":{"type":"string","format":"uri","nullable":true},"download_url":{"type":"string","format":"uri","nullable":true},"entries":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"size":{"type":"integer"},"name":{"type":"string"},"path":{"type":"string"},"content":{"type":"string"},"sha":{"type":"string"},"url":{"type":"string","format":"uri"},"git_url":{"type":"string","format":"uri","nullable":true},"html_url":{"type":"string","format":"uri","nullable":true},"download_url":{"type":"string","format":"uri","nullable":true},"_links":{"type":"object","properties":{"git":{"type":"string","format":"uri","nullable":true},"html":{"type":"string","format":"uri","nullable":true},"self":{"type":"string","format":"uri"}},"required":["git","html","self"]}},"required":["_links","git_url","html_url","download_url","name","path","sha","size","type","url"]}},"_links":{"type":"object","properties":{"git":{"type":"string","format":"uri","nullable":true},"html":{"type":"string","format":"uri","nullable":true},"self":{"type":"string","format":"uri"}},"required":["git","html","self"]}},"required":["_links","git_url","html_url","download_url","name","path","sha","size","type","url","content","encoding"]},"content-directory":{"title":"Content Directory","description":"A list of directory items","type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"size":{"type":"integer"},"name":{"type":"string"},"path":{"type":"string"},"content":{"type":"string"},"sha":{"type":"string"},"url":{"type":"string","format":"uri"},"git_url":{"type":"string","format":"uri","nullable":true},"html_url":{"type":"string","format":"uri","nullable":true},"download_url":{"type":"string","format":"uri","nullable":true},"_links":{"type":"object","properties":{"git":{"type":"string","format":"uri","nullable":true},"html":{"type":"string","format":"uri","nullable":true},"self":{"type":"string","format":"uri"}},"required":["git","html","self"]}},"required":["_links","git_url","html_url","download_url","name","path","sha","size","type","url"]}},"content-file":{"title":"Content File","description":"Content File","type":"object","properties":{"type":{"type":"string"},"encoding":{"type":"string"},"size":{"type":"integer"},"name":{"type":"string"},"path":{"type":"string"},"content":{"type":"string"},"sha":{"type":"string"},"url":{"type":"string","format":"uri"},"git_url":{"type":"string","format":"uri","nullable":true},"html_url":{"type":"string","format":"uri","nullable":true},"download_url":{"type":"string","format":"uri","nullable":true},"_links":{"type":"object","properties":{"git":{"type":"string","format":"uri","nullable":true},"html":{"type":"string","format":"uri","nullable":true},"self":{"type":"string","format":"uri"}},"required":["git","html","self"]},"target":{"type":"string","example":"\\"actual/actual.md\\""},"submodule_git_url":{"type":"string","example":"\\"git://example.com/defunkt/dotjs.git\\""}},"required":["_links","git_url","html_url","download_url","name","path","sha","size","type","url","content","encoding"]},"content-symlink":{"title":"Symlink Content","description":"An object describing a symlink","type":"object","properties":{"type":{"type":"string"},"target":{"type":"string"},"size":{"type":"integer"},"name":{"type":"string"},"path":{"type":"string"},"sha":{"type":"string"},"url":{"type":"string","format":"uri"},"git_url":{"type":"string","format":"uri","nullable":true},"html_url":{"type":"string","format":"uri","nullable":true},"download_url":{"type":"string","format":"uri","nullable":true},"_links":{"type":"object","properties":{"git":{"type":"string","format":"uri","nullable":true},"html":{"type":"string","format":"uri","nullable":true},"self":{"type":"string","format":"uri"}},"required":["git","html","self"]}},"required":["_links","git_url","html_url","download_url","name","path","sha","size","type","url","target"]},"content-submodule":{"title":"Symlink Content","description":"An object describing a symlink","type":"object","properties":{"type":{"type":"string"},"submodule_git_url":{"type":"string","format":"uri"},"size":{"type":"integer"},"name":{"type":"string"},"path":{"type":"string"},"sha":{"type":"string"},"url":{"type":"string","format":"uri"},"git_url":{"type":"string","format":"uri","nullable":true},"html_url":{"type":"string","format":"uri","nullable":true},"download_url":{"type":"string","format":"uri","nullable":true},"_links":{"type":"object","properties":{"git":{"type":"string","format":"uri","nullable":true},"html":{"type":"string","format":"uri","nullable":true},"self":{"type":"string","format":"uri"}},"required":["git","html","self"]}},"required":["_links","git_url","html_url","download_url","name","path","sha","size","type","url","submodule_git_url"]},"file-commit":{"title":"File Commit","description":"File Commit","type":"object","required":["content","commit"],"properties":{"content":{"type":"object","properties":{"name":{"type":"string"},"path":{"type":"string"},"sha":{"type":"string"},"size":{"type":"integer"},"url":{"type":"string"},"html_url":{"type":"string"},"git_url":{"type":"string"},"download_url":{"type":"string"},"type":{"type":"string"},"_links":{"type":"object","properties":{"self":{"type":"string"},"git":{"type":"string"},"html":{"type":"string"}}}},"nullable":true},"commit":{"type":"object","properties":{"sha":{"type":"string"},"node_id":{"type":"string"},"url":{"type":"string"},"html_url":{"type":"string"},"author":{"type":"object","properties":{"date":{"type":"string"},"name":{"type":"string"},"email":{"type":"string"}}},"committer":{"type":"object","properties":{"date":{"type":"string"},"name":{"type":"string"},"email":{"type":"string"}}},"message":{"type":"string"},"tree":{"type":"object","properties":{"url":{"type":"string"},"sha":{"type":"string"}}},"parents":{"type":"array","items":{"type":"object","properties":{"url":{"type":"string"},"html_url":{"type":"string"},"sha":{"type":"string"}}}},"verification":{"type":"object","properties":{"verified":{"type":"boolean"},"reason":{"type":"string"},"signature":{"type":"string","nullable":true},"payload":{"type":"string","nullable":true}}}}}}},"contributor":{"title":"Contributor","description":"Contributor","type":"object","properties":{"login":{"type":"string"},"id":{"type":"integer"},"node_id":{"type":"string"},"avatar_url":{"type":"string","format":"uri"},"gravatar_id":{"type":"string","nullable":true},"url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"followers_url":{"type":"string","format":"uri"},"following_url":{"type":"string"},"gists_url":{"type":"string"},"starred_url":{"type":"string"},"subscriptions_url":{"type":"string","format":"uri"},"organizations_url":{"type":"string","format":"uri"},"repos_url":{"type":"string","format":"uri"},"events_url":{"type":"string"},"received_events_url":{"type":"string","format":"uri"},"type":{"type":"string"},"site_admin":{"type":"boolean"},"contributions":{"type":"integer"},"email":{"type":"string"},"name":{"type":"string"}},"required":["contributions","type"]},"deployment-status":{"title":"Deployment Status","description":"The status of a deployment.","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example/deployments/42/statuses/1"},"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDE2OkRlcGxveW1lbnRTdGF0dXMx"},"state":{"description":"The state of the status.","enum":["error","failure","inactive","pending","success","queued","in_progress"],"example":"success","type":"string"},"creator":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"description":{"description":"A short description of the status.","default":"","type":"string","maxLength":140,"example":"Deployment finished successfully."},"environment":{"description":"The environment of the deployment that the status is for.","default":"","type":"string","example":"production"},"target_url":{"description":"Deprecated: the URL to associate with this status.","default":"","type":"string","format":"uri","example":"https://example.com/deployment/42/output"},"created_at":{"type":"string","format":"date-time","example":"2012-07-20T01:19:13Z"},"updated_at":{"type":"string","format":"date-time","example":"2012-07-20T01:19:13Z"},"deployment_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example/deployments/42"},"repository_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example"},"environment_url":{"description":"The URL for accessing your environment.","default":"","type":"string","format":"uri","example":"https://staging.example.com/"},"log_url":{"description":"The URL to associate with this status.","default":"","type":"string","format":"uri","example":"https://example.com/deployment/42/output"},"performed_via_github_app":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/integration"}]}},"required":["id","node_id","state","creator","description","deployment_url","target_url","repository_url","url","created_at","updated_at"]},"wait-timer":{"type":"integer","example":30,"description":"The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days)."},"deployment_branch_policy":{"type":"object","description":"The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.","properties":{"protected_branches":{"type":"boolean","description":"Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`."},"custom_branch_policies":{"type":"boolean","description":"Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`."}},"nullable":true,"required":["protected_branches","custom_branch_policies"]},"environment":{"title":"Environment","description":"Details of a deployment environment","type":"object","properties":{"id":{"description":"The id of the environment.","example":56780428,"type":"integer"},"node_id":{"type":"string","example":"MDExOkVudmlyb25tZW50NTY3ODA0Mjg="},"name":{"description":"The name of the environment.","example":"staging","type":"string"},"url":{"type":"string","example":"https://api.github.com/repos/github/hello-world/environments/staging"},"html_url":{"type":"string","example":"https://github.com/github/hello-world/deployments/activity_log?environments_filter=staging"},"created_at":{"description":"The time that the environment was created, in ISO 8601 format.","example":"2020-11-23T22:00:40Z","format":"date-time","type":"string"},"updated_at":{"description":"The time that the environment was last updated, in ISO 8601 format.","example":"2020-11-23T22:00:40Z","format":"date-time","type":"string"},"protection_rules":{"type":"array","items":{"anyOf":[{"type":"object","properties":{"id":{"type":"integer","example":3515},"node_id":{"type":"string","example":"MDQ6R2F0ZTM1MTU="},"type":{"type":"string","example":"wait_timer"},"wait_timer":{"$ref":"#/components/schemas/wait-timer"}},"required":["id","node_id","type"]},{"type":"object","properties":{"id":{"type":"integer","example":3755},"node_id":{"type":"string","example":"MDQ6R2F0ZTM3NTU="},"type":{"type":"string","example":"required_reviewers"},"reviewers":{"type":"array","description":"The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.","items":{"type":"object","properties":{"type":{"$ref":"#/components/schemas/deployment-reviewer-type"},"reviewer":{"anyOf":[{"$ref":"#/components/schemas/simple-user"},{"$ref":"#/components/schemas/team-simple"}]}}}}},"required":["id","node_id","type"]},{"type":"object","properties":{"id":{"type":"integer","example":3515},"node_id":{"type":"string","example":"MDQ6R2F0ZTM1MTU="},"type":{"type":"string","example":"branch_policy"}},"required":["id","node_id","type"]}]}},"deployment_branch_policy":{"$ref":"#/components/schemas/deployment_branch_policy"}},"required":["id","node_id","name","url","html_url","created_at","updated_at"]},"short-blob":{"title":"Short Blob","description":"Short Blob","type":"object","properties":{"url":{"type":"string"},"sha":{"type":"string"}},"required":["url","sha"]},"blob":{"title":"Blob","description":"Blob","type":"object","properties":{"content":{"type":"string"},"encoding":{"type":"string"},"url":{"type":"string","format":"uri"},"sha":{"type":"string"},"size":{"type":"integer","nullable":true},"node_id":{"type":"string"},"highlighted_content":{"type":"string"}},"required":["sha","url","node_id","size","content","encoding"]},"git-commit":{"title":"Git Commit","description":"Low-level Git commit operations within a repository","type":"object","properties":{"sha":{"description":"SHA for the commit","example":"7638417db6d59f3c431d3e1f261cc637155684cd","type":"string"},"node_id":{"type":"string"},"url":{"type":"string","format":"uri"},"author":{"description":"Identifying information for the git-user","type":"object","properties":{"date":{"description":"Timestamp of the commit","example":"2014-08-09T08:02:04+12:00","format":"date-time","type":"string"},"email":{"type":"string","description":"Git email address of the user","example":"monalisa.octocat@example.com"},"name":{"description":"Name of the git user","example":"Monalisa Octocat","type":"string"}},"required":["email","name","date"]},"committer":{"description":"Identifying information for the git-user","type":"object","properties":{"date":{"description":"Timestamp of the commit","example":"2014-08-09T08:02:04+12:00","format":"date-time","type":"string"},"email":{"type":"string","description":"Git email address of the user","example":"monalisa.octocat@example.com"},"name":{"description":"Name of the git user","example":"Monalisa Octocat","type":"string"}},"required":["email","name","date"]},"message":{"description":"Message describing the purpose of the commit","example":"Fix #42","type":"string"},"tree":{"type":"object","properties":{"sha":{"description":"SHA for the commit","example":"7638417db6d59f3c431d3e1f261cc637155684cd","type":"string"},"url":{"type":"string","format":"uri"}},"required":["sha","url"]},"parents":{"type":"array","items":{"type":"object","properties":{"sha":{"description":"SHA for the commit","example":"7638417db6d59f3c431d3e1f261cc637155684cd","type":"string"},"url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"}},"required":["sha","url","html_url"]}},"verification":{"type":"object","properties":{"verified":{"type":"boolean"},"reason":{"type":"string"},"signature":{"type":"string","nullable":true},"payload":{"type":"string","nullable":true}},"required":["verified","reason","signature","payload"]},"html_url":{"type":"string","format":"uri"}},"required":["sha","node_id","url","html_url","author","committer","tree","message","parents","verification"]},"git-ref":{"title":"Git Reference","description":"Git references within a repository","type":"object","properties":{"ref":{"type":"string"},"node_id":{"type":"string"},"url":{"type":"string","format":"uri"},"object":{"type":"object","properties":{"type":{"type":"string"},"sha":{"description":"SHA for the reference","example":"7638417db6d59f3c431d3e1f261cc637155684cd","type":"string","minLength":40,"maxLength":40},"url":{"type":"string","format":"uri"}},"required":["type","sha","url"]}},"required":["ref","node_id","url","object"]},"git-tag":{"title":"Git Tag","description":"Metadata for a Git tag","type":"object","properties":{"node_id":{"type":"string","example":"MDM6VGFnOTQwYmQzMzYyNDhlZmFlMGY5ZWU1YmM3YjJkNWM5ODU4ODdiMTZhYw=="},"tag":{"description":"Name of the tag","example":"v0.0.1","type":"string"},"sha":{"type":"string","example":"940bd336248efae0f9ee5bc7b2d5c985887b16ac"},"url":{"description":"URL for the tag","example":"https://api.github.com/repositories/42/git/tags/940bd336248efae0f9ee5bc7b2d5c985887b16ac","type":"string","format":"uri"},"message":{"description":"Message describing the purpose of the tag","example":"Initial public release","type":"string"},"tagger":{"type":"object","properties":{"date":{"type":"string"},"email":{"type":"string"},"name":{"type":"string"}},"required":["date","email","name"]},"object":{"type":"object","properties":{"sha":{"type":"string"},"type":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["sha","type","url"]},"verification":{"$ref":"#/components/schemas/verification"}},"required":["sha","url","node_id","tagger","object","tag","message"]},"git-tree":{"title":"Git Tree","description":"The hierarchy between files in a Git repository.","type":"object","properties":{"sha":{"type":"string"},"url":{"type":"string","format":"uri"},"truncated":{"type":"boolean"},"tree":{"description":"Objects specifying a tree structure","type":"array","items":{"type":"object","properties":{"path":{"type":"string","example":"test/file.rb"},"mode":{"type":"string","example":"040000"},"type":{"type":"string","example":"tree"},"sha":{"type":"string","example":"23f6827669e43831def8a7ad935069c8bd418261"},"size":{"type":"integer","example":12},"url":{"type":"string","example":"https://api.github.com/repos/owner-482f3203ecf01f67e9deb18e/BBB_Private_Repo/git/blobs/23f6827669e43831def8a7ad935069c8bd418261"}}},"example":[{"path":"file.rb","mode":"100644","type":"blob","size":30,"sha":"44b4fc6d56897b048c772eb4087f854f46256132","url":"https://api.github.com/repos/octocat/Hello-World/git/blobs/44b4fc6d56897b048c772eb4087f854f46256132","properties":{"path":{"type":"string"},"mode":{"type":"string"},"type":{"type":"string"},"size":{"type":"integer"},"sha":{"type":"string"},"url":{"type":"string"}},"required":["path","mode","type","sha","url","size"]}]}},"required":["sha","url","tree","truncated"]},"hook-response":{"title":"Hook Response","type":"object","properties":{"code":{"type":"integer","nullable":true},"status":{"type":"string","nullable":true},"message":{"type":"string","nullable":true}},"required":["code","status","message"]},"hook":{"title":"Webhook","description":"Webhooks for repositories.","type":"object","properties":{"type":{"type":"string"},"id":{"description":"Unique identifier of the webhook.","example":42,"type":"integer"},"name":{"description":"The name of a valid service, use \'web\' for a webhook.","example":"web","type":"string"},"active":{"description":"Determines whether the hook is actually triggered on pushes.","type":"boolean","example":true},"events":{"description":"Determines what events the hook is triggered for. Default: [\'push\'].","type":"array","items":{"type":"string"},"example":["push","pull_request"]},"config":{"type":"object","properties":{"email":{"type":"string","example":"\\"foo@bar.com\\""},"password":{"type":"string","example":"\\"foo\\""},"room":{"type":"string","example":"\\"roomer\\""},"subdomain":{"type":"string","example":"\\"foo\\""},"url":{"$ref":"#/components/schemas/webhook-config-url"},"insecure_ssl":{"$ref":"#/components/schemas/webhook-config-insecure-ssl"},"content_type":{"$ref":"#/components/schemas/webhook-config-content-type"},"digest":{"type":"string","example":"\\"sha256\\""},"secret":{"$ref":"#/components/schemas/webhook-config-secret"},"token":{"type":"string","example":"\\"abc\\""}}},"updated_at":{"type":"string","format":"date-time","example":"2011-09-06T20:39:23Z"},"created_at":{"type":"string","format":"date-time","example":"2011-09-06T17:26:27Z"},"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/hooks/1"},"test_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/hooks/1/test"},"ping_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/hooks/1/pings"},"last_response":{"$ref":"#/components/schemas/hook-response"}},"required":["id","url","type","name","active","events","config","ping_url","created_at","updated_at","last_response","test_url"]},"import":{"title":"Import","description":"A repository import from an external source.","type":"object","properties":{"vcs":{"type":"string","nullable":true},"use_lfs":{"type":"string"},"vcs_url":{"description":"The URL of the originating repository.","type":"string"},"svc_root":{"type":"string"},"tfvc_project":{"type":"string"},"status":{"type":"string","enum":["auth","error","none","detecting","choose","auth_failed","importing","mapping","waiting_to_push","pushing","complete","setup","unknown","detection_found_multiple","detection_found_nothing","detection_needs_auth"]},"status_text":{"type":"string","nullable":true},"failed_step":{"type":"string","nullable":true},"error_message":{"type":"string","nullable":true},"import_percent":{"type":"integer","nullable":true},"commit_count":{"type":"integer","nullable":true},"push_percent":{"type":"integer","nullable":true},"has_large_files":{"type":"boolean"},"large_files_size":{"type":"integer"},"large_files_count":{"type":"integer"},"project_choices":{"type":"array","items":{"type":"object","properties":{"vcs":{"type":"string"},"tfvc_project":{"type":"string"},"human_name":{"type":"string"}}}},"message":{"type":"string"},"authors_count":{"type":"integer","nullable":true},"url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"authors_url":{"type":"string","format":"uri"},"repository_url":{"type":"string","format":"uri"},"svn_root":{"type":"string"}},"required":["vcs","vcs_url","status","url","repository_url","html_url","authors_url"]},"porter-author":{"title":"Porter Author","description":"Porter Author","type":"object","properties":{"id":{"type":"integer"},"remote_id":{"type":"string"},"remote_name":{"type":"string"},"email":{"type":"string"},"name":{"type":"string"},"url":{"type":"string","format":"uri"},"import_url":{"type":"string","format":"uri"}},"required":["id","remote_id","remote_name","email","name","url","import_url"]},"porter-large-file":{"title":"Porter Large File","description":"Porter Large File","type":"object","properties":{"ref_name":{"type":"string"},"path":{"type":"string"},"oid":{"type":"string"},"size":{"type":"integer"}},"required":["oid","path","ref_name","size"]},"issue-event-label":{"title":"Issue Event Label","description":"Issue Event Label","type":"object","properties":{"name":{"type":"string","nullable":true},"color":{"type":"string","nullable":true}},"required":["name","color"]},"issue-event-dismissed-review":{"title":"Issue Event Dismissed Review","type":"object","properties":{"state":{"type":"string"},"review_id":{"type":"integer"},"dismissal_message":{"type":"string","nullable":true},"dismissal_commit_id":{"type":"string","nullable":true}},"required":["state","review_id","dismissal_message"]},"issue-event-milestone":{"title":"Issue Event Milestone","description":"Issue Event Milestone","type":"object","properties":{"title":{"type":"string"}},"required":["title"]},"issue-event-project-card":{"title":"Issue Event Project Card","description":"Issue Event Project Card","type":"object","properties":{"url":{"type":"string","format":"uri"},"id":{"type":"integer"},"project_url":{"type":"string","format":"uri"},"project_id":{"type":"integer"},"column_name":{"type":"string"},"previous_column_name":{"type":"string"}},"required":["url","id","project_url","project_id","column_name"]},"issue-event-rename":{"title":"Issue Event Rename","description":"Issue Event Rename","type":"object","properties":{"from":{"type":"string"},"to":{"type":"string"}},"required":["from","to"]},"issue-event":{"title":"Issue Event","description":"Issue Event","type":"object","properties":{"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDEwOklzc3VlRXZlbnQx"},"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/issues/events/1"},"actor":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"event":{"type":"string","example":"closed"},"commit_id":{"type":"string","example":"6dcb09b5b57875f334f61aebed695e2e4193db5e","nullable":true},"commit_url":{"type":"string","example":"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e","nullable":true},"created_at":{"type":"string","format":"date-time","example":"2011-04-14T16:00:49Z"},"issue":{"$ref":"#/components/schemas/issue-simple"},"label":{"$ref":"#/components/schemas/issue-event-label"},"assignee":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"assigner":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"review_requester":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"requested_reviewer":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"requested_team":{"$ref":"#/components/schemas/team"},"dismissed_review":{"$ref":"#/components/schemas/issue-event-dismissed-review"},"milestone":{"$ref":"#/components/schemas/issue-event-milestone"},"project_card":{"$ref":"#/components/schemas/issue-event-project-card"},"rename":{"$ref":"#/components/schemas/issue-event-rename"},"author_association":{"$ref":"#/components/schemas/author_association"},"lock_reason":{"type":"string","nullable":true}},"required":["id","node_id","url","actor","event","commit_id","commit_url","created_at"]},"issue-event-for-issue":{"title":"Issue Event for Issue","description":"Issue Event for Issue","type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"url":{"type":"string"},"actor":{"$ref":"#/components/schemas/simple-user"},"event":{"type":"string"},"commit_id":{"type":"string","nullable":true},"commit_url":{"type":"string","nullable":true},"created_at":{"type":"string"},"sha":{"type":"string","example":"\\"480d4f47447129f015cb327536c522ca683939a1\\""},"html_url":{"type":"string","example":"\\"https://github.com/owner-3906e11a33a3d55ba449d63f/BBB_Private_Repo/commit/480d4f47447129f015cb327536c522ca683939a1\\""},"message":{"type":"string","example":"\\"add a bunch of files\\""},"issue_url":{"type":"string","example":"\\"https://api.github.com/repos/owner-3906e11a33a3d55ba449d63f/AAA_Public_Repo/issues/1\\""},"updated_at":{"type":"string","example":"\\"2020-07-09T00:17:36Z\\""},"author_association":{"$ref":"#/components/schemas/author_association"},"body":{"type":"string","example":"\\":+1:\\""},"lock_reason":{"type":"string","example":"\\"off-topic\\""},"submitted_at":{"type":"string","example":"\\"2020-07-09T00:17:51Z\\""},"state":{"type":"string","example":"\\"commented\\""},"pull_request_url":{"type":"string","example":"\\"https://api.github.com/repos/owner-3906e11a33a3d55ba449d63f/AAA_Public_Repo/pulls/2\\""},"body_html":{"type":"string","example":"\\"<p>Accusantium fugiat cumque. Autem qui nostrum. Atque quae ullam.</p>\\""},"body_text":{"type":"string","example":"\\"Accusantium fugiat cumque. Autem qui nostrum. Atque quae ullam.\\""}}},"deploy-key":{"title":"Deploy Key","description":"An SSH key granting access to a single repository.","type":"object","properties":{"id":{"type":"integer"},"key":{"type":"string"},"url":{"type":"string"},"title":{"type":"string"},"verified":{"type":"boolean"},"created_at":{"type":"string"},"read_only":{"type":"boolean"}},"required":["id","key","url","title","verified","created_at","read_only"]},"language":{"title":"Language","description":"Language","type":"object","additionalProperties":{"type":"integer"}},"license-content":{"title":"License Content","description":"License Content","type":"object","properties":{"name":{"type":"string"},"path":{"type":"string"},"sha":{"type":"string"},"size":{"type":"integer"},"url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri","nullable":true},"git_url":{"type":"string","format":"uri","nullable":true},"download_url":{"type":"string","format":"uri","nullable":true},"type":{"type":"string"},"content":{"type":"string"},"encoding":{"type":"string"},"_links":{"type":"object","properties":{"git":{"type":"string","format":"uri","nullable":true},"html":{"type":"string","format":"uri","nullable":true},"self":{"type":"string","format":"uri"}},"required":["git","html","self"]},"license":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/license-simple"}]}},"required":["_links","git_url","html_url","download_url","name","path","sha","size","type","url","content","encoding","license"]},"pages-source-hash":{"title":"Pages Source Hash","type":"object","properties":{"branch":{"type":"string"},"path":{"type":"string"}},"required":["branch","path"]},"page":{"title":"GitHub Pages","description":"The configuration for GitHub Pages for a repository.","type":"object","properties":{"url":{"type":"string","description":"The API address for accessing this Page resource.","format":"uri","example":"https://api.github.com/repos/github/hello-world/pages"},"status":{"type":"string","description":"The status of the most recent build of the Page.","example":"built","enum":["built","building","errored"],"nullable":true},"cname":{"description":"The Pages site\'s custom domain","example":"example.com","type":"string","nullable":true},"custom_404":{"type":"boolean","description":"Whether the Page has a custom 404 page.","example":false,"default":false},"html_url":{"type":"string","description":"The web address the Page can be accessed from.","format":"uri","example":"https://example.com"},"source":{"$ref":"#/components/schemas/pages-source-hash"},"public":{"type":"boolean","description":"Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site.","example":true}},"required":["url","status","cname","custom_404","public"]},"page-build":{"title":"Page Build","description":"Page Build","type":"object","properties":{"url":{"type":"string","format":"uri"},"status":{"type":"string"},"error":{"type":"object","properties":{"message":{"type":"string","nullable":true}},"required":["message"]},"pusher":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"commit":{"type":"string"},"duration":{"type":"integer"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"}},"required":["url","status","error","pusher","commit","duration","created_at","updated_at"]},"page-build-status":{"title":"Page Build Status","description":"Page Build Status","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/github/hello-world/pages/builds/latest"},"status":{"type":"string","example":"queued"}},"required":["url","status"]},"pull-request":{"type":"object","title":"Pull Request","description":"Pull requests let you tell others about changes you\'ve pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/1347"},"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDExOlB1bGxSZXF1ZXN0MQ=="},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/pull/1347"},"diff_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/pull/1347.diff"},"patch_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/pull/1347.patch"},"issue_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/issues/1347"},"commits_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/1347/commits"},"review_comments_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/1347/comments"},"review_comment_url":{"type":"string","example":"https://api.github.com/repos/octocat/Hello-World/pulls/comments{/number}"},"comments_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/issues/1347/comments"},"statuses_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e"},"number":{"description":"Number uniquely identifying the pull request within its repository.","example":42,"type":"integer"},"state":{"description":"State of this Pull Request. Either `open` or `closed`.","enum":["open","closed"],"example":"open","type":"string"},"locked":{"type":"boolean","example":true},"title":{"description":"The title of the pull request.","example":"Amazing new feature","type":"string"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"body":{"type":"string","example":"Please pull these awesome changes","nullable":true},"labels":{"type":"array","items":{"type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"url":{"type":"string"},"name":{"type":"string"},"description":{"type":"string","nullable":true},"color":{"type":"string"},"default":{"type":"boolean"}}}},"milestone":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/milestone"}]},"active_lock_reason":{"type":"string","example":"too heated","nullable":true},"created_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z"},"updated_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z"},"closed_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z","nullable":true},"merged_at":{"type":"string","format":"date-time","example":"2011-01-26T19:01:12Z","nullable":true},"merge_commit_sha":{"type":"string","example":"e5bd3914e2e596debea16f433f57875b5b90bcd6","nullable":true},"assignee":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"assignees":{"type":"array","items":{"$ref":"#/components/schemas/simple-user"},"nullable":true},"requested_reviewers":{"type":"array","items":{"$ref":"#/components/schemas/simple-user"},"nullable":true},"requested_teams":{"type":"array","items":{"$ref":"#/components/schemas/team-simple"},"nullable":true},"head":{"type":"object","properties":{"label":{"type":"string"},"ref":{"type":"string"},"repo":{"type":"object","properties":{"archive_url":{"type":"string"},"assignees_url":{"type":"string"},"blobs_url":{"type":"string"},"branches_url":{"type":"string"},"collaborators_url":{"type":"string"},"comments_url":{"type":"string"},"commits_url":{"type":"string"},"compare_url":{"type":"string"},"contents_url":{"type":"string"},"contributors_url":{"type":"string","format":"uri"},"deployments_url":{"type":"string","format":"uri"},"description":{"type":"string","nullable":true},"downloads_url":{"type":"string","format":"uri"},"events_url":{"type":"string","format":"uri"},"fork":{"type":"boolean"},"forks_url":{"type":"string","format":"uri"},"full_name":{"type":"string"},"git_commits_url":{"type":"string"},"git_refs_url":{"type":"string"},"git_tags_url":{"type":"string"},"hooks_url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"id":{"type":"integer"},"node_id":{"type":"string"},"issue_comment_url":{"type":"string"},"issue_events_url":{"type":"string"},"issues_url":{"type":"string"},"keys_url":{"type":"string"},"labels_url":{"type":"string"},"languages_url":{"type":"string","format":"uri"},"merges_url":{"type":"string","format":"uri"},"milestones_url":{"type":"string"},"name":{"type":"string"},"notifications_url":{"type":"string"},"owner":{"type":"object","properties":{"avatar_url":{"type":"string","format":"uri"},"events_url":{"type":"string"},"followers_url":{"type":"string","format":"uri"},"following_url":{"type":"string"},"gists_url":{"type":"string"},"gravatar_id":{"type":"string","nullable":true},"html_url":{"type":"string","format":"uri"},"id":{"type":"integer"},"node_id":{"type":"string"},"login":{"type":"string"},"organizations_url":{"type":"string","format":"uri"},"received_events_url":{"type":"string","format":"uri"},"repos_url":{"type":"string","format":"uri"},"site_admin":{"type":"boolean"},"starred_url":{"type":"string"},"subscriptions_url":{"type":"string","format":"uri"},"type":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["avatar_url","events_url","followers_url","following_url","gists_url","gravatar_id","html_url","id","node_id","login","organizations_url","received_events_url","repos_url","site_admin","starred_url","subscriptions_url","type","url"]},"private":{"type":"boolean"},"pulls_url":{"type":"string"},"releases_url":{"type":"string"},"stargazers_url":{"type":"string","format":"uri"},"statuses_url":{"type":"string"},"subscribers_url":{"type":"string","format":"uri"},"subscription_url":{"type":"string","format":"uri"},"tags_url":{"type":"string","format":"uri"},"teams_url":{"type":"string","format":"uri"},"trees_url":{"type":"string"},"url":{"type":"string","format":"uri"},"clone_url":{"type":"string"},"default_branch":{"type":"string"},"forks":{"type":"integer"},"forks_count":{"type":"integer"},"git_url":{"type":"string"},"has_downloads":{"type":"boolean"},"has_issues":{"type":"boolean"},"has_projects":{"type":"boolean"},"has_wiki":{"type":"boolean"},"has_pages":{"type":"boolean"},"homepage":{"type":"string","format":"uri","nullable":true},"language":{"type":"string","nullable":true},"master_branch":{"type":"string"},"archived":{"type":"boolean"},"disabled":{"type":"boolean"},"mirror_url":{"type":"string","format":"uri","nullable":true},"open_issues":{"type":"integer"},"open_issues_count":{"type":"integer"},"permissions":{"type":"object","properties":{"admin":{"type":"boolean"},"pull":{"type":"boolean"},"push":{"type":"boolean"}},"required":["admin","pull","push"]},"temp_clone_token":{"type":"string"},"allow_merge_commit":{"type":"boolean"},"allow_squash_merge":{"type":"boolean"},"allow_rebase_merge":{"type":"boolean"},"license":{"type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"url":{"type":"string","format":"uri","nullable":true},"spdx_id":{"type":"string","nullable":true},"node_id":{"type":"string"}},"required":["key","name","url","spdx_id","node_id"],"nullable":true},"pushed_at":{"type":"string","format":"date-time"},"size":{"type":"integer"},"ssh_url":{"type":"string"},"stargazers_count":{"type":"integer"},"svn_url":{"type":"string","format":"uri"},"topics":{"type":"array","items":{"type":"string"}},"watchers":{"type":"integer"},"watchers_count":{"type":"integer"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"}},"required":["archive_url","assignees_url","blobs_url","branches_url","collaborators_url","comments_url","commits_url","compare_url","contents_url","contributors_url","deployments_url","description","downloads_url","events_url","fork","forks_url","full_name","git_commits_url","git_refs_url","git_tags_url","hooks_url","html_url","id","node_id","issue_comment_url","issue_events_url","issues_url","keys_url","labels_url","languages_url","merges_url","milestones_url","name","notifications_url","owner","private","pulls_url","releases_url","stargazers_url","statuses_url","subscribers_url","subscription_url","tags_url","teams_url","trees_url","url","clone_url","default_branch","forks","forks_count","git_url","has_downloads","has_issues","has_projects","has_wiki","has_pages","homepage","language","archived","disabled","mirror_url","open_issues","open_issues_count","license","pushed_at","size","ssh_url","stargazers_count","svn_url","watchers","watchers_count","created_at","updated_at"]},"sha":{"type":"string"},"user":{"type":"object","properties":{"avatar_url":{"type":"string","format":"uri"},"events_url":{"type":"string"},"followers_url":{"type":"string","format":"uri"},"following_url":{"type":"string"},"gists_url":{"type":"string"},"gravatar_id":{"type":"string","nullable":true},"html_url":{"type":"string","format":"uri"},"id":{"type":"integer"},"node_id":{"type":"string"},"login":{"type":"string"},"organizations_url":{"type":"string","format":"uri"},"received_events_url":{"type":"string","format":"uri"},"repos_url":{"type":"string","format":"uri"},"site_admin":{"type":"boolean"},"starred_url":{"type":"string"},"subscriptions_url":{"type":"string","format":"uri"},"type":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["avatar_url","events_url","followers_url","following_url","gists_url","gravatar_id","html_url","id","node_id","login","organizations_url","received_events_url","repos_url","site_admin","starred_url","subscriptions_url","type","url"]}},"required":["label","ref","repo","sha","user"]},"base":{"type":"object","properties":{"label":{"type":"string"},"ref":{"type":"string"},"repo":{"type":"object","properties":{"archive_url":{"type":"string"},"assignees_url":{"type":"string"},"blobs_url":{"type":"string"},"branches_url":{"type":"string"},"collaborators_url":{"type":"string"},"comments_url":{"type":"string"},"commits_url":{"type":"string"},"compare_url":{"type":"string"},"contents_url":{"type":"string"},"contributors_url":{"type":"string","format":"uri"},"deployments_url":{"type":"string","format":"uri"},"description":{"type":"string","nullable":true},"downloads_url":{"type":"string","format":"uri"},"events_url":{"type":"string","format":"uri"},"fork":{"type":"boolean"},"forks_url":{"type":"string","format":"uri"},"full_name":{"type":"string"},"git_commits_url":{"type":"string"},"git_refs_url":{"type":"string"},"git_tags_url":{"type":"string"},"hooks_url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"id":{"type":"integer"},"node_id":{"type":"string"},"issue_comment_url":{"type":"string"},"issue_events_url":{"type":"string"},"issues_url":{"type":"string"},"keys_url":{"type":"string"},"labels_url":{"type":"string"},"languages_url":{"type":"string","format":"uri"},"merges_url":{"type":"string","format":"uri"},"milestones_url":{"type":"string"},"name":{"type":"string"},"notifications_url":{"type":"string"},"owner":{"type":"object","properties":{"avatar_url":{"type":"string","format":"uri"},"events_url":{"type":"string"},"followers_url":{"type":"string","format":"uri"},"following_url":{"type":"string"},"gists_url":{"type":"string"},"gravatar_id":{"type":"string","nullable":true},"html_url":{"type":"string","format":"uri"},"id":{"type":"integer"},"node_id":{"type":"string"},"login":{"type":"string"},"organizations_url":{"type":"string","format":"uri"},"received_events_url":{"type":"string","format":"uri"},"repos_url":{"type":"string","format":"uri"},"site_admin":{"type":"boolean"},"starred_url":{"type":"string"},"subscriptions_url":{"type":"string","format":"uri"},"type":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["avatar_url","events_url","followers_url","following_url","gists_url","gravatar_id","html_url","id","node_id","login","organizations_url","received_events_url","repos_url","site_admin","starred_url","subscriptions_url","type","url"]},"private":{"type":"boolean"},"pulls_url":{"type":"string"},"releases_url":{"type":"string"},"stargazers_url":{"type":"string","format":"uri"},"statuses_url":{"type":"string"},"subscribers_url":{"type":"string","format":"uri"},"subscription_url":{"type":"string","format":"uri"},"tags_url":{"type":"string","format":"uri"},"teams_url":{"type":"string","format":"uri"},"trees_url":{"type":"string"},"url":{"type":"string","format":"uri"},"clone_url":{"type":"string"},"default_branch":{"type":"string"},"forks":{"type":"integer"},"forks_count":{"type":"integer"},"git_url":{"type":"string"},"has_downloads":{"type":"boolean"},"has_issues":{"type":"boolean"},"has_projects":{"type":"boolean"},"has_wiki":{"type":"boolean"},"has_pages":{"type":"boolean"},"homepage":{"type":"string","format":"uri","nullable":true},"language":{"type":"string","nullable":true},"master_branch":{"type":"string"},"archived":{"type":"boolean"},"disabled":{"type":"boolean"},"mirror_url":{"type":"string","format":"uri","nullable":true},"open_issues":{"type":"integer"},"open_issues_count":{"type":"integer"},"permissions":{"type":"object","properties":{"admin":{"type":"boolean"},"pull":{"type":"boolean"},"push":{"type":"boolean"}},"required":["admin","pull","push"]},"temp_clone_token":{"type":"string"},"allow_merge_commit":{"type":"boolean"},"allow_squash_merge":{"type":"boolean"},"allow_rebase_merge":{"type":"boolean"},"license":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/license-simple"}]},"pushed_at":{"type":"string","format":"date-time"},"size":{"type":"integer"},"ssh_url":{"type":"string"},"stargazers_count":{"type":"integer"},"svn_url":{"type":"string","format":"uri"},"topics":{"type":"array","items":{"type":"string"}},"watchers":{"type":"integer"},"watchers_count":{"type":"integer"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"}},"required":["archive_url","assignees_url","blobs_url","branches_url","collaborators_url","comments_url","commits_url","compare_url","contents_url","contributors_url","deployments_url","description","downloads_url","events_url","fork","forks_url","full_name","git_commits_url","git_refs_url","git_tags_url","hooks_url","html_url","id","node_id","issue_comment_url","issue_events_url","issues_url","keys_url","labels_url","languages_url","merges_url","milestones_url","name","notifications_url","owner","private","pulls_url","releases_url","stargazers_url","statuses_url","subscribers_url","subscription_url","tags_url","teams_url","trees_url","url","clone_url","default_branch","forks","forks_count","git_url","has_downloads","has_issues","has_projects","has_wiki","has_pages","homepage","language","archived","disabled","mirror_url","open_issues","open_issues_count","license","pushed_at","size","ssh_url","stargazers_count","svn_url","watchers","watchers_count","created_at","updated_at"]},"sha":{"type":"string"},"user":{"type":"object","properties":{"avatar_url":{"type":"string","format":"uri"},"events_url":{"type":"string"},"followers_url":{"type":"string","format":"uri"},"following_url":{"type":"string"},"gists_url":{"type":"string"},"gravatar_id":{"type":"string","nullable":true},"html_url":{"type":"string","format":"uri"},"id":{"type":"integer"},"node_id":{"type":"string"},"login":{"type":"string"},"organizations_url":{"type":"string","format":"uri"},"received_events_url":{"type":"string","format":"uri"},"repos_url":{"type":"string","format":"uri"},"site_admin":{"type":"boolean"},"starred_url":{"type":"string"},"subscriptions_url":{"type":"string","format":"uri"},"type":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["avatar_url","events_url","followers_url","following_url","gists_url","gravatar_id","html_url","id","node_id","login","organizations_url","received_events_url","repos_url","site_admin","starred_url","subscriptions_url","type","url"]}},"required":["label","ref","repo","sha","user"]},"_links":{"type":"object","properties":{"comments":{"$ref":"#/components/schemas/link"},"commits":{"$ref":"#/components/schemas/link"},"statuses":{"$ref":"#/components/schemas/link"},"html":{"$ref":"#/components/schemas/link"},"issue":{"$ref":"#/components/schemas/link"},"review_comments":{"$ref":"#/components/schemas/link"},"review_comment":{"$ref":"#/components/schemas/link"},"self":{"$ref":"#/components/schemas/link"}},"required":["comments","commits","statuses","html","issue","review_comments","review_comment","self"]},"author_association":{"$ref":"#/components/schemas/author_association"},"auto_merge":{"$ref":"#/components/schemas/auto_merge"},"draft":{"description":"Indicates whether or not the pull request is a draft.","example":false,"type":"boolean"},"merged":{"type":"boolean"},"mergeable":{"type":"boolean","example":true,"nullable":true},"rebaseable":{"type":"boolean","example":true,"nullable":true},"mergeable_state":{"type":"string","example":"clean"},"merged_by":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"comments":{"type":"integer","example":10},"review_comments":{"type":"integer","example":0},"maintainer_can_modify":{"description":"Indicates whether maintainers can modify the pull request.","example":true,"type":"boolean"},"commits":{"type":"integer","example":3},"additions":{"type":"integer","example":100},"deletions":{"type":"integer","example":3},"changed_files":{"type":"integer","example":5}},"required":["_links","assignee","labels","base","body","closed_at","comments_url","commits_url","created_at","diff_url","head","html_url","id","node_id","issue_url","merge_commit_sha","merged_at","milestone","number","patch_url","review_comment_url","review_comments_url","statuses_url","state","locked","title","updated_at","url","user","author_association","auto_merge","additions","changed_files","comments","commits","deletions","mergeable","mergeable_state","merged","maintainer_can_modify","merged_by","review_comments"]},"pull-request-review-comment":{"title":"Pull Request Review Comment","description":"Pull Request Review Comments are comments on a portion of the Pull Request\'s diff.","type":"object","properties":{"url":{"description":"URL for the pull request review comment","example":"https://api.github.com/repos/octocat/Hello-World/pulls/comments/1","type":"string"},"pull_request_review_id":{"description":"The ID of the pull request review to which the comment belongs.","example":42,"type":"integer","nullable":true},"id":{"description":"The ID of the pull request review comment.","example":1,"type":"integer"},"node_id":{"description":"The node ID of the pull request review comment.","type":"string","example":"MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEw"},"diff_hunk":{"description":"The diff of the line that the comment refers to.","type":"string","example":"@@ -16,33 +16,40 @@ public class Connection : IConnection..."},"path":{"description":"The relative path of the file to which the comment applies.","example":"config/database.yaml","type":"string"},"position":{"description":"The line index in the diff to which the comment applies.","example":1,"type":"integer"},"original_position":{"description":"The index of the original line in the diff to which the comment applies.","example":4,"type":"integer"},"commit_id":{"description":"The SHA of the commit to which the comment applies.","example":"6dcb09b5b57875f334f61aebed695e2e4193db5e","type":"string"},"original_commit_id":{"description":"The SHA of the original commit to which the comment applies.","example":"9c48853fa3dc5c1c3d6f1f1cd1f2743e72652840","type":"string"},"in_reply_to_id":{"description":"The comment ID to reply to.","example":8,"type":"integer"},"user":{"$ref":"#/components/schemas/simple-user"},"body":{"description":"The text of the comment.","example":"We should probably include a check for null values here.","type":"string"},"created_at":{"type":"string","format":"date-time","example":"2011-04-14T16:00:49Z"},"updated_at":{"type":"string","format":"date-time","example":"2011-04-14T16:00:49Z"},"html_url":{"description":"HTML URL for the pull request review comment.","type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/pull/1#discussion-diff-1"},"pull_request_url":{"description":"URL for the pull request that the review comment belongs to.","type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/1"},"author_association":{"$ref":"#/components/schemas/author_association"},"_links":{"type":"object","properties":{"self":{"type":"object","properties":{"href":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/comments/1"}},"required":["href"]},"html":{"type":"object","properties":{"href":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/pull/1#discussion-diff-1"}},"required":["href"]},"pull_request":{"type":"object","properties":{"href":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/1"}},"required":["href"]}},"required":["self","html","pull_request"]},"start_line":{"type":"integer","description":"The first line of the range for a multi-line comment.","example":2,"nullable":true},"original_start_line":{"type":"integer","description":"The first line of the range for a multi-line comment.","example":2,"nullable":true},"start_side":{"type":"string","description":"The side of the first line of the range for a multi-line comment.","enum":["LEFT","RIGHT"],"default":"RIGHT","nullable":true},"line":{"description":"The line of the blob to which the comment applies. The last line of the range for a multi-line comment","example":2,"type":"integer"},"original_line":{"description":"The line of the blob to which the comment applies. The last line of the range for a multi-line comment","example":2,"type":"integer"},"side":{"description":"The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment","enum":["LEFT","RIGHT"],"default":"RIGHT","type":"string"},"reactions":{"$ref":"#/components/schemas/reaction-rollup"},"body_html":{"type":"string","example":"\\"<p>comment body</p>\\""},"body_text":{"type":"string","example":"\\"comment body\\""}},"required":["url","id","node_id","pull_request_review_id","diff_hunk","path","position","original_position","commit_id","original_commit_id","user","body","created_at","updated_at","html_url","pull_request_url","author_association","_links"]},"pull-request-merge-result":{"title":"Pull Request Merge Result","description":"Pull Request Merge Result","type":"object","properties":{"sha":{"type":"string"},"merged":{"type":"boolean"},"message":{"type":"string"}},"required":["merged","message","sha"]},"pull-request-review-request":{"title":"Pull Request Review Request","description":"Pull Request Review Request","type":"object","properties":{"users":{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}},"teams":{"type":"array","items":{"$ref":"#/components/schemas/team-simple"}}},"required":["users","teams"]},"pull-request-review":{"title":"Pull Request Review","description":"Pull Request Reviews are reviews on pull requests.","type":"object","properties":{"id":{"description":"Unique identifier of the review","example":42,"type":"integer"},"node_id":{"type":"string","example":"MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODA="},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"body":{"description":"The text of the review.","example":"This looks great.","type":"string"},"state":{"type":"string","example":"CHANGES_REQUESTED"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80"},"pull_request_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/12"},"_links":{"type":"object","properties":{"html":{"type":"object","properties":{"href":{"type":"string"}},"required":["href"]},"pull_request":{"type":"object","properties":{"href":{"type":"string"}},"required":["href"]}},"required":["html","pull_request"]},"submitted_at":{"type":"string","format":"date-time"},"commit_id":{"description":"A commit SHA for the review.","example":"54bb654c9e6025347f57900a4a5c2313a96b8035","type":"string"},"body_html":{"type":"string"},"body_text":{"type":"string"},"author_association":{"$ref":"#/components/schemas/author_association"}},"required":["id","node_id","user","body","state","commit_id","html_url","pull_request_url","_links","author_association"]},"review-comment":{"title":"Legacy Review Comment","description":"Legacy Review Comment","type":"object","properties":{"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/comments/1"},"pull_request_review_id":{"type":"integer","example":42,"nullable":true},"id":{"type":"integer","example":10},"node_id":{"type":"string","example":"MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEw"},"diff_hunk":{"type":"string","example":"@@ -16,33 +16,40 @@ public class Connection : IConnection..."},"path":{"type":"string","example":"file1.txt"},"position":{"type":"integer","example":1,"nullable":true},"original_position":{"type":"integer","example":4},"commit_id":{"type":"string","example":"6dcb09b5b57875f334f61aebed695e2e4193db5e"},"original_commit_id":{"type":"string","example":"9c48853fa3dc5c1c3d6f1f1cd1f2743e72652840"},"in_reply_to_id":{"type":"integer","example":8},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"body":{"type":"string","example":"Great stuff"},"created_at":{"type":"string","format":"date-time","example":"2011-04-14T16:00:49Z"},"updated_at":{"type":"string","format":"date-time","example":"2011-04-14T16:00:49Z"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/pull/1#discussion-diff-1"},"pull_request_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/Hello-World/pulls/1"},"author_association":{"$ref":"#/components/schemas/author_association"},"_links":{"type":"object","properties":{"self":{"$ref":"#/components/schemas/link"},"html":{"$ref":"#/components/schemas/link"},"pull_request":{"$ref":"#/components/schemas/link"}},"required":["self","html","pull_request"]},"body_text":{"type":"string"},"body_html":{"type":"string"},"side":{"description":"The side of the first line of the range for a multi-line comment.","enum":["LEFT","RIGHT"],"default":"RIGHT","type":"string"},"start_side":{"type":"string","description":"The side of the first line of the range for a multi-line comment.","enum":["LEFT","RIGHT"],"default":"RIGHT","nullable":true},"line":{"description":"The line of the blob to which the comment applies. The last line of the range for a multi-line comment","example":2,"type":"integer"},"original_line":{"description":"The original line of the blob to which the comment applies. The last line of the range for a multi-line comment","example":2,"type":"integer"},"start_line":{"description":"The first line of the range for a multi-line comment.","example":2,"type":"integer","nullable":true},"original_start_line":{"description":"The original first line of the range for a multi-line comment.","example":2,"type":"integer","nullable":true}},"required":["id","node_id","url","body","diff_hunk","path","position","original_position","commit_id","original_commit_id","user","pull_request_review_id","html_url","pull_request_url","_links","author_association","created_at","updated_at"]},"release-asset":{"title":"Release Asset","description":"Data related to a release.","type":"object","properties":{"url":{"type":"string","format":"uri"},"browser_download_url":{"type":"string","format":"uri"},"id":{"type":"integer"},"node_id":{"type":"string"},"name":{"description":"The file name of the asset.","type":"string","example":"Team Environment"},"label":{"type":"string","nullable":true},"state":{"description":"State of the release asset.","type":"string","enum":["uploaded","open"]},"content_type":{"type":"string"},"size":{"type":"integer"},"download_count":{"type":"integer"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"uploader":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]}},"required":["id","name","content_type","size","state","url","node_id","download_count","label","uploader","browser_download_url","created_at","updated_at"]},"release":{"title":"Release","description":"A release.","type":"object","properties":{"url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"assets_url":{"type":"string","format":"uri"},"upload_url":{"type":"string"},"tarball_url":{"type":"string","format":"uri","nullable":true},"zipball_url":{"type":"string","format":"uri","nullable":true},"id":{"type":"integer"},"node_id":{"type":"string"},"tag_name":{"description":"The name of the tag.","example":"v1.0.0","type":"string"},"target_commitish":{"description":"Specifies the commitish value that determines where the Git tag is created from.","example":"master","type":"string"},"name":{"type":"string","nullable":true},"body":{"type":"string","nullable":true},"draft":{"description":"true to create a draft (unpublished) release, false to create a published one.","example":false,"type":"boolean"},"prerelease":{"description":"Whether to identify the release as a prerelease or a full release.","example":false,"type":"boolean"},"created_at":{"type":"string","format":"date-time"},"published_at":{"type":"string","format":"date-time","nullable":true},"author":{"$ref":"#/components/schemas/simple-user"},"assets":{"type":"array","items":{"$ref":"#/components/schemas/release-asset"}},"body_html":{"type":"string"},"body_text":{"type":"string"}},"required":["assets_url","upload_url","tarball_url","zipball_url","created_at","published_at","draft","id","node_id","author","html_url","name","prerelease","tag_name","target_commitish","assets","url"]},"secret-scanning-alert-state":{"description":"Sets the state of the secret scanning alert. Can be either `open` or `resolved`. You must provide `resolution` when you set the state to `resolved`.","type":"string","enum":["open","resolved"]},"secret-scanning-alert-resolution":{"type":"string","description":"**Required when the `state` is `resolved`.** The reason for resolving the alert. Can be one of `false_positive`, `wont_fix`, `revoked`, or `used_in_tests`.","nullable":true,"oneOf":[{"enum":["false_positive","wont_fix","revoked","used_in_tests"]},{"enum":[null]}]},"secret-scanning-alert":{"type":"object","properties":{"number":{"$ref":"#/components/schemas/alert-number"},"created_at":{"$ref":"#/components/schemas/alert-created-at"},"url":{"$ref":"#/components/schemas/alert-url"},"html_url":{"$ref":"#/components/schemas/alert-html-url"},"state":{"$ref":"#/components/schemas/secret-scanning-alert-state"},"resolution":{"$ref":"#/components/schemas/secret-scanning-alert-resolution"},"resolved_at":{"type":"string","format":"date-time","description":"The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.","nullable":true},"resolved_by":{"$ref":"#/components/schemas/simple-user"},"secret_type":{"type":"string","description":"The type of secret that secret scanning detected."},"secret":{"type":"string","description":"The secret that was detected."}}},"stargazer":{"title":"Stargazer","description":"Stargazer","type":"object","properties":{"starred_at":{"type":"string","format":"date-time"},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]}},"required":["starred_at","user"]},"code-frequency-stat":{"title":"Code Frequency Stat","description":"Code Frequency Stat","type":"array","items":{"type":"integer"}},"commit-activity":{"title":"Commit Activity","description":"Commit Activity","type":"object","properties":{"days":{"type":"array","example":[0,3,26,20,39,1,0],"items":{"type":"integer"}},"total":{"type":"integer","example":89},"week":{"type":"integer","example":1336280400}},"required":["days","total","week"]},"contributor-activity":{"title":"Contributor Activity","description":"Contributor Activity","type":"object","properties":{"author":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"total":{"type":"integer","example":135},"weeks":{"type":"array","example":[{"w":"1367712000","a":6898,"d":77,"c":10}],"items":{"type":"object","properties":{"w":{"type":"string"},"a":{"type":"integer"},"d":{"type":"integer"},"c":{"type":"integer"}}}}},"required":["author","total","weeks"]},"participation-stats":{"title":"Participation Stats","type":"object","properties":{"all":{"type":"array","items":{"type":"integer"}},"owner":{"type":"array","items":{"type":"integer"}}},"required":["all","owner"]},"repository-subscription":{"title":"Repository Invitation","description":"Repository invitations let you manage who you collaborate with.","type":"object","properties":{"subscribed":{"description":"Determines if notifications should be received from this repository.","type":"boolean","example":true},"ignored":{"description":"Determines if all notifications should be blocked from this repository.","type":"boolean"},"reason":{"type":"string","nullable":true},"created_at":{"type":"string","format":"date-time","example":"2012-10-06T21:34:12Z"},"url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example/subscription"},"repository_url":{"type":"string","format":"uri","example":"https://api.github.com/repos/octocat/example"}},"required":["created_at","ignored","reason","subscribed","url","repository_url"]},"tag":{"title":"Tag","description":"Tag","type":"object","properties":{"name":{"type":"string","example":"v0.1"},"commit":{"type":"object","properties":{"sha":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["sha","url"]},"zipball_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/zipball/v0.1"},"tarball_url":{"type":"string","format":"uri","example":"https://github.com/octocat/Hello-World/tarball/v0.1"},"node_id":{"type":"string"}},"required":["name","node_id","commit","zipball_url","tarball_url"]},"topic":{"title":"Topic","description":"A topic aggregates entities that are related to a subject.","type":"object","properties":{"names":{"type":"array","items":{"type":"string"}}},"required":["names"]},"traffic":{"title":"Traffic","type":"object","properties":{"timestamp":{"type":"string","format":"date-time"},"uniques":{"type":"integer"},"count":{"type":"integer"}},"required":["timestamp","uniques","count"]},"clone-traffic":{"title":"Clone Traffic","description":"Clone Traffic","type":"object","properties":{"count":{"type":"integer","example":173},"uniques":{"type":"integer","example":128},"clones":{"type":"array","items":{"$ref":"#/components/schemas/traffic"}}},"required":["uniques","count","clones"]},"content-traffic":{"title":"Content Traffic","description":"Content Traffic","type":"object","properties":{"path":{"type":"string","example":"/github/hubot"},"title":{"type":"string","example":"github/hubot: A customizable life embetterment robot."},"count":{"type":"integer","example":3542},"uniques":{"type":"integer","example":2225}},"required":["path","title","uniques","count"]},"referrer-traffic":{"title":"Referrer Traffic","description":"Referrer Traffic","type":"object","properties":{"referrer":{"type":"string","example":"Google"},"count":{"type":"integer","example":4},"uniques":{"type":"integer","example":3}},"required":["referrer","uniques","count"]},"view-traffic":{"title":"View Traffic","description":"View Traffic","type":"object","properties":{"count":{"type":"integer","example":14850},"uniques":{"type":"integer","example":3782},"views":{"type":"array","items":{"$ref":"#/components/schemas/traffic"}}},"required":["uniques","count","views"]},"scim-group-list-enterprise":{"type":"object","properties":{"schemas":{"type":"array","items":{"type":"string"}},"totalResults":{"type":"number"},"itemsPerPage":{"type":"number"},"startIndex":{"type":"number"},"Resources":{"type":"array","items":{"type":"object","properties":{"schemas":{"type":"array","items":{"type":"string"}},"id":{"type":"string"},"externalId":{"type":"string","nullable":true},"displayName":{"type":"string"},"members":{"type":"array","items":{"type":"object","properties":{"value":{"type":"string"},"$ref":{"type":"string"},"display":{"type":"string"}}}},"meta":{"type":"object","properties":{"resourceType":{"type":"string"},"created":{"type":"string"},"lastModified":{"type":"string"},"location":{"type":"string"}}}},"required":["schemas","id"]}}},"required":["schemas","totalResults","itemsPerPage","startIndex","Resources"]},"scim-enterprise-group":{"type":"object","properties":{"schemas":{"type":"array","items":{"type":"string"}},"id":{"type":"string"},"externalId":{"type":"string","nullable":true},"displayName":{"type":"string"},"members":{"type":"array","items":{"type":"object","properties":{"value":{"type":"string"},"$ref":{"type":"string"},"display":{"type":"string"}}}},"meta":{"type":"object","properties":{"resourceType":{"type":"string"},"created":{"type":"string"},"lastModified":{"type":"string"},"location":{"type":"string"}}}},"required":["schemas","id"]},"scim-user-list-enterprise":{"type":"object","properties":{"schemas":{"type":"array","items":{"type":"string"}},"totalResults":{"type":"number"},"itemsPerPage":{"type":"number"},"startIndex":{"type":"number"},"Resources":{"type":"array","items":{"type":"object","properties":{"schemas":{"type":"array","items":{"type":"string"}},"id":{"type":"string"},"externalId":{"type":"string"},"userName":{"type":"string"},"name":{"type":"object","properties":{"givenName":{"type":"string"},"familyName":{"type":"string"}}},"emails":{"type":"array","items":{"type":"object","properties":{"value":{"type":"string"},"primary":{"type":"boolean"},"type":{"type":"string"}}}},"groups":{"type":"array","items":{"type":"object","properties":{"value":{"type":"string"}}}},"active":{"type":"boolean"},"meta":{"type":"object","properties":{"resourceType":{"type":"string"},"created":{"type":"string"},"lastModified":{"type":"string"},"location":{"type":"string"}}}},"required":["schemas","id"]}}},"required":["schemas","totalResults","itemsPerPage","startIndex","Resources"]},"scim-enterprise-user":{"type":"object","properties":{"schemas":{"type":"array","items":{"type":"string"}},"id":{"type":"string"},"externalId":{"type":"string"},"userName":{"type":"string"},"name":{"type":"object","properties":{"givenName":{"type":"string"},"familyName":{"type":"string"}}},"emails":{"type":"array","items":{"type":"object","properties":{"value":{"type":"string"},"type":{"type":"string"},"primary":{"type":"boolean"}}}},"groups":{"type":"array","items":{"type":"object","properties":{"value":{"type":"string"}}}},"active":{"type":"boolean"},"meta":{"type":"object","properties":{"resourceType":{"type":"string"},"created":{"type":"string"},"lastModified":{"type":"string"},"location":{"type":"string"}}}},"required":["schemas","id"]},"scim-user":{"title":"SCIM /Users","description":"SCIM /Users provisioning endpoints","type":"object","properties":{"schemas":{"description":"SCIM schema used.","type":"array","minItems":1,"items":{"type":"string","example":"urn:ietf:params:scim:schemas:core:2.0:User"}},"id":{"description":"Unique identifier of an external identity","example":"1b78eada-9baa-11e6-9eb6-a431576d590e","type":"string"},"externalId":{"description":"The ID of the User.","type":"string","example":"a7b0f98395","nullable":true},"userName":{"description":"Configured by the admin. Could be an email, login, or username","example":"someone@example.com","type":"string","nullable":true},"displayName":{"description":"The name of the user, suitable for display to end-users","example":"Jon Doe","type":"string","nullable":true},"name":{"type":"object","properties":{"givenName":{"type":"string","nullable":true},"familyName":{"type":"string","nullable":true},"formatted":{"type":"string","nullable":true}},"required":["givenName","familyName"],"example":{"givenName":"Jane","familyName":"User"}},"emails":{"description":"user emails","example":[{"value":"someone@example.com","primary":true},{"value":"another@example.com","primary":false}],"type":"array","minItems":1,"items":{"type":"object","properties":{"value":{"type":"string"},"primary":{"type":"boolean"}},"required":["value"]}},"active":{"description":"The active status of the User.","type":"boolean","example":true},"meta":{"type":"object","properties":{"resourceType":{"type":"string","example":"User"},"created":{"type":"string","format":"date-time","example":"2019-01-24T22:45:36.000Z"},"lastModified":{"type":"string","format":"date-time","example":"2019-01-24T22:45:36.000Z"},"location":{"type":"string","format":"uri","example":"https://api.github.com/scim/v2/organizations/myorg-123abc55141bfd8f/Users/c42772b5-2029-11e9-8543-9264a97dec8d"}}},"organization_id":{"description":"The ID of the organization.","type":"integer"},"operations":{"description":"Set of operations to be performed","example":[{"op":"replace","value":{"active":false}}],"type":"array","minItems":1,"items":{"properties":{"op":{"type":"string","enum":["add","remove","replace"]},"path":{"type":"string"},"value":{"oneOf":[{"type":"string"},{"type":"object"},{"type":"array","items":{}}]}},"required":["op"],"type":"object"}},"groups":{"description":"associated groups","type":"array","items":{"properties":{"value":{"type":"string"},"display":{"type":"string"}}}}},"required":["id","schemas","externalId","userName","name","emails","active","meta"]},"scim-user-list":{"title":"SCIM User List","description":"SCIM User List","type":"object","properties":{"schemas":{"description":"SCIM schema used.","type":"array","minItems":1,"items":{"type":"string","example":"urn:ietf:params:scim:api:messages:2.0:ListResponse"}},"totalResults":{"type":"integer","example":3},"itemsPerPage":{"type":"integer","example":10},"startIndex":{"type":"integer","example":1},"Resources":{"type":"array","items":{"$ref":"#/components/schemas/scim-user"}}},"required":["schemas","totalResults","itemsPerPage","startIndex","Resources"]},"search-result-text-matches":{"title":"Search Result Text Matches","type":"array","items":{"type":"object","properties":{"object_url":{"type":"string"},"object_type":{"nullable":true,"type":"string"},"property":{"type":"string"},"fragment":{"type":"string"},"matches":{"type":"array","items":{"type":"object","properties":{"text":{"type":"string"},"indices":{"type":"array","items":{"type":"integer"}}}}}}}},"code-search-result-item":{"title":"Code Search Result Item","description":"Code Search Result Item","type":"object","properties":{"name":{"type":"string"},"path":{"type":"string"},"sha":{"type":"string"},"url":{"type":"string","format":"uri"},"git_url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"repository":{"$ref":"#/components/schemas/minimal-repository"},"score":{"type":"integer"},"file_size":{"type":"integer"},"language":{"type":"string","nullable":true},"last_modified_at":{"type":"string","format":"date-time"},"line_numbers":{"type":"array","items":{"type":"string"},"example":["73..77","77..78"]},"text_matches":{"$ref":"#/components/schemas/search-result-text-matches"}},"required":["score","name","path","sha","git_url","html_url","url","repository"]},"commit-search-result-item":{"title":"Commit Search Result Item","description":"Commit Search Result Item","type":"object","properties":{"url":{"type":"string","format":"uri"},"sha":{"type":"string"},"html_url":{"type":"string","format":"uri"},"comments_url":{"type":"string","format":"uri"},"commit":{"type":"object","properties":{"author":{"type":"object","properties":{"name":{"type":"string"},"email":{"type":"string"},"date":{"type":"string","format":"date-time"}},"required":["name","email","date"]},"committer":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/git-user"}]},"comment_count":{"type":"integer"},"message":{"type":"string"},"tree":{"type":"object","properties":{"sha":{"type":"string"},"url":{"type":"string","format":"uri"}},"required":["sha","url"]},"url":{"type":"string","format":"uri"},"verification":{"$ref":"#/components/schemas/verification"}},"required":["author","committer","comment_count","message","tree","url"]},"author":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"committer":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/git-user"}]},"parents":{"type":"array","items":{"type":"object","properties":{"url":{"type":"string"},"html_url":{"type":"string"},"sha":{"type":"string"}}}},"repository":{"$ref":"#/components/schemas/minimal-repository"},"score":{"type":"integer"},"node_id":{"type":"string"},"text_matches":{"$ref":"#/components/schemas/search-result-text-matches"}},"required":["sha","node_id","url","html_url","author","committer","parents","comments_url","commit","repository","score"]},"issue-search-result-item":{"title":"Issue Search Result Item","description":"Issue Search Result Item","type":"object","properties":{"url":{"type":"string","format":"uri"},"repository_url":{"type":"string","format":"uri"},"labels_url":{"type":"string"},"comments_url":{"type":"string","format":"uri"},"events_url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"id":{"type":"integer"},"node_id":{"type":"string"},"number":{"type":"integer"},"title":{"type":"string"},"locked":{"type":"boolean"},"active_lock_reason":{"type":"string","nullable":true},"assignees":{"type":"array","items":{"$ref":"#/components/schemas/simple-user"},"nullable":true},"user":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"labels":{"type":"array","items":{"type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"url":{"type":"string"},"name":{"type":"string"},"color":{"type":"string"},"default":{"type":"boolean"},"description":{"type":"string","nullable":true}}}},"state":{"type":"string"},"assignee":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"milestone":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/milestone"}]},"comments":{"type":"integer"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"closed_at":{"type":"string","format":"date-time","nullable":true},"text_matches":{"$ref":"#/components/schemas/search-result-text-matches"},"pull_request":{"type":"object","properties":{"merged_at":{"type":"string","format":"date-time","nullable":true},"diff_url":{"type":"string","format":"uri","nullable":true},"html_url":{"type":"string","format":"uri","nullable":true},"patch_url":{"type":"string","format":"uri","nullable":true},"url":{"type":"string","format":"uri","nullable":true}},"required":["diff_url","html_url","patch_url","url"]},"body":{"type":"string"},"score":{"type":"integer"},"author_association":{"$ref":"#/components/schemas/author_association"},"draft":{"type":"boolean"},"repository":{"$ref":"#/components/schemas/repository"},"body_html":{"type":"string"},"body_text":{"type":"string"},"timeline_url":{"type":"string","format":"uri"},"performed_via_github_app":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/integration"}]}},"required":["assignee","closed_at","comments","comments_url","events_url","html_url","id","node_id","labels","labels_url","milestone","number","repository_url","state","locked","title","url","user","author_association","created_at","updated_at","score"]},"label-search-result-item":{"title":"Label Search Result Item","description":"Label Search Result Item","type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"url":{"type":"string","format":"uri"},"name":{"type":"string"},"color":{"type":"string"},"default":{"type":"boolean"},"description":{"type":"string","nullable":true},"score":{"type":"integer"},"text_matches":{"$ref":"#/components/schemas/search-result-text-matches"}},"required":["id","node_id","url","name","color","default","description","score"]},"repo-search-result-item":{"title":"Repo Search Result Item","description":"Repo Search Result Item","type":"object","properties":{"id":{"type":"integer"},"node_id":{"type":"string"},"name":{"type":"string"},"full_name":{"type":"string"},"owner":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/simple-user"}]},"private":{"type":"boolean"},"html_url":{"type":"string","format":"uri"},"description":{"type":"string","nullable":true},"fork":{"type":"boolean"},"url":{"type":"string","format":"uri"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"pushed_at":{"type":"string","format":"date-time"},"homepage":{"type":"string","format":"uri","nullable":true},"size":{"type":"integer"},"stargazers_count":{"type":"integer"},"watchers_count":{"type":"integer"},"language":{"type":"string","nullable":true},"forks_count":{"type":"integer"},"open_issues_count":{"type":"integer"},"master_branch":{"type":"string"},"default_branch":{"type":"string"},"score":{"type":"integer"},"forks_url":{"type":"string","format":"uri"},"keys_url":{"type":"string"},"collaborators_url":{"type":"string"},"teams_url":{"type":"string","format":"uri"},"hooks_url":{"type":"string","format":"uri"},"issue_events_url":{"type":"string"},"events_url":{"type":"string","format":"uri"},"assignees_url":{"type":"string"},"branches_url":{"type":"string"},"tags_url":{"type":"string","format":"uri"},"blobs_url":{"type":"string"},"git_tags_url":{"type":"string"},"git_refs_url":{"type":"string"},"trees_url":{"type":"string"},"statuses_url":{"type":"string"},"languages_url":{"type":"string","format":"uri"},"stargazers_url":{"type":"string","format":"uri"},"contributors_url":{"type":"string","format":"uri"},"subscribers_url":{"type":"string","format":"uri"},"subscription_url":{"type":"string","format":"uri"},"commits_url":{"type":"string"},"git_commits_url":{"type":"string"},"comments_url":{"type":"string"},"issue_comment_url":{"type":"string"},"contents_url":{"type":"string"},"compare_url":{"type":"string"},"merges_url":{"type":"string","format":"uri"},"archive_url":{"type":"string"},"downloads_url":{"type":"string","format":"uri"},"issues_url":{"type":"string"},"pulls_url":{"type":"string"},"milestones_url":{"type":"string"},"notifications_url":{"type":"string"},"labels_url":{"type":"string"},"releases_url":{"type":"string"},"deployments_url":{"type":"string","format":"uri"},"git_url":{"type":"string"},"ssh_url":{"type":"string"},"clone_url":{"type":"string"},"svn_url":{"type":"string","format":"uri"},"forks":{"type":"integer"},"open_issues":{"type":"integer"},"watchers":{"type":"integer"},"topics":{"type":"array","items":{"type":"string"}},"mirror_url":{"type":"string","format":"uri","nullable":true},"has_issues":{"type":"boolean"},"has_projects":{"type":"boolean"},"has_pages":{"type":"boolean"},"has_wiki":{"type":"boolean"},"has_downloads":{"type":"boolean"},"archived":{"type":"boolean"},"disabled":{"type":"boolean","description":"Returns whether or not this repository disabled."},"license":{"nullable":true,"allOf":[{"$ref":"#/components/schemas/license-simple"}]},"permissions":{"type":"object","properties":{"admin":{"type":"boolean"},"pull":{"type":"boolean"},"push":{"type":"boolean"}},"required":["admin","pull","push"]},"text_matches":{"$ref":"#/components/schemas/search-result-text-matches"},"temp_clone_token":{"type":"string"},"allow_merge_commit":{"type":"boolean"},"allow_squash_merge":{"type":"boolean"},"allow_rebase_merge":{"type":"boolean"},"delete_branch_on_merge":{"type":"boolean"}},"required":["archive_url","assignees_url","blobs_url","branches_url","collaborators_url","comments_url","commits_url","compare_url","contents_url","contributors_url","deployments_url","description","downloads_url","events_url","fork","forks_url","full_name","git_commits_url","git_refs_url","git_tags_url","hooks_url","html_url","id","node_id","issue_comment_url","issue_events_url","issues_url","keys_url","labels_url","languages_url","merges_url","milestones_url","name","notifications_url","owner","private","pulls_url","releases_url","stargazers_url","statuses_url","subscribers_url","subscription_url","tags_url","teams_url","trees_url","url","clone_url","default_branch","forks","forks_count","git_url","has_downloads","has_issues","has_projects","has_wiki","has_pages","homepage","language","archived","disabled","mirror_url","open_issues","open_issues_count","license","pushed_at","size","ssh_url","stargazers_count","svn_url","watchers","watchers_count","created_at","updated_at","score"]},"topic-search-result-item":{"title":"Topic Search Result Item","description":"Topic Search Result Item","type":"object","properties":{"name":{"type":"string"},"display_name":{"type":"string","nullable":true},"short_description":{"type":"string","nullable":true},"description":{"type":"string","nullable":true},"created_by":{"type":"string","nullable":true},"released":{"type":"string","nullable":true},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"featured":{"type":"boolean"},"curated":{"type":"boolean"},"score":{"type":"integer"},"repository_count":{"type":"integer","nullable":true},"logo_url":{"type":"string","format":"uri","nullable":true},"text_matches":{"$ref":"#/components/schemas/search-result-text-matches"},"related":{"type":"array","nullable":true,"items":{"type":"object","properties":{"topic_relation":{"type":"object","properties":{"id":{"type":"integer"},"name":{"type":"string"},"topic_id":{"type":"integer"},"relation_type":{"type":"string"}}}}}},"aliases":{"type":"array","nullable":true,"items":{"type":"object","properties":{"topic_relation":{"type":"object","properties":{"id":{"type":"integer"},"name":{"type":"string"},"topic_id":{"type":"integer"},"relation_type":{"type":"string"}}}}}}},"required":["name","display_name","short_description","description","created_by","released","created_at","updated_at","featured","curated","score"]},"user-search-result-item":{"title":"User Search Result Item","description":"User Search Result Item","type":"object","properties":{"login":{"type":"string"},"id":{"type":"integer"},"node_id":{"type":"string"},"avatar_url":{"type":"string","format":"uri"},"gravatar_id":{"type":"string","nullable":true},"url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"followers_url":{"type":"string","format":"uri"},"subscriptions_url":{"type":"string","format":"uri"},"organizations_url":{"type":"string","format":"uri"},"repos_url":{"type":"string","format":"uri"},"received_events_url":{"type":"string","format":"uri"},"type":{"type":"string"},"score":{"type":"integer"},"following_url":{"type":"string"},"gists_url":{"type":"string"},"starred_url":{"type":"string"},"events_url":{"type":"string"},"public_repos":{"type":"integer"},"public_gists":{"type":"integer"},"followers":{"type":"integer"},"following":{"type":"integer"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"name":{"type":"string","nullable":true},"bio":{"type":"string","nullable":true},"email":{"type":"string","format":"email","nullable":true},"location":{"type":"string","nullable":true},"site_admin":{"type":"boolean"},"hireable":{"type":"boolean","nullable":true},"text_matches":{"$ref":"#/components/schemas/search-result-text-matches"},"blog":{"type":"string","nullable":true},"company":{"type":"string","nullable":true},"suspended_at":{"type":"string","format":"date-time","nullable":true}},"required":["avatar_url","events_url","followers_url","following_url","gists_url","gravatar_id","html_url","id","node_id","login","organizations_url","received_events_url","repos_url","site_admin","starred_url","subscriptions_url","type","url","score"]},"private-user":{"title":"Private User","description":"Private User","type":"object","properties":{"login":{"type":"string","example":"octocat"},"id":{"type":"integer","example":1},"node_id":{"type":"string","example":"MDQ6VXNlcjE="},"avatar_url":{"type":"string","format":"uri","example":"https://github.com/images/error/octocat_happy.gif"},"gravatar_id":{"type":"string","example":"41d064eb2195891e12d0413f63227ea7","nullable":true},"url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat"},"html_url":{"type":"string","format":"uri","example":"https://github.com/octocat"},"followers_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/followers"},"following_url":{"type":"string","example":"https://api.github.com/users/octocat/following{/other_user}"},"gists_url":{"type":"string","example":"https://api.github.com/users/octocat/gists{/gist_id}"},"starred_url":{"type":"string","example":"https://api.github.com/users/octocat/starred{/owner}{/repo}"},"subscriptions_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/subscriptions"},"organizations_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/orgs"},"repos_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/repos"},"events_url":{"type":"string","example":"https://api.github.com/users/octocat/events{/privacy}"},"received_events_url":{"type":"string","format":"uri","example":"https://api.github.com/users/octocat/received_events"},"type":{"type":"string","example":"User"},"site_admin":{"type":"boolean"},"name":{"type":"string","example":"monalisa octocat","nullable":true},"company":{"type":"string","example":"GitHub","nullable":true},"blog":{"type":"string","example":"https://github.com/blog","nullable":true},"location":{"type":"string","example":"San Francisco","nullable":true},"email":{"type":"string","format":"email","example":"octocat@github.com","nullable":true},"hireable":{"type":"boolean","nullable":true},"bio":{"type":"string","example":"There once was...","nullable":true},"twitter_username":{"type":"string","example":"monalisa","nullable":true},"public_repos":{"type":"integer","example":2},"public_gists":{"type":"integer","example":1},"followers":{"type":"integer","example":20},"following":{"type":"integer","example":0},"created_at":{"type":"string","format":"date-time","example":"2008-01-14T04:33:35Z"},"updated_at":{"type":"string","format":"date-time","example":"2008-01-14T04:33:35Z"},"private_gists":{"type":"integer","example":81},"total_private_repos":{"type":"integer","example":100},"owned_private_repos":{"type":"integer","example":100},"disk_usage":{"type":"integer","example":10000},"collaborators":{"type":"integer","example":8},"two_factor_authentication":{"type":"boolean","example":true},"plan":{"type":"object","properties":{"collaborators":{"type":"integer"},"name":{"type":"string"},"space":{"type":"integer"},"private_repos":{"type":"integer"}},"required":["collaborators","name","space","private_repos"]},"suspended_at":{"type":"string","format":"date-time","nullable":true},"business_plus":{"type":"boolean"},"ldap_dn":{"type":"string"}},"required":["avatar_url","events_url","followers_url","following_url","gists_url","gravatar_id","html_url","id","node_id","login","organizations_url","received_events_url","repos_url","site_admin","starred_url","subscriptions_url","type","url","bio","blog","company","email","followers","following","hireable","location","name","public_gists","public_repos","created_at","updated_at","collaborators","disk_usage","owned_private_repos","private_gists","total_private_repos","two_factor_authentication"]},"public-user":{"title":"Public User","description":"Public User","type":"object","properties":{"login":{"type":"string"},"id":{"type":"integer"},"node_id":{"type":"string"},"avatar_url":{"type":"string","format":"uri"},"gravatar_id":{"type":"string","nullable":true},"url":{"type":"string","format":"uri"},"html_url":{"type":"string","format":"uri"},"followers_url":{"type":"string","format":"uri"},"following_url":{"type":"string"},"gists_url":{"type":"string"},"starred_url":{"type":"string"},"subscriptions_url":{"type":"string","format":"uri"},"organizations_url":{"type":"string","format":"uri"},"repos_url":{"type":"string","format":"uri"},"events_url":{"type":"string"},"received_events_url":{"type":"string","format":"uri"},"type":{"type":"string"},"site_admin":{"type":"boolean"},"name":{"type":"string","nullable":true},"company":{"type":"string","nullable":true},"blog":{"type":"string","nullable":true},"location":{"type":"string","nullable":true},"email":{"type":"string","format":"email","nullable":true},"hireable":{"type":"boolean","nullable":true},"bio":{"type":"string","nullable":true},"twitter_username":{"type":"string","nullable":true},"public_repos":{"type":"integer"},"public_gists":{"type":"integer"},"followers":{"type":"integer"},"following":{"type":"integer"},"created_at":{"type":"string","format":"date-time"},"updated_at":{"type":"string","format":"date-time"},"plan":{"type":"object","properties":{"collaborators":{"type":"integer"},"name":{"type":"string"},"space":{"type":"integer"},"private_repos":{"type":"integer"}},"required":["collaborators","name","space","private_repos"]},"suspended_at":{"type":"string","format":"date-time","nullable":true},"private_gists":{"type":"integer","example":1},"total_private_repos":{"type":"integer","example":2},"owned_private_repos":{"type":"integer","example":2},"disk_usage":{"type":"integer","example":1},"collaborators":{"type":"integer","example":3}},"required":["avatar_url","events_url","followers_url","following_url","gists_url","gravatar_id","html_url","id","node_id","login","organizations_url","received_events_url","repos_url","site_admin","starred_url","subscriptions_url","type","url","bio","blog","company","email","followers","following","hireable","location","name","public_gists","public_repos","created_at","updated_at"],"additionalProperties":false},"email":{"title":"Email","description":"Email","type":"object","properties":{"email":{"type":"string","format":"email","example":"octocat@github.com"},"primary":{"type":"boolean","example":true},"verified":{"type":"boolean","example":true},"visibility":{"type":"string","example":"public","nullable":true}},"required":["email","primary","verified","visibility"]},"gpg-key":{"title":"GPG Key","description":"A unique encryption key","type":"object","properties":{"id":{"type":"integer","example":3},"primary_key_id":{"type":"integer","nullable":true},"key_id":{"type":"string","example":"3262EFF25BA0D270"},"public_key":{"type":"string","example":"xsBNBFayYZ..."},"emails":{"type":"array","example":[{"email":"mastahyeti@users.noreply.github.com","verified":true}],"items":{"type":"object","properties":{"email":{"type":"string"},"verified":{"type":"boolean"}}}},"subkeys":{"type":"array","example":[{"id":4,"primary_key_id":3,"key_id":"4A595D4C72EE49C7","public_key":"zsBNBFayYZ...","emails":[],"subkeys":[],"can_sign":false,"can_encrypt_comms":true,"can_encrypt_storage":true,"can_certify":false,"created_at":"2016-03-24T11:31:04-06:00","expires_at":null}],"items":{"type":"object","properties":{"id":{"type":"integer"},"primary_key_id":{"type":"integer"},"key_id":{"type":"string"},"public_key":{"type":"string"},"emails":{"type":"array","items":{}},"subkeys":{"type":"array","items":{}},"can_sign":{"type":"boolean"},"can_encrypt_comms":{"type":"boolean"},"can_encrypt_storage":{"type":"boolean"},"can_certify":{"type":"boolean"},"created_at":{"type":"string"},"expires_at":{"type":"string","nullable":true},"raw_key":{"type":"string","nullable":true}}}},"can_sign":{"type":"boolean","example":true},"can_encrypt_comms":{"type":"boolean"},"can_encrypt_storage":{"type":"boolean"},"can_certify":{"type":"boolean","example":true},"created_at":{"type":"string","format":"date-time","example":"2016-03-24T11:31:04-06:00"},"expires_at":{"type":"string","format":"date-time","nullable":true},"raw_key":{"type":"string","nullable":true}},"required":["id","primary_key_id","key_id","raw_key","public_key","created_at","expires_at","can_sign","can_encrypt_comms","can_encrypt_storage","can_certify","emails","subkeys"]},"key":{"title":"Key","description":"Key","type":"object","properties":{"key_id":{"type":"string"},"key":{"type":"string"},"id":{"type":"integer"},"url":{"type":"string"},"title":{"type":"string"},"created_at":{"type":"string","format":"date-time"},"verified":{"type":"boolean"},"read_only":{"type":"boolean"}},"required":["key_id","key","id","url","title","created_at","verified","read_only"]},"marketplace-account":{"title":"Marketplace Account","type":"object","properties":{"url":{"type":"string","format":"uri"},"id":{"type":"integer"},"type":{"type":"string"},"node_id":{"type":"string"},"login":{"type":"string"},"email":{"type":"string","nullable":true,"format":"email"},"organization_billing_email":{"type":"string","nullable":true,"format":"email"}},"required":["url","id","type","login"]},"user-marketplace-purchase":{"title":"User Marketplace Purchase","description":"User Marketplace Purchase","type":"object","properties":{"billing_cycle":{"type":"string","example":"monthly"},"next_billing_date":{"type":"string","format":"date-time","example":"2017-11-11T00:00:00Z","nullable":true},"unit_count":{"type":"integer","nullable":true},"on_free_trial":{"type":"boolean","example":true},"free_trial_ends_on":{"type":"string","format":"date-time","example":"2017-11-11T00:00:00Z","nullable":true},"updated_at":{"type":"string","format":"date-time","example":"2017-11-02T01:12:12Z","nullable":true},"account":{"$ref":"#/components/schemas/marketplace-account"},"plan":{"$ref":"#/components/schemas/marketplace-listing-plan"}},"required":["billing_cycle","next_billing_date","unit_count","updated_at","on_free_trial","free_trial_ends_on","account","plan"]},"starred-repository":{"title":"Starred Repository","description":"Starred Repository","type":"object","properties":{"starred_at":{"type":"string","format":"date-time"},"repo":{"$ref":"#/components/schemas/repository"}},"required":["starred_at","repo"]},"hovercard":{"title":"Hovercard","description":"Hovercard","type":"object","properties":{"contexts":{"type":"array","items":{"type":"object","properties":{"message":{"type":"string"},"octicon":{"type":"string"}},"required":["message","octicon"]}}},"required":["contexts"]},"key-simple":{"title":"Key Simple","description":"Key Simple","type":"object","properties":{"id":{"type":"integer"},"key":{"type":"string"}},"required":["key","id"]}}',
      ),
    ),
  ) {}
  async metaRoot(params: {}): Promise<{
    current_user_url: string;
    current_user_authorizations_html_url: string;
    authorizations_url: string;
    code_search_url: string;
    commit_search_url: string;
    emails_url: string;
    emojis_url: string;
    events_url: string;
    feeds_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    hub_url: string;
    issue_search_url: string;
    issues_url: string;
    keys_url: string;
    label_search_url: string;
    notifications_url: string;
    organization_url: string;
    organization_repositories_url: string;
    organization_teams_url: string;
    public_gists_url: string;
    rate_limit_url: string;
    repository_url: string;
    repository_search_url: string;
    current_user_repositories_url: string;
    starred_url: string;
    starred_gists_url: string;
    topic_search_url?: string;
    user_url: string;
    user_organizations_url: string;
    user_repositories_url: string;
    user_search_url: string;
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{"current_user_url":{"type":"string","format":"uri"},"current_user_authorizations_html_url":{"type":"string","format":"uri"},"authorizations_url":{"type":"string","format":"uri"},"code_search_url":{"type":"string","format":"uri"},"commit_search_url":{"type":"string","format":"uri"},"emails_url":{"type":"string","format":"uri"},"emojis_url":{"type":"string","format":"uri"},"events_url":{"type":"string","format":"uri"},"feeds_url":{"type":"string","format":"uri"},"followers_url":{"type":"string","format":"uri"},"following_url":{"type":"string","format":"uri"},"gists_url":{"type":"string","format":"uri"},"hub_url":{"type":"string","format":"uri"},"issue_search_url":{"type":"string","format":"uri"},"issues_url":{"type":"string","format":"uri"},"keys_url":{"type":"string","format":"uri"},"label_search_url":{"type":"string","format":"uri"},"notifications_url":{"type":"string","format":"uri"},"organization_url":{"type":"string","format":"uri"},"organization_repositories_url":{"type":"string","format":"uri"},"organization_teams_url":{"type":"string","format":"uri"},"public_gists_url":{"type":"string","format":"uri"},"rate_limit_url":{"type":"string","format":"uri"},"repository_url":{"type":"string","format":"uri"},"repository_search_url":{"type":"string","format":"uri"},"current_user_repositories_url":{"type":"string","format":"uri"},"starred_url":{"type":"string","format":"uri"},"starred_gists_url":{"type":"string","format":"uri"},"topic_search_url":{"type":"string","format":"uri"},"user_url":{"type":"string","format":"uri"},"user_organizations_url":{"type":"string","format":"uri"},"user_repositories_url":{"type":"string","format":"uri"},"user_search_url":{"type":"string","format":"uri"}},"required":["current_user_url","current_user_authorizations_html_url","authorizations_url","code_search_url","commit_search_url","emails_url","emojis_url","events_url","feeds_url","followers_url","following_url","gists_url","hub_url","issue_search_url","issues_url","keys_url","label_search_url","notifications_url","organization_url","organization_repositories_url","organization_teams_url","public_gists_url","rate_limit_url","repository_url","repository_search_url","current_user_repositories_url","starred_url","starred_gists_url","user_url","user_organizations_url","user_repositories_url","user_search_url"]}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsGetAuthenticated(params: {}): Promise<Integration> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/app', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/integration"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsCreateFromManifest(params: { code: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/app-manifests/{code}/conversions', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"allOf":[{"$ref":"#/components/schemas/integration"},{"type":"object","properties":{"client_id":{"type":"string"},"client_secret":{"type":"string"},"webhook_secret":{"type":"string"},"pem":{"type":"string"}},"required":["client_id","client_secret","webhook_secret","pem"],"additionalProperties":true}]}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsGetWebhookConfigForApp(params: {}): Promise<WebhookConfig> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/app/hook/config', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/webhook-config"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsUpdateWebhookConfigForApp(
    params: {},
    body: {
      url?: WebhookConfigUrl;
      content_type?: WebhookConfigContentType;
      secret?: WebhookConfigSecret;
      insecure_ssl?: WebhookConfigInsecureSsl;
    },
  ): Promise<WebhookConfig> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/app/hook/config', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/webhook-config"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsListInstallations(params: {
    per_page?: number;
    page?: number;
    since?: string;
    outdated?: string;
  }): Promise<Installation[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/app/installations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.outdated !== undefined)
      requestContext.setQueryParam(
        'outdated',
        r.serializeParameter(params.outdated),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/installation"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsGetInstallation(params: {
    installation_id: number;
  }): Promise<Installation> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/app/installations/{installation_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/installation"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsDeleteInstallation(params: {
    installation_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/app/installations/{installation_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsCreateInstallationAccessToken(
    params: {
      installation_id: number;
    },
    body: {
      repositories?: string[];
      repository_ids?: number[];
      permissions?: AppPermissions;
    },
  ): Promise<InstallationToken> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/app/installations/{installation_id}/access_tokens',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/installation-token"}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsSuspendInstallation(params: {
    installation_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/app/installations/{installation_id}/suspended',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsUnsuspendInstallation(params: {
    installation_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/app/installations/{installation_id}/suspended',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async oauthAuthorizationsListGrants(params: {
    per_page?: number;
    page?: number;
    client_id?: string;
  }): Promise<ApplicationGrant[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/applications/grants', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.client_id !== undefined)
      requestContext.setQueryParam(
        'client_id',
        r.serializeParameter(params.client_id),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/application-grant"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async oauthAuthorizationsGetGrant(params: {
    grant_id: number;
  }): Promise<ApplicationGrant> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/applications/grants/{grant_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/application-grant"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async oauthAuthorizationsDeleteGrant(params: {
    grant_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/applications/grants/{grant_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsDeleteAuthorization(
    params: {
      client_id: string;
    },
    body: {
      access_token?: string;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/applications/{client_id}/grant', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsRevokeGrantForApplication(params: {
    client_id: string;
    access_token: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/applications/{client_id}/grants/{access_token}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsCheckToken(
    params: {
      client_id: string;
    },
    body: {
      access_token: string;
    },
  ): Promise<Authorization> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/applications/{client_id}/token', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsResetToken(
    params: {
      client_id: string;
    },
    body: {
      access_token: string;
    },
  ): Promise<Authorization> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/applications/{client_id}/token', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsDeleteToken(
    params: {
      client_id: string;
    },
    body: {
      access_token: string;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/applications/{client_id}/token', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsScopeToken(
    params: {
      client_id: string;
    },
    body: {
      access_token: string;
      target?: string;
      target_id?: number;
      repositories?: string[];
      repository_ids?: number[];
      permissions?: AppPermissions;
    },
  ): Promise<Authorization> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/applications/{client_id}/token/scoped', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsCheckAuthorization(params: {
    client_id: string;
    access_token: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/applications/{client_id}/tokens/{access_token}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"nullable":true,"allOf":[{"$ref":"#/components/schemas/authorization"}]}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsResetAuthorization(params: {
    client_id: string;
    access_token: string;
  }): Promise<Authorization> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/applications/{client_id}/tokens/{access_token}',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsRevokeAuthorizationForApplication(params: {
    client_id: string;
    access_token: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/applications/{client_id}/tokens/{access_token}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsGetBySlug(params: { app_slug: string }): Promise<Integration> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/apps/{app_slug}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/integration"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async oauthAuthorizationsListAuthorizations(params: {
    per_page?: number;
    page?: number;
    client_id?: string;
  }): Promise<Authorization[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/authorizations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.client_id !== undefined)
      requestContext.setQueryParam(
        'client_id',
        r.serializeParameter(params.client_id),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/authorization"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async oauthAuthorizationsCreateAuthorization(
    params: {},
    body: {
      scopes?: string[] | null;
      note?: string;
      note_url?: string;
      client_id?: string;
      client_secret?: string;
      fingerprint?: string;
    },
  ): Promise<Authorization> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/authorizations', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async oauthAuthorizationsGetOrCreateAuthorizationForApp(
    params: {
      client_id: string;
    },
    body: {
      client_secret: string;
      scopes?: string[] | null;
      note?: string;
      note_url?: string;
      fingerprint?: string;
    },
  ): Promise<Authorization> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/authorizations/clients/{client_id}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
        this.resolver,
      );
    if (r.isCodeInRange('201', response.httpStatusCode))
      throw new r.ApiException<Authorization>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async oauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(
    params: {
      client_id: string;
      fingerprint: string;
    },
    body: {
      client_secret: string;
      scopes?: string[] | null;
      note?: string;
      note_url?: string;
    },
  ): Promise<Authorization> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/authorizations/clients/{client_id}/{fingerprint}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
        this.resolver,
      );
    if (r.isCodeInRange('201', response.httpStatusCode))
      throw new r.ApiException<Authorization>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async oauthAuthorizationsGetAuthorization(params: {
    authorization_id: number;
  }): Promise<Authorization> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/authorizations/{authorization_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async oauthAuthorizationsUpdateAuthorization(
    params: {
      authorization_id: number;
    },
    body: {
      scopes?: string[] | null;
      add_scopes?: string[];
      remove_scopes?: string[];
      note?: string;
      note_url?: string;
      fingerprint?: string;
    },
  ): Promise<Authorization> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/authorizations/{authorization_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authorization"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async oauthAuthorizationsDeleteAuthorization(params: {
    authorization_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/authorizations/{authorization_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codesOfConductGetAllCodesOfConduct(params: {}): Promise<
    CodeOfConduct[]
  > {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/codes_of_conduct', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/code-of-conduct"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codesOfConductGetConductCode(params: {
    key: string;
  }): Promise<CodeOfConduct> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/codes_of_conduct/{key}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/code-of-conduct"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsCreateContentAttachment(
    params: {
      content_reference_id: number;
    },
    body: {
      title: string;
      body: string;
    },
  ): Promise<ContentReferenceAttachment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/content_references/{content_reference_id}/attachments',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/content-reference-attachment"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async emojisGet(params: {}): Promise<{
    [key: string]: string;
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/emojis', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","additionalProperties":{"type":"string"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminGetGithubActionsPermissionsEnterprise(params: {
    enterprise: string;
  }): Promise<ActionsEnterprisePermissions> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/permissions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/actions-enterprise-permissions"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminSetGithubActionsPermissionsEnterprise(
    params: {
      enterprise: string;
    },
    body: {
      enabled_organizations: EnabledOrganizations;
      allowed_actions?: AllowedActions;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/permissions',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(params: {
    enterprise: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    organizations: OrganizationSimple[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/permissions/organizations',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{"total_count":{"type":"number"},"organizations":{"type":"array","items":{"$ref":"#/components/schemas/organization-simple"}}},"required":["total_count","organizations"]}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(
    params: {
      enterprise: string;
    },
    body: {
      selected_organization_ids: number[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/permissions/organizations',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(params: {
    enterprise: string;
    org_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/permissions/organizations/{org_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(params: {
    enterprise: string;
    org_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/permissions/organizations/{org_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminGetAllowedActionsEnterprise(params: {
    enterprise: string;
  }): Promise<SelectedActions> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/permissions/selected-actions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/selected-actions"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminSetAllowedActionsEnterprise(
    params: {
      enterprise: string;
    },
    body: SelectedActions,
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/permissions/selected-actions',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminListSelfHostedRunnerGroupsForEnterprise(params: {
    enterprise: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    runner_groups: RunnerGroupsEnterprise[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{"total_count":{"type":"number"},"runner_groups":{"type":"array","items":{"$ref":"#/components/schemas/runner-groups-enterprise"}}},"required":["total_count","runner_groups"]}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(
    params: {
      enterprise: string;
    },
    body: {
      name: string;
      visibility?: 'selected' | 'all';
      selected_organization_ids?: number[];
      runners?: number[];
    },
  ): Promise<RunnerGroupsEnterprise> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/runner-groups-enterprise"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminGetSelfHostedRunnerGroupForEnterprise(params: {
    enterprise: string;
    runner_group_id: number;
  }): Promise<RunnerGroupsEnterprise> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/runner-groups-enterprise"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(
    params: {
      enterprise: string;
      runner_group_id: number;
    },
    body: {
      name?: string;
      visibility?: 'selected' | 'all';
    },
  ): Promise<RunnerGroupsEnterprise> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/runner-groups-enterprise"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(params: {
    enterprise: string;
    runner_group_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(params: {
    enterprise: string;
    runner_group_id: number;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    organizations: OrganizationSimple[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{"total_count":{"type":"number"},"organizations":{"type":"array","items":{"$ref":"#/components/schemas/organization-simple"}}},"required":["total_count","organizations"]}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(
    params: {
      enterprise: string;
      runner_group_id: number;
    },
    body: {
      selected_organization_ids: number[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(params: {
    enterprise: string;
    runner_group_id: number;
    org_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(params: {
    enterprise: string;
    runner_group_id: number;
    org_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminListSelfHostedRunnersInGroupForEnterprise(params: {
    enterprise: string;
    runner_group_id: number;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    runners: Runner[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{"total_count":{"type":"number"},"runners":{"type":"array","items":{"$ref":"#/components/schemas/runner"}}},"required":["total_count","runners"]}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(
    params: {
      enterprise: string;
      runner_group_id: number;
    },
    body: {
      runners: number[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(params: {
    enterprise: string;
    runner_group_id: number;
    runner_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(params: {
    enterprise: string;
    runner_group_id: number;
    runner_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminListSelfHostedRunnersForEnterprise(params: {
    enterprise: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count?: number;
    runners?: Runner[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/enterprises/{enterprise}/actions/runners', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{"total_count":{"type":"number"},"runners":{"type":"array","items":{"$ref":"#/components/schemas/runner"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminListRunnerApplicationsForEnterprise(params: {
    enterprise: string;
  }): Promise<RunnerApplication[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runners/downloads',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/runner-application"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminCreateRegistrationTokenForEnterprise(params: {
    enterprise: string;
  }): Promise<AuthenticationToken> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runners/registration-token',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authentication-token"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminCreateRemoveTokenForEnterprise(params: {
    enterprise: string;
  }): Promise<AuthenticationToken> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runners/remove-token',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authentication-token"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminGetSelfHostedRunnerForEnterprise(params: {
    enterprise: string;
    runner_id: number;
  }): Promise<Runner> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runners/{runner_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/runner"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminDeleteSelfHostedRunnerFromEnterprise(params: {
    enterprise: string;
    runner_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/actions/runners/{runner_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async auditLogGetAuditLog(params: {
    enterprise: string;
    phrase?: string;
    include?: 'web' | 'git' | 'all';
    after?: string;
    before?: string;
    order?: 'desc' | 'asc';
    page?: number;
    per_page?: number;
  }): Promise<AuditLogEvent[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/enterprises/{enterprise}/audit-log', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.phrase !== undefined)
      requestContext.setQueryParam(
        'phrase',
        r.serializeParameter(params.phrase),
      );
    if (params.include !== undefined)
      requestContext.setQueryParam(
        'include',
        r.serializeParameter(params.include),
      );
    if (params.after !== undefined)
      requestContext.setQueryParam('after', r.serializeParameter(params.after));
    if (params.before !== undefined)
      requestContext.setQueryParam(
        'before',
        r.serializeParameter(params.before),
      );
    if (params.order !== undefined)
      requestContext.setQueryParam('order', r.serializeParameter(params.order));
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/audit-log-event"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async billingGetGithubActionsBillingGhe(params: {
    enterprise: string;
  }): Promise<ActionsBillingUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/settings/billing/actions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/actions-billing-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async billingGetGithubPackagesBillingGhe(params: {
    enterprise: string;
  }): Promise<PackagesBillingUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/settings/billing/packages',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/packages-billing-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async billingGetSharedStorageBillingGhe(params: {
    enterprise: string;
  }): Promise<CombinedBillingUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/enterprises/{enterprise}/settings/billing/shared-storage',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/combined-billing-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListPublicEvents(params: {
    per_page?: number;
    page?: number;
  }): Promise<Event[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/events', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/event"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityGetFeeds(params: {}): Promise<Feed> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/feeds', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/feed"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsList(params: {
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<BaseGist[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/base-gist"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsCreate(
    params: {},
    body: {
      description?: string;
      files: {
        [key: string]: {
          content: string;
        };
      };
      public?: boolean | ('true' | 'false');
    },
  ): Promise<GistSimple> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/gist-simple"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsListPublic(params: {
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<BaseGist[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/public', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/base-gist"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsListStarred(params: {
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<BaseGist[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/starred', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/base-gist"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsGet(params: { gist_id: string }): Promise<GistSimple> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/gist-simple"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<{
        block?: {
          reason?: string;
          created_at?: string;
          html_url?: string | null;
        };
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"block":{"type":"object","properties":{"reason":{"type":"string"},"created_at":{"type":"string"},"html_url":{"type":"string","nullable":true}}},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsUpdate(
    params: {
      gist_id: string;
    },
    body: {
      description?: string;
      files?: {
        [key: string]: {
          content?: string;
          filename?: string | null;
        } | null;
      };
    } | null,
  ): Promise<GistSimple> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/gist-simple"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsDelete(params: { gist_id: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsListComments(params: {
    gist_id: string;
    per_page?: number;
    page?: number;
  }): Promise<GistComment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/comments', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/gist-comment"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsCreateComment(
    params: {
      gist_id: string;
    },
    body: {
      body: string;
    },
  ): Promise<GistComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/comments', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/gist-comment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsGetComment(params: {
    gist_id: string;
    comment_id: number;
  }): Promise<GistComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/comments/{comment_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/gist-comment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<{
        block?: {
          reason?: string;
          created_at?: string;
          html_url?: string | null;
        };
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"block":{"type":"object","properties":{"reason":{"type":"string"},"created_at":{"type":"string"},"html_url":{"type":"string","nullable":true}}},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsUpdateComment(
    params: {
      gist_id: string;
      comment_id: number;
    },
    body: {
      body: string;
    },
  ): Promise<GistComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/comments/{comment_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/gist-comment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsDeleteComment(params: {
    gist_id: string;
    comment_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/comments/{comment_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsListCommits(params: {
    gist_id: string;
    per_page?: number;
    page?: number;
  }): Promise<GistCommit[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/commits', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/gist-commit"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsListForks(params: {
    gist_id: string;
    per_page?: number;
    page?: number;
  }): Promise<GistSimple[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/forks', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/gist-simple"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsFork(params: { gist_id: string }): Promise<BaseGist> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/forks', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/base-gist"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsCheckIsStarred(params: { gist_id: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/star', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{},"additionalProperties":false}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsStar(params: { gist_id: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/star', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsUnstar(params: { gist_id: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/star', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsGetRevision(params: {
    gist_id: string;
    sha: string;
  }): Promise<GistSimple> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gists/{gist_id}/{sha}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/gist-simple"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitignoreGetAllTemplates(params: {}): Promise<string[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gitignore/templates', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"type":"array","items":{"type":"string"}}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitignoreGetTemplate(params: {
    name: string;
  }): Promise<GitignoreTemplate> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/gitignore/templates/{name}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/gitignore-template"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsListReposAccessibleToInstallation(params: {
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    repositories: Repository[];
    repository_selection?: string;
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/installation/repositories', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","repositories"],"properties":{"total_count":{"type":"integer"},"repositories":{"type":"array","items":{"$ref":"#/components/schemas/repository"}},"repository_selection":{"type":"string","example":"selected"}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsRevokeInstallationAccessToken(params: {}): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/installation/token', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesList(params: {
    filter?:
      | 'assigned'
      | 'created'
      | 'mentioned'
      | 'subscribed'
      | 'repos'
      | 'all';
    state?: 'open' | 'closed' | 'all';
    labels?: string;
    sort?: 'created' | 'updated' | 'comments';
    direction?: 'asc' | 'desc';
    since?: string;
    collab?: boolean;
    orgs?: boolean;
    owned?: boolean;
    pulls?: boolean;
    per_page?: number;
    page?: number;
  }): Promise<Issue[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/issues', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.labels !== undefined)
      requestContext.setQueryParam(
        'labels',
        r.serializeParameter(params.labels),
      );
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.collab !== undefined)
      requestContext.setQueryParam(
        'collab',
        r.serializeParameter(params.collab),
      );
    if (params.orgs !== undefined)
      requestContext.setQueryParam('orgs', r.serializeParameter(params.orgs));
    if (params.owned !== undefined)
      requestContext.setQueryParam('owned', r.serializeParameter(params.owned));
    if (params.pulls !== undefined)
      requestContext.setQueryParam('pulls', r.serializeParameter(params.pulls));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/issue"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async licensesGetAllCommonlyUsed(params: {
    featured?: boolean;
    per_page?: number;
    page?: number;
  }): Promise<LicenseSimple[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/licenses', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.featured !== undefined)
      requestContext.setQueryParam(
        'featured',
        r.serializeParameter(params.featured),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/license-simple"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async licensesGet(params: { license: string }): Promise<License> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/licenses/{license}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/license"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async markdownRender(
    params: {},
    body: {
      text: string;
      mode?: 'markdown' | 'gfm';
      context?: string;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/markdown', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async markdownRenderRaw(params: {}, body: any): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/markdown/raw', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsGetSubscriptionPlanForAccount(params: {
    account_id: number;
  }): Promise<MarketplacePurchase> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/marketplace_listing/accounts/{account_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/marketplace-purchase"}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsListPlans(params: {
    per_page?: number;
    page?: number;
  }): Promise<MarketplaceListingPlan[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/marketplace_listing/plans', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/marketplace-listing-plan"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsListAccountsForPlan(params: {
    plan_id: number;
    sort?: 'created' | 'updated';
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<MarketplacePurchase[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/marketplace_listing/plans/{plan_id}/accounts',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/marketplace-purchase"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsGetSubscriptionPlanForAccountStubbed(params: {
    account_id: number;
  }): Promise<MarketplacePurchase> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/marketplace_listing/stubbed/accounts/{account_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/marketplace-purchase"}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsListPlansStubbed(params: {
    per_page?: number;
    page?: number;
  }): Promise<MarketplaceListingPlan[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/marketplace_listing/stubbed/plans', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/marketplace-listing-plan"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsListAccountsForPlanStubbed(params: {
    plan_id: number;
    sort?: 'created' | 'updated';
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<MarketplacePurchase[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/marketplace_listing/stubbed/plans/{plan_id}/accounts',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/marketplace-purchase"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async metaGet(params: {}): Promise<ApiOverview> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/meta', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/api-overview"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListPublicEventsForRepoNetwork(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<Event[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/networks/{owner}/{repo}/events', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/event"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('301', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListNotificationsForAuthenticatedUser(params: {
    all?: boolean;
    participating?: boolean;
    since?: string;
    before?: string;
    per_page?: number;
    page?: number;
  }): Promise<Thread[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/notifications', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.all !== undefined)
      requestContext.setQueryParam('all', r.serializeParameter(params.all));
    if (params.participating !== undefined)
      requestContext.setQueryParam(
        'participating',
        r.serializeParameter(params.participating),
      );
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.before !== undefined)
      requestContext.setQueryParam(
        'before',
        r.serializeParameter(params.before),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/thread"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityMarkNotificationsAsRead(
    params: {},
    body: {
      last_read_at?: Date;
      read?: boolean;
    },
  ): Promise<{
    message?: string;
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/notifications', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('202', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{"message":{"type":"string"}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('205', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityGetThread(params: { thread_id: number }): Promise<Thread> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/notifications/threads/{thread_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/thread"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityMarkThreadAsRead(params: { thread_id: number }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/notifications/threads/{thread_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('205', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityGetThreadSubscriptionForAuthenticatedUser(params: {
    thread_id: number;
  }): Promise<ThreadSubscription> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/notifications/threads/{thread_id}/subscription',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/thread-subscription"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activitySetThreadSubscription(
    params: {
      thread_id: number;
    },
    body: {
      ignored?: boolean;
    },
  ): Promise<ThreadSubscription> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/notifications/threads/{thread_id}/subscription',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/thread-subscription"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityDeleteThreadSubscription(params: {
    thread_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/notifications/threads/{thread_id}/subscription',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async metaGetOctocat(params: { s?: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/octocat', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.s !== undefined)
      requestContext.setQueryParam('s', r.serializeParameter(params.s));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsList(params: {
    since?: number;
    per_page?: number;
  }): Promise<OrganizationSimple[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/organizations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/organization-simple"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsGet(params: { org: string }): Promise<OrganizationFull> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/organization-full"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsUpdate(
    params: {
      org: string;
    },
    body: {
      billing_email?: string;
      company?: string;
      email?: string;
      twitter_username?: string;
      location?: string;
      name?: string;
      description?: string;
      has_organization_projects?: boolean;
      has_repository_projects?: boolean;
      default_repository_permission?: 'read' | 'write' | 'admin' | 'none';
      members_can_create_repositories?: boolean;
      members_can_create_internal_repositories?: boolean;
      members_can_create_private_repositories?: boolean;
      members_can_create_public_repositories?: boolean;
      members_allowed_repository_creation_type?: 'all' | 'private' | 'none';
      members_can_create_pages?: boolean;
      members_can_create_public_pages?: boolean;
      members_can_create_private_pages?: boolean;
      blog?: string;
    },
  ): Promise<OrganizationFull> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/organization-full"}'),
        this.resolver,
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError | ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"oneOf":[{"$ref":"#/components/schemas/validation-error"},{"$ref":"#/components/schemas/validation-error-simple"}]}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetGithubActionsPermissionsOrganization(params: {
    org: string;
  }): Promise<ActionsOrganizationPermissions> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/permissions', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/actions-organization-permissions"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsSetGithubActionsPermissionsOrganization(
    params: {
      org: string;
    },
    body: {
      enabled_repositories: EnabledRepositories;
      allowed_actions?: AllowedActions;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/permissions', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListSelectedRepositoriesEnabledGithubActionsOrganization(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    repositories: Repository[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/permissions/repositories', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","repositories"],"properties":{"total_count":{"type":"number"},"repositories":{"type":"array","items":{"$ref":"#/components/schemas/repository"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
    params: {
      org: string;
    },
    body: {
      selected_repository_ids: number[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/permissions/repositories', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsEnableSelectedRepositoryGithubActionsOrganization(params: {
    org: string;
    repository_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/permissions/repositories/{repository_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDisableSelectedRepositoryGithubActionsOrganization(params: {
    org: string;
    repository_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/permissions/repositories/{repository_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetAllowedActionsOrganization(params: {
    org: string;
  }): Promise<SelectedActions> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/permissions/selected-actions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/selected-actions"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsSetAllowedActionsOrganization(
    params: {
      org: string;
    },
    body: SelectedActions,
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/permissions/selected-actions',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListSelfHostedRunnerGroupsForOrg(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    runner_groups: RunnerGroupsOrg[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/runner-groups', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","runner_groups"],"properties":{"total_count":{"type":"number"},"runner_groups":{"type":"array","items":{"$ref":"#/components/schemas/runner-groups-org"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsCreateSelfHostedRunnerGroupForOrg(
    params: {
      org: string;
    },
    body: {
      name: string;
      visibility?: 'selected' | 'all' | 'private';
      selected_repository_ids?: number[];
      runners?: number[];
    },
  ): Promise<RunnerGroupsOrg> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/runner-groups', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/runner-groups-org"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetSelfHostedRunnerGroupForOrg(params: {
    org: string;
    runner_group_id: number;
  }): Promise<RunnerGroupsOrg> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/runner-groups-org"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsUpdateSelfHostedRunnerGroupForOrg(
    params: {
      org: string;
      runner_group_id: number;
    },
    body: {
      name?: string;
      visibility?: 'selected' | 'all' | 'private';
    },
  ): Promise<RunnerGroupsOrg> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/runner-groups-org"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDeleteSelfHostedRunnerGroupFromOrg(params: {
    org: string;
    runner_group_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListRepoAccessToSelfHostedRunnerGroupInOrg(params: {
    org: string;
    runner_group_id: number;
    page?: number;
    per_page?: number;
  }): Promise<{
    total_count: number;
    repositories: Repository[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","repositories"],"properties":{"total_count":{"type":"number"},"repositories":{"type":"array","items":{"$ref":"#/components/schemas/repository"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(
    params: {
      org: string;
      runner_group_id: number;
    },
    body: {
      selected_repository_ids: number[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsAddRepoAccessToSelfHostedRunnerGroupInOrg(params: {
    org: string;
    runner_group_id: number;
    repository_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(params: {
    org: string;
    runner_group_id: number;
    repository_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListSelfHostedRunnersInGroupForOrg(params: {
    org: string;
    runner_group_id: number;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    runners: Runner[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","runners"],"properties":{"total_count":{"type":"number"},"runners":{"type":"array","items":{"$ref":"#/components/schemas/runner"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsSetSelfHostedRunnersInGroupForOrg(
    params: {
      org: string;
      runner_group_id: number;
    },
    body: {
      runners: number[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsAddSelfHostedRunnerToGroupForOrg(params: {
    org: string;
    runner_group_id: number;
    runner_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsRemoveSelfHostedRunnerFromGroupForOrg(params: {
    org: string;
    runner_group_id: number;
    runner_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListSelfHostedRunnersForOrg(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    runners: Runner[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/runners', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","runners"],"properties":{"total_count":{"type":"integer"},"runners":{"type":"array","items":{"$ref":"#/components/schemas/runner"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListRunnerApplicationsForOrg(params: {
    org: string;
  }): Promise<RunnerApplication[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/runners/downloads', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/runner-application"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsCreateRegistrationTokenForOrg(params: {
    org: string;
  }): Promise<AuthenticationToken> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/runners/registration-token',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authentication-token"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsCreateRemoveTokenForOrg(params: {
    org: string;
  }): Promise<AuthenticationToken> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/runners/remove-token', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authentication-token"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetSelfHostedRunnerForOrg(params: {
    org: string;
    runner_id: number;
  }): Promise<Runner> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/runners/{runner_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/runner"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDeleteSelfHostedRunnerFromOrg(params: {
    org: string;
    runner_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/runners/{runner_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListOrgSecrets(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    secrets: OrganizationActionsSecret[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/secrets', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","secrets"],"properties":{"total_count":{"type":"integer"},"secrets":{"type":"array","items":{"$ref":"#/components/schemas/organization-actions-secret"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetOrgPublicKey(params: {
    org: string;
  }): Promise<ActionsPublicKey> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/secrets/public-key', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/actions-public-key"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetOrgSecret(params: {
    org: string;
    secret_name: string;
  }): Promise<OrganizationActionsSecret> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/secrets/{secret_name}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/organization-actions-secret"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsCreateOrUpdateOrgSecret(
    params: {
      org: string;
      secret_name: string;
    },
    body: {
      encrypted_value?: string;
      key_id?: string;
      visibility?: 'all' | 'private' | 'selected';
      selected_repository_ids?: string[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/secrets/{secret_name}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('204', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDeleteOrgSecret(params: {
    org: string;
    secret_name: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/actions/secrets/{secret_name}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListSelectedReposForOrgSecret(params: {
    org: string;
    secret_name: string;
    page?: number;
    per_page?: number;
  }): Promise<{
    total_count: number;
    repositories: MinimalRepository[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/secrets/{secret_name}/repositories',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","repositories"],"properties":{"total_count":{"type":"integer"},"repositories":{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsSetSelectedReposForOrgSecret(
    params: {
      org: string;
      secret_name: string;
    },
    body: {
      selected_repository_ids?: number[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/secrets/{secret_name}/repositories',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsAddSelectedRepoToOrgSecret(params: {
    org: string;
    secret_name: string;
    repository_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsRemoveSelectedRepoFromOrgSecret(params: {
    org: string;
    secret_name: string;
    repository_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsGetAuditLog(params: {
    org: string;
    phrase?: string;
    include?: 'web' | 'git' | 'all';
    after?: string;
    before?: string;
    order?: 'desc' | 'asc';
    per_page?: number;
    page?: number;
  }): Promise<AuditLogEvent[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/audit-log', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.phrase !== undefined)
      requestContext.setQueryParam(
        'phrase',
        r.serializeParameter(params.phrase),
      );
    if (params.include !== undefined)
      requestContext.setQueryParam(
        'include',
        r.serializeParameter(params.include),
      );
    if (params.after !== undefined)
      requestContext.setQueryParam('after', r.serializeParameter(params.after));
    if (params.before !== undefined)
      requestContext.setQueryParam(
        'before',
        r.serializeParameter(params.before),
      );
    if (params.order !== undefined)
      requestContext.setQueryParam('order', r.serializeParameter(params.order));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/audit-log-event"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListBlockedUsers(params: { org: string }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/blocks', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsCheckBlockedUser(params: {
    org: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/blocks/{username}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsBlockUser(params: { org: string; username: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/blocks/{username}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsUnblockUser(params: {
    org: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/blocks/{username}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListSamlSsoAuthorizations(params: {
    org: string;
  }): Promise<CredentialAuthorization[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/credential-authorizations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/credential-authorization"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsRemoveSamlSsoAuthorization(params: {
    org: string;
    credential_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/credential-authorizations/{credential_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListPublicOrgEvents(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<Event[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/events', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/event"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListFailedInvitations(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<OrganizationInvitation[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/failed_invitations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/organization-invitation"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListWebhooks(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<OrgHook[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/hooks', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/org-hook"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsCreateWebhook(
    params: {
      org: string;
    },
    body: {
      name: string;
      config: {
        url: WebhookConfigUrl;
        content_type?: WebhookConfigContentType;
        secret?: WebhookConfigSecret;
        insecure_ssl?: WebhookConfigInsecureSsl;
        username?: string;
        password?: string;
      };
      events?: string[];
      active?: boolean;
    },
  ): Promise<OrgHook> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/hooks', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/org-hook"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsGetWebhook(params: {
    org: string;
    hook_id: number;
  }): Promise<OrgHook> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/hooks/{hook_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/org-hook"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsUpdateWebhook(
    params: {
      org: string;
      hook_id: number;
    },
    body: {
      config?: {
        url: WebhookConfigUrl;
        content_type?: WebhookConfigContentType;
        secret?: WebhookConfigSecret;
        insecure_ssl?: WebhookConfigInsecureSsl;
      };
      events?: string[];
      active?: boolean;
      name?: string;
    },
  ): Promise<OrgHook> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/hooks/{hook_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/org-hook"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsDeleteWebhook(params: {
    org: string;
    hook_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/hooks/{hook_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsGetWebhookConfigForOrg(params: {
    org: string;
    hook_id: number;
  }): Promise<WebhookConfig> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/hooks/{hook_id}/config', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/webhook-config"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsUpdateWebhookConfigForOrg(
    params: {
      org: string;
      hook_id: number;
    },
    body: {
      url?: WebhookConfigUrl;
      content_type?: WebhookConfigContentType;
      secret?: WebhookConfigSecret;
      insecure_ssl?: WebhookConfigInsecureSsl;
    },
  ): Promise<WebhookConfig> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/hooks/{hook_id}/config', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/webhook-config"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsPingWebhook(params: {
    org: string;
    hook_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/hooks/{hook_id}/pings', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsGetOrgInstallation(params: { org: string }): Promise<Installation> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/installation', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/installation"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListAppInstallations(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    installations: Installation[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/installations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","installations"],"properties":{"total_count":{"type":"integer"},"installations":{"type":"array","items":{"$ref":"#/components/schemas/installation"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async interactionsGetRestrictionsForOrg(params: {
    org: string;
  }): Promise<InteractionLimitResponse> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/interaction-limits', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/interaction-limit-response"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async interactionsSetRestrictionsForOrg(
    params: {
      org: string;
    },
    body: InteractionLimit,
  ): Promise<InteractionLimitResponse> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/interaction-limits', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/interaction-limit-response"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async interactionsRemoveRestrictionsForOrg(params: {
    org: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/interaction-limits', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListPendingInvitations(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<OrganizationInvitation[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/invitations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/organization-invitation"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsCreateInvitation(
    params: {
      org: string;
    },
    body: {
      invitee_id?: number;
      email?: string;
      role?: 'admin' | 'direct_member' | 'billing_manager';
      team_ids?: number[];
    },
  ): Promise<OrganizationInvitation> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/invitations', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/organization-invitation"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsCancelInvitation(params: {
    org: string;
    invitation_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/invitations/{invitation_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListInvitationTeams(params: {
    org: string;
    invitation_id: number;
    per_page?: number;
    page?: number;
  }): Promise<Team[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/invitations/{invitation_id}/teams',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListForOrg(params: {
    org: string;
    filter?:
      | 'assigned'
      | 'created'
      | 'mentioned'
      | 'subscribed'
      | 'repos'
      | 'all';
    state?: 'open' | 'closed' | 'all';
    labels?: string;
    sort?: 'created' | 'updated' | 'comments';
    direction?: 'asc' | 'desc';
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<Issue[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/issues', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.labels !== undefined)
      requestContext.setQueryParam(
        'labels',
        r.serializeParameter(params.labels),
      );
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/issue"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListMembers(params: {
    org: string;
    filter?: '2fa_disabled' | 'all';
    role?: 'all' | 'admin' | 'member';
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/members', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    if (params.role !== undefined)
      requestContext.setQueryParam('role', r.serializeParameter(params.role));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsCheckMembershipForUser(params: {
    org: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/members/{username}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsRemoveMember(params: {
    org: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/members/{username}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsGetMembershipForUser(params: {
    org: string;
    username: string;
  }): Promise<OrgMembership> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/memberships/{username}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/org-membership"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsSetMembershipForUser(
    params: {
      org: string;
      username: string;
    },
    body: {
      role?: 'admin' | 'member';
    },
  ): Promise<OrgMembership> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/memberships/{username}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/org-membership"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsRemoveMembershipForUser(params: {
    org: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/memberships/{username}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsListForOrg(params: {
    org: string;
    per_page?: number;
    page?: number;
    exclude?: 'repositories'[];
  }): Promise<Migration[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/migrations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.exclude !== undefined)
      requestContext.setQueryParam(
        'exclude',
        r.serializeParameter(params.exclude),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/migration"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsStartForOrg(
    params: {
      org: string;
    },
    body: {
      repositories: string[];
      lock_repositories?: boolean;
      exclude_attachments?: boolean;
      exclude?: string[];
    },
  ): Promise<Migration> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/migrations', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/migration"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsGetStatusForOrg(params: {
    org: string;
    migration_id: number;
    exclude?: 'repositories'[];
  }): Promise<Migration> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/migrations/{migration_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.exclude !== undefined)
      requestContext.setQueryParam(
        'exclude',
        r.serializeParameter(params.exclude),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/migration"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsDownloadArchiveForOrg(params: {
    org: string;
    migration_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/migrations/{migration_id}/archive',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsDeleteArchiveForOrg(params: {
    org: string;
    migration_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/migrations/{migration_id}/archive',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsUnlockRepoForOrg(params: {
    org: string;
    migration_id: number;
    repo_name: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsListReposForOrg(params: {
    org: string;
    migration_id: number;
    per_page?: number;
    page?: number;
  }): Promise<MinimalRepository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/migrations/{migration_id}/repositories',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListOutsideCollaborators(params: {
    org: string;
    filter?: '2fa_disabled' | 'all';
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/outside_collaborators', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsConvertMemberToOutsideCollaborator(params: {
    org: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/outside_collaborators/{username}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('202', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('204', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsRemoveOutsideCollaborator(params: {
    org: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/outside_collaborators/{username}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesGetPackageForOrganization(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    org: string;
  }): Promise<Package> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/packages/{package_type}/{package_name}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/package"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesDeletePackageForOrg(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    org: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/packages/{package_type}/{package_name}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesRestorePackageForOrg(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    org: string;
    token?: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/packages/{package_type}/{package_name}/restore',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.token !== undefined)
      requestContext.setQueryParam('token', r.serializeParameter(params.token));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesGetAllPackageVersionsForPackageOwnedByOrg(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    org: string;
    page?: number;
    per_page?: number;
    state?: 'active' | 'deleted';
  }): Promise<PackageVersion[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/packages/{package_type}/{package_name}/versions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/package-version"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesGetPackageVersionForOrganization(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    org: string;
    package_version_id: number;
  }): Promise<PackageVersion> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/package-version"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesDeletePackageVersionForOrg(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    org: string;
    package_version_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesRestorePackageVersionForOrg(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    org: string;
    package_version_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsListForOrg(params: {
    org: string;
    state?: 'open' | 'closed' | 'all';
    per_page?: number;
    page?: number;
  }): Promise<Project[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/projects', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/project"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsCreateForOrg(
    params: {
      org: string;
    },
    body: {
      name: string;
      body?: string;
    },
  ): Promise<Project> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/projects', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project"}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListPublicMembers(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/public_members', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsCheckPublicMembershipForUser(params: {
    org: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/public_members/{username}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsSetPublicMembershipForAuthenticatedUser(params: {
    org: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/public_members/{username}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsRemovePublicMembershipForAuthenticatedUser(params: {
    org: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/public_members/{username}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListForOrg(params: {
    org: string;
    type?:
      | 'all'
      | 'public'
      | 'private'
      | 'forks'
      | 'sources'
      | 'member'
      | 'internal';
    sort?: 'created' | 'updated' | 'pushed' | 'full_name';
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<MinimalRepository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/repos', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.type !== undefined)
      requestContext.setQueryParam('type', r.serializeParameter(params.type));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateInOrg(
    params: {
      org: string;
    },
    body: {
      name: string;
      description?: string;
      homepage?: string;
      private?: boolean;
      visibility?: 'public' | 'private' | 'visibility' | 'internal';
      has_issues?: boolean;
      has_projects?: boolean;
      has_wiki?: boolean;
      is_template?: boolean;
      team_id?: number;
      auto_init?: boolean;
      gitignore_template?: string;
      license_template?: string;
      allow_squash_merge?: boolean;
      allow_merge_commit?: boolean;
      allow_rebase_merge?: boolean;
      delete_branch_on_merge?: boolean;
    },
  ): Promise<Repository> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/repos', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/repository"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async billingGetGithubActionsBillingOrg(params: {
    org: string;
  }): Promise<ActionsBillingUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/settings/billing/actions', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/actions-billing-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async billingGetGithubPackagesBillingOrg(params: {
    org: string;
  }): Promise<PackagesBillingUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/settings/billing/packages', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/packages-billing-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async billingGetSharedStorageBillingOrg(params: {
    org: string;
  }): Promise<CombinedBillingUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/settings/billing/shared-storage', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/combined-billing-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListIdpGroupsForOrg(params: {
    org: string;
    per_page?: number;
    page?: string;
  }): Promise<GroupMapping> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/team-sync/groups', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/group-mapping"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsList(params: {
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<Team[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCreate(
    params: {
      org: string;
    },
    body: {
      name: string;
      description?: string;
      maintainers?: string[];
      repo_names?: string[];
      privacy?: 'secret' | 'closed';
      permission?: 'pull' | 'push' | 'admin';
      parent_team_id?: number;
    },
  ): Promise<TeamFull> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-full"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsGetByName(params: {
    org: string;
    team_slug: string;
  }): Promise<TeamFull> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams/{team_slug}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-full"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsUpdateInOrg(
    params: {
      org: string;
      team_slug: string;
    },
    body: {
      name?: string;
      description?: string;
      privacy?: 'secret' | 'closed';
      permission?: 'pull' | 'push' | 'admin';
      parent_team_id?: number | null;
    },
  ): Promise<TeamFull> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams/{team_slug}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-full"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsDeleteInOrg(params: {
    org: string;
    team_slug: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams/{team_slug}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListDiscussionsInOrg(params: {
    org: string;
    team_slug: string;
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
    pinned?: string;
  }): Promise<TeamDiscussion[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams/{team_slug}/discussions', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.pinned !== undefined)
      requestContext.setQueryParam(
        'pinned',
        r.serializeParameter(params.pinned),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team-discussion"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCreateDiscussionInOrg(
    params: {
      org: string;
      team_slug: string;
    },
    body: {
      title: string;
      body: string;
      private?: boolean;
    },
  ): Promise<TeamDiscussion> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams/{team_slug}/discussions', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsGetDiscussionInOrg(params: {
    org: string;
    team_slug: string;
    discussion_number: number;
  }): Promise<TeamDiscussion> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsUpdateDiscussionInOrg(
    params: {
      org: string;
      team_slug: string;
      discussion_number: number;
    },
    body: {
      title?: string;
      body?: string;
    },
  ): Promise<TeamDiscussion> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsDeleteDiscussionInOrg(params: {
    org: string;
    team_slug: string;
    discussion_number: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListDiscussionCommentsInOrg(params: {
    org: string;
    team_slug: string;
    discussion_number: number;
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<TeamDiscussionComment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team-discussion-comment"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCreateDiscussionCommentInOrg(
    params: {
      org: string;
      team_slug: string;
      discussion_number: number;
    },
    body: {
      body: string;
    },
  ): Promise<TeamDiscussionComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion-comment"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsGetDiscussionCommentInOrg(params: {
    org: string;
    team_slug: string;
    discussion_number: number;
    comment_number: number;
  }): Promise<TeamDiscussionComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion-comment"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsUpdateDiscussionCommentInOrg(
    params: {
      org: string;
      team_slug: string;
      discussion_number: number;
      comment_number: number;
    },
    body: {
      body: string;
    },
  ): Promise<TeamDiscussionComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion-comment"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsDeleteDiscussionCommentInOrg(params: {
    org: string;
    team_slug: string;
    discussion_number: number;
    comment_number: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsListForTeamDiscussionCommentInOrg(params: {
    org: string;
    team_slug: string;
    discussion_number: number;
    comment_number: number;
    content?:
      | '+1'
      | '-1'
      | 'laugh'
      | 'confused'
      | 'heart'
      | 'hooray'
      | 'rocket'
      | 'eyes';
    per_page?: number;
    page?: number;
  }): Promise<Reaction[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.content !== undefined)
      requestContext.setQueryParam(
        'content',
        r.serializeParameter(params.content),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/reaction"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsCreateForTeamDiscussionCommentInOrg(
    params: {
      org: string;
      team_slug: string;
      discussion_number: number;
      comment_number: number;
    },
    body: {
      content:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
    },
  ): Promise<Reaction> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsDeleteForTeamDiscussionComment(params: {
    org: string;
    team_slug: string;
    discussion_number: number;
    comment_number: number;
    reaction_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsListForTeamDiscussionInOrg(params: {
    org: string;
    team_slug: string;
    discussion_number: number;
    content?:
      | '+1'
      | '-1'
      | 'laugh'
      | 'confused'
      | 'heart'
      | 'hooray'
      | 'rocket'
      | 'eyes';
    per_page?: number;
    page?: number;
  }): Promise<Reaction[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.content !== undefined)
      requestContext.setQueryParam(
        'content',
        r.serializeParameter(params.content),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/reaction"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsCreateForTeamDiscussionInOrg(
    params: {
      org: string;
      team_slug: string;
      discussion_number: number;
    },
    body: {
      content:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
    },
  ): Promise<Reaction> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsDeleteForTeamDiscussion(params: {
    org: string;
    team_slug: string;
    discussion_number: number;
    reaction_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListPendingInvitationsInOrg(params: {
    org: string;
    team_slug: string;
    per_page?: number;
    page?: number;
  }): Promise<OrganizationInvitation[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams/{team_slug}/invitations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/organization-invitation"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListMembersInOrg(params: {
    org: string;
    team_slug: string;
    role?: 'member' | 'maintainer' | 'all';
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams/{team_slug}/members', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.role !== undefined)
      requestContext.setQueryParam('role', r.serializeParameter(params.role));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsGetMembershipForUserInOrg(params: {
    org: string;
    team_slug: string;
    username: string;
  }): Promise<TeamMembership> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/memberships/{username}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-membership"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsAddOrUpdateMembershipForUserInOrg(
    params: {
      org: string;
      team_slug: string;
      username: string;
    },
    body: {
      role?: 'member' | 'maintainer';
    },
  ): Promise<TeamMembership> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/memberships/{username}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-membership"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        errors?: {
          code?: string;
          field?: string;
          resource?: string;
        }[];
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"errors":{"type":"array","items":{"type":"object","properties":{"code":{"type":"string"},"field":{"type":"string"},"resource":{"type":"string"}}}}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsRemoveMembershipForUserInOrg(params: {
    org: string;
    team_slug: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/memberships/{username}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListProjectsInOrg(params: {
    org: string;
    team_slug: string;
    per_page?: number;
    page?: number;
  }): Promise<TeamProject[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams/{team_slug}/projects', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team-project"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCheckPermissionsForProjectInOrg(params: {
    org: string;
    team_slug: string;
    project_id: number;
  }): Promise<TeamProject> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/projects/{project_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-project"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsAddOrUpdateProjectPermissionsInOrg(
    params: {
      org: string;
      team_slug: string;
      project_id: number;
    },
    body: {
      permission?: 'read' | 'write' | 'admin';
    } | null,
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/projects/{project_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsRemoveProjectInOrg(params: {
    org: string;
    team_slug: string;
    project_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/projects/{project_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListReposInOrg(params: {
    org: string;
    team_slug: string;
    per_page?: number;
    page?: number;
  }): Promise<MinimalRepository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams/{team_slug}/repos', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCheckPermissionsForRepoInOrg(params: {
    org: string;
    team_slug: string;
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('204', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsAddOrUpdateRepoPermissionsInOrg(
    params: {
      org: string;
      team_slug: string;
      owner: string;
      repo: string;
    },
    body: {
      permission?: 'pull' | 'push' | 'admin' | 'maintain' | 'triage';
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsRemoveRepoInOrg(params: {
    org: string;
    team_slug: string;
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListIdpGroupsInOrg(params: {
    org: string;
    team_slug: string;
  }): Promise<GroupMapping> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/team-sync/group-mappings',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/group-mapping"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCreateOrUpdateIdpGroupConnectionsInOrg(
    params: {
      org: string;
      team_slug: string;
    },
    body: {
      groups: {
        group_id: string;
        group_name: string;
        group_description: string;
      }[];
    },
  ): Promise<GroupMapping> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/orgs/{org}/teams/{team_slug}/team-sync/group-mappings',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/group-mapping"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListChildInOrg(params: {
    org: string;
    team_slug: string;
    per_page?: number;
    page?: number;
  }): Promise<Team[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/orgs/{org}/teams/{team_slug}/teams', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsGetCard(params: { card_id: number }): Promise<ProjectCard> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/columns/cards/{card_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project-card"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsUpdateCard(
    params: {
      card_id: number;
    },
    body: {
      note?: string | null;
      archived?: boolean;
    },
  ): Promise<ProjectCard> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/columns/cards/{card_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project-card"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsDeleteCard(params: { card_id: number }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/columns/cards/{card_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
        errors?: string[];
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"},"errors":{"type":"array","items":{"type":"string"}}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsMoveCard(
    params: {
      card_id: number;
    },
    body: {
      position: string;
      column_id?: number;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/columns/cards/{card_id}/moves', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{},"additionalProperties":false}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
        errors?: {
          code?: string;
          message?: string;
          resource?: string;
          field?: string;
        }[];
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"},"errors":{"type":"array","items":{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"resource":{"type":"string"},"field":{"type":"string"}}}}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
        errors?: {
          code?: string;
          message?: string;
        }[];
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"},"errors":{"type":"array","items":{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"}}}}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsGetColumn(params: {
    column_id: number;
  }): Promise<ProjectColumn> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/columns/{column_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project-column"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsUpdateColumn(
    params: {
      column_id: number;
    },
    body: {
      name: string;
    },
  ): Promise<ProjectColumn> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/columns/{column_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project-column"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsDeleteColumn(params: { column_id: number }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/columns/{column_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsListCards(params: {
    column_id: number;
    archived_state?: 'all' | 'archived' | 'not_archived';
    per_page?: number;
    page?: number;
  }): Promise<ProjectCard[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/columns/{column_id}/cards', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.archived_state !== undefined)
      requestContext.setQueryParam(
        'archived_state',
        r.serializeParameter(params.archived_state),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/project-card"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsCreateCard(
    params: {
      column_id: number;
    },
    body:
      | {
          note: string | null;
        }
      | {
          content_id: number;
          content_type: string;
        },
  ): Promise<ProjectCard> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/columns/{column_id}/cards', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project-card"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError | ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"oneOf":[{"$ref":"#/components/schemas/validation-error"},{"$ref":"#/components/schemas/validation-error-simple"}]}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
        errors?: {
          code?: string;
          message?: string;
        }[];
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"},"errors":{"type":"array","items":{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"}}}}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsMoveColumn(
    params: {
      column_id: number;
    },
    body: {
      position: string;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/columns/{column_id}/moves', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{},"additionalProperties":false}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsGet(params: { project_id: number }): Promise<Project> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/{project_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsUpdate(
    params: {
      project_id: number;
    },
    body: {
      name?: string;
      body?: string | null;
      state?: string;
      organization_permission?: 'read' | 'write' | 'admin' | 'none';
      private?: boolean;
    },
  ): Promise<Project> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/{project_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
        errors?: string[];
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"},"errors":{"type":"array","items":{"type":"string"}}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsDelete(params: { project_id: number }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/{project_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
        errors?: string[];
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"},"errors":{"type":"array","items":{"type":"string"}}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsListCollaborators(params: {
    project_id: number;
    affiliation?: 'outside' | 'direct' | 'all';
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/{project_id}/collaborators', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.affiliation !== undefined)
      requestContext.setQueryParam(
        'affiliation',
        r.serializeParameter(params.affiliation),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsAddCollaborator(
    params: {
      project_id: number;
      username: string;
    },
    body: {
      permission?: 'read' | 'write' | 'admin';
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/projects/{project_id}/collaborators/{username}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsRemoveCollaborator(params: {
    project_id: number;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/projects/{project_id}/collaborators/{username}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsGetPermissionForUser(params: {
    project_id: number;
    username: string;
  }): Promise<RepositoryCollaboratorPermission> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/projects/{project_id}/collaborators/{username}/permission',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/repository-collaborator-permission"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsListColumns(params: {
    project_id: number;
    per_page?: number;
    page?: number;
  }): Promise<ProjectColumn[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/{project_id}/columns', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/project-column"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsCreateColumn(
    params: {
      project_id: number;
    },
    body: {
      name: string;
    },
  ): Promise<ProjectColumn> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/projects/{project_id}/columns', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project-column"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async rateLimitGet(params: {}): Promise<RateLimitOverview> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/rate_limit', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/rate-limit-overview"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsDeleteLegacy(params: { reaction_id: number }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/reactions/{reaction_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGet(params: {
    owner: string;
    repo: string;
  }): Promise<FullRepository> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/full-repository"}'),
        this.resolver,
      );
    if (r.isCodeInRange('301', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdate(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      name?: string;
      description?: string;
      homepage?: string;
      private?: boolean;
      visibility?: 'public' | 'private' | 'visibility' | 'internal';
      has_issues?: boolean;
      has_projects?: boolean;
      has_wiki?: boolean;
      is_template?: boolean;
      default_branch?: string;
      allow_squash_merge?: boolean;
      allow_merge_commit?: boolean;
      allow_rebase_merge?: boolean;
      delete_branch_on_merge?: boolean;
      archived?: boolean;
    },
  ): Promise<FullRepository> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/full-repository"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDelete(params: { owner: string; repo: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListArtifactsForRepo(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    artifacts: Artifact[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/actions/artifacts', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","artifacts"],"properties":{"total_count":{"type":"integer"},"artifacts":{"type":"array","items":{"$ref":"#/components/schemas/artifact"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetArtifact(params: {
    owner: string;
    repo: string;
    artifact_id: number;
  }): Promise<Artifact> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/artifact"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDeleteArtifact(params: {
    owner: string;
    repo: string;
    artifact_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDownloadArtifact(params: {
    owner: string;
    repo: string;
    artifact_id: number;
    archive_format: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetJobForWorkflowRun(params: {
    owner: string;
    repo: string;
    job_id: number;
  }): Promise<Job> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/actions/jobs/{job_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('202', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/job"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDownloadJobLogsForWorkflowRun(params: {
    owner: string;
    repo: string;
    job_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/jobs/{job_id}/logs',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetGithubActionsPermissionsRepository(params: {
    owner: string;
    repo: string;
  }): Promise<ActionsRepositoryPermissions> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/actions/permissions', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/actions-repository-permissions"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsSetGithubActionsPermissionsRepository(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      enabled: ActionsEnabled;
      allowed_actions?: AllowedActions;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/actions/permissions', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetAllowedActionsRepository(params: {
    owner: string;
    repo: string;
  }): Promise<SelectedActions> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/permissions/selected-actions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/selected-actions"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsSetAllowedActionsRepository(
    params: {
      owner: string;
      repo: string;
    },
    body: SelectedActions,
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/permissions/selected-actions',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListSelfHostedRunnersForRepo(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    runners: Runner[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/actions/runners', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","runners"],"properties":{"total_count":{"type":"integer"},"runners":{"type":"array","items":{"$ref":"#/components/schemas/runner"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListRunnerApplicationsForRepo(params: {
    owner: string;
    repo: string;
  }): Promise<RunnerApplication[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runners/downloads',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/runner-application"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsCreateRegistrationTokenForRepo(params: {
    owner: string;
    repo: string;
  }): Promise<AuthenticationToken> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runners/registration-token',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authentication-token"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsCreateRemoveTokenForRepo(params: {
    owner: string;
    repo: string;
  }): Promise<AuthenticationToken> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runners/remove-token',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/authentication-token"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetSelfHostedRunnerForRepo(params: {
    owner: string;
    repo: string;
    runner_id: number;
  }): Promise<Runner> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runners/{runner_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/runner"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDeleteSelfHostedRunnerFromRepo(params: {
    owner: string;
    repo: string;
    runner_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runners/{runner_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListWorkflowRunsForRepo(params: {
    owner: string;
    repo: string;
    actor?: string;
    branch?: string;
    event?: string;
    status?:
      | 'completed'
      | 'action_required'
      | 'cancelled'
      | 'failure'
      | 'neutral'
      | 'skipped'
      | 'stale'
      | 'success'
      | 'timed_out'
      | 'in_progress'
      | 'queued'
      | 'requested'
      | 'waiting';
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    workflow_runs: WorkflowRun[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/actions/runs', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.actor !== undefined)
      requestContext.setQueryParam('actor', r.serializeParameter(params.actor));
    if (params.branch !== undefined)
      requestContext.setQueryParam(
        'branch',
        r.serializeParameter(params.branch),
      );
    if (params.event !== undefined)
      requestContext.setQueryParam('event', r.serializeParameter(params.event));
    if (params.status !== undefined)
      requestContext.setQueryParam(
        'status',
        r.serializeParameter(params.status),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","workflow_runs"],"properties":{"total_count":{"type":"integer"},"workflow_runs":{"type":"array","items":{"$ref":"#/components/schemas/workflow-run"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetWorkflowRun(params: {
    owner: string;
    repo: string;
    run_id: number;
  }): Promise<WorkflowRun> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/actions/runs/{run_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/workflow-run"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDeleteWorkflowRun(params: {
    owner: string;
    repo: string;
    run_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/actions/runs/{run_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetReviewsForRun(params: {
    owner: string;
    repo: string;
    run_id: number;
  }): Promise<EnvironmentApprovals[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runs/{run_id}/approvals',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/environment-approvals"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListWorkflowRunArtifacts(params: {
    owner: string;
    repo: string;
    run_id: number;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    artifacts: Artifact[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","artifacts"],"properties":{"total_count":{"type":"integer"},"artifacts":{"type":"array","items":{"$ref":"#/components/schemas/artifact"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsCancelWorkflowRun(params: {
    owner: string;
    repo: string;
    run_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runs/{run_id}/cancel',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('202', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListJobsForWorkflowRun(params: {
    owner: string;
    repo: string;
    run_id: number;
    filter?: 'latest' | 'all';
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    jobs: Job[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runs/{run_id}/jobs',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","jobs"],"properties":{"total_count":{"type":"integer"},"jobs":{"type":"array","items":{"$ref":"#/components/schemas/job"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDownloadWorkflowRunLogs(params: {
    owner: string;
    repo: string;
    run_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runs/{run_id}/logs',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDeleteWorkflowRunLogs(params: {
    owner: string;
    repo: string;
    run_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runs/{run_id}/logs',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetPendingDeploymentsForRun(params: {
    owner: string;
    repo: string;
    run_id: number;
  }): Promise<PendingDeployment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/pending-deployment"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsReviewPendingDeploymentsForRun(
    params: {
      owner: string;
      repo: string;
      run_id: number;
    },
    body: {
      environment_ids: number[];
      state: 'approved' | 'rejected';
      comment: string;
    },
  ): Promise<Deployment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/deployment"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsReRunWorkflow(params: {
    owner: string;
    repo: string;
    run_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runs/{run_id}/rerun',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetWorkflowRunUsage(params: {
    owner: string;
    repo: string;
    run_id: number;
  }): Promise<WorkflowRunUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/runs/{run_id}/timing',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/workflow-run-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListRepoSecrets(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    secrets: ActionsSecret[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/actions/secrets', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","secrets"],"properties":{"total_count":{"type":"integer"},"secrets":{"type":"array","items":{"$ref":"#/components/schemas/actions-secret"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetRepoPublicKey(params: {
    owner: string;
    repo: string;
  }): Promise<ActionsPublicKey> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/secrets/public-key',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/actions-public-key"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetRepoSecret(params: {
    owner: string;
    repo: string;
    secret_name: string;
  }): Promise<ActionsSecret> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/secrets/{secret_name}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/actions-secret"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsCreateOrUpdateRepoSecret(
    params: {
      owner: string;
      repo: string;
      secret_name: string;
    },
    body: {
      encrypted_value?: string;
      key_id?: string;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/secrets/{secret_name}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('204', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDeleteRepoSecret(params: {
    owner: string;
    repo: string;
    secret_name: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/secrets/{secret_name}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListRepoWorkflows(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    workflows: Workflow[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/actions/workflows', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","workflows"],"properties":{"total_count":{"type":"integer"},"workflows":{"type":"array","items":{"$ref":"#/components/schemas/workflow"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetWorkflow(params: {
    owner: string;
    repo: string;
    workflow_id: number | string;
  }): Promise<Workflow> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/workflows/{workflow_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/workflow"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDisableWorkflow(params: {
    owner: string;
    repo: string;
    workflow_id: number | string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsCreateWorkflowDispatch(
    params: {
      owner: string;
      repo: string;
      workflow_id: number | string;
    },
    body: {
      ref: string;
      inputs?: {
        [key: string]: string;
      };
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsEnableWorkflow(params: {
    owner: string;
    repo: string;
    workflow_id: number | string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListWorkflowRuns(params: {
    owner: string;
    repo: string;
    workflow_id: number | string;
    actor?: string;
    branch?: string;
    event?: string;
    status?:
      | 'completed'
      | 'action_required'
      | 'cancelled'
      | 'failure'
      | 'neutral'
      | 'skipped'
      | 'stale'
      | 'success'
      | 'timed_out'
      | 'in_progress'
      | 'queued'
      | 'requested'
      | 'waiting';
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    workflow_runs: WorkflowRun[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.actor !== undefined)
      requestContext.setQueryParam('actor', r.serializeParameter(params.actor));
    if (params.branch !== undefined)
      requestContext.setQueryParam(
        'branch',
        r.serializeParameter(params.branch),
      );
    if (params.event !== undefined)
      requestContext.setQueryParam('event', r.serializeParameter(params.event));
    if (params.status !== undefined)
      requestContext.setQueryParam(
        'status',
        r.serializeParameter(params.status),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","workflow_runs"],"properties":{"total_count":{"type":"integer"},"workflow_runs":{"type":"array","items":{"$ref":"#/components/schemas/workflow-run"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetWorkflowUsage(params: {
    owner: string;
    repo: string;
    workflow_id: number | string;
  }): Promise<WorkflowUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/workflow-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListAssignees(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/assignees', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesCheckUserCanBeAssigned(params: {
    owner: string;
    repo: string;
    assignee: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/assignees/{assignee}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposEnableAutomatedSecurityFixes(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/automated-security-fixes',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDisableAutomatedSecurityFixes(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/automated-security-fixes',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListBranches(params: {
    owner: string;
    repo: string;
    protected?: boolean;
    per_page?: number;
    page?: number;
  }): Promise<ShortBranch[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/branches', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.protected !== undefined)
      requestContext.setQueryParam(
        'protected',
        r.serializeParameter(params.protected),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/short-branch"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetBranch(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<BranchWithProtection> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/branches/{branch}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/branch-with-protection"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetBranchProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<BranchProtection> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/branch-protection"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdateBranchProtection(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      required_status_checks: {
        strict: boolean;
        contexts: string[];
      } | null;
      enforce_admins: boolean | null;
      required_pull_request_reviews: {
        dismissal_restrictions?: {
          users?: string[];
          teams?: string[];
        };
        dismiss_stale_reviews?: boolean;
        require_code_owner_reviews?: boolean;
        required_approving_review_count?: number;
      } | null;
      restrictions: {
        users: string[];
        teams: string[];
        apps?: string[];
      } | null;
      required_linear_history?: boolean;
      allow_force_pushes?: boolean | null;
      allow_deletions?: boolean;
    },
  ): Promise<ProtectedBranch> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/protected-branch"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteBranchProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetAdminBranchProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<ProtectedBranchAdminEnforced> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/protected-branch-admin-enforced"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposSetAdminBranchProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<ProtectedBranchAdminEnforced> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/protected-branch-admin-enforced"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteAdminBranchProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetPullRequestReviewProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdatePullRequestReviewProtection(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      dismissal_restrictions?: {
        users?: string[];
        teams?: string[];
      };
      dismiss_stale_reviews?: boolean;
      require_code_owner_reviews?: boolean;
      required_approving_review_count?: number;
    },
  ): Promise<ProtectedBranchPullRequestReview> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/protected-branch-pull-request-review"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeletePullRequestReviewProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetCommitSignatureProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<ProtectedBranchAdminEnforced> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/protected-branch-admin-enforced"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateCommitSignatureProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<ProtectedBranchAdminEnforced> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/protected-branch-admin-enforced"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteCommitSignatureProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetStatusChecksProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<StatusCheckPolicy> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/status-check-policy"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdateStatusCheckProtection(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      strict?: boolean;
      contexts?: string[];
    },
  ): Promise<StatusCheckPolicy> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/status-check-policy"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposRemoveStatusCheckProtection(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetAllStatusCheckContexts(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<string[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"type":"array","items":{"type":"string"}}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposAddStatusCheckContexts(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      contexts: string[];
    },
  ): Promise<string[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"type":"array","items":{"type":"string"}}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposSetStatusCheckContexts(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      contexts: string[];
    },
  ): Promise<string[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"type":"array","items":{"type":"string"}}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposRemoveStatusCheckContexts(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      contexts: string[];
    },
  ): Promise<string[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"type":"array","items":{"type":"string"}}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetAccessRestrictions(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<BranchRestrictionPolicy> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/branch-restriction-policy"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteAccessRestrictions(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetAppsWithAccessToProtectedBranch(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<Integration[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/integration"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposAddAppAccessRestrictions(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      apps: string[];
    },
  ): Promise<Integration[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/integration"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposSetAppAccessRestrictions(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      apps: string[];
    },
  ): Promise<Integration[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/integration"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposRemoveAppAccessRestrictions(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      apps: string[];
    },
  ): Promise<Integration[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/integration"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetTeamsWithAccessToProtectedBranch(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<Team[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposAddTeamAccessRestrictions(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      teams: string[];
    },
  ): Promise<Team[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposSetTeamAccessRestrictions(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      teams: string[];
    },
  ): Promise<Team[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposRemoveTeamAccessRestrictions(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      teams: string[];
    },
  ): Promise<Team[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetUsersWithAccessToProtectedBranch(params: {
    owner: string;
    repo: string;
    branch: string;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposAddUserAccessRestrictions(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      users: string[];
    },
  ): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposSetUserAccessRestrictions(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      users: string[];
    },
  ): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposRemoveUserAccessRestrictions(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      users: string[];
    },
  ): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposRenameBranch(
    params: {
      owner: string;
      repo: string;
      branch: string;
    },
    body: {
      new_name: string;
    },
  ): Promise<BranchWithProtection> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/branches/{branch}/rename',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/branch-with-protection"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksCreate(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      name: string;
      head_sha: string;
      details_url?: string;
      external_id?: string;
      status?: 'queued' | 'in_progress' | 'completed';
      started_at?: string;
      conclusion?:
        | 'action_required'
        | 'cancelled'
        | 'failure'
        | 'neutral'
        | 'success'
        | 'skipped'
        | 'stale'
        | 'timed_out';
      completed_at?: string;
      output?: {
        title: string;
        summary: string;
        text?: string;
        annotations?: {
          path: string;
          start_line: number;
          end_line: number;
          start_column?: number;
          end_column?: number;
          annotation_level: 'notice' | 'warning' | 'failure';
          message: string;
          title?: string;
          raw_details?: string;
        }[];
        images?: {
          alt: string;
          image_url: string;
          caption?: string;
        }[];
      };
      actions?: {
        label: string;
        description: string;
        identifier: string;
      }[];
    },
  ): Promise<CheckRun> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/check-runs', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/check-run"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksGet(params: {
    owner: string;
    repo: string;
    check_run_id: number;
  }): Promise<CheckRun> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/check-runs/{check_run_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/check-run"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksUpdate(
    params: {
      owner: string;
      repo: string;
      check_run_id: number;
    },
    body: {
      name?: string;
      details_url?: string;
      external_id?: string;
      started_at?: string;
      status?: 'queued' | 'in_progress' | 'completed';
      conclusion?:
        | 'action_required'
        | 'cancelled'
        | 'failure'
        | 'neutral'
        | 'success'
        | 'skipped'
        | 'stale'
        | 'timed_out';
      completed_at?: string;
      output?: {
        title?: string;
        summary: string;
        text?: string;
        annotations?: {
          path: string;
          start_line: number;
          end_line: number;
          start_column?: number;
          end_column?: number;
          annotation_level: 'notice' | 'warning' | 'failure';
          message: string;
          title?: string;
          raw_details?: string;
        }[];
        images?: {
          alt: string;
          image_url: string;
          caption?: string;
        }[];
      };
      actions?: {
        label: string;
        description: string;
        identifier: string;
      }[];
    },
  ): Promise<CheckRun> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/check-runs/{check_run_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/check-run"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksListAnnotations(params: {
    owner: string;
    repo: string;
    check_run_id: number;
    per_page?: number;
    page?: number;
  }): Promise<CheckAnnotation[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/check-annotation"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksCreateSuite(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      head_sha: string;
    },
  ): Promise<CheckSuite> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/check-suites', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/check-suite"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksSetSuitesPreferences(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      auto_trigger_checks?: {
        app_id: number;
        setting: boolean;
      }[];
    },
  ): Promise<CheckSuitePreference> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/check-suites/preferences',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/check-suite-preference"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksGetSuite(params: {
    owner: string;
    repo: string;
    check_suite_id: number;
  }): Promise<CheckSuite> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/check-suites/{check_suite_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/check-suite"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksListForSuite(params: {
    owner: string;
    repo: string;
    check_suite_id: number;
    check_name?: string;
    status?: 'queued' | 'in_progress' | 'completed';
    filter?: 'latest' | 'all';
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    check_runs: CheckRun[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.check_name !== undefined)
      requestContext.setQueryParam(
        'check_name',
        r.serializeParameter(params.check_name),
      );
    if (params.status !== undefined)
      requestContext.setQueryParam(
        'status',
        r.serializeParameter(params.status),
      );
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","check_runs"],"properties":{"total_count":{"type":"integer"},"check_runs":{"type":"array","items":{"$ref":"#/components/schemas/check-run"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksRerequestSuite(params: {
    owner: string;
    repo: string;
    check_suite_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codeScanningListAlertsForRepo(params: {
    owner: string;
    repo: string;
    tool_name?: CodeScanningAnalysisToolName;
    tool_guid?: CodeScanningAnalysisToolGuid;
    page?: number;
    per_page?: number;
    ref?: CodeScanningRef;
    state?: CodeScanningAlertState;
  }): Promise<CodeScanningAlertItems[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/code-scanning/alerts', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.tool_name !== undefined)
      requestContext.setQueryParam(
        'tool_name',
        r.serializeParameter(params.tool_name),
      );
    if (params.tool_guid !== undefined)
      requestContext.setQueryParam(
        'tool_guid',
        r.serializeParameter(params.tool_guid),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.ref !== undefined)
      requestContext.setQueryParam('ref', r.serializeParameter(params.ref));
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/code-scanning-alert-items"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codeScanningGetAlert(params: {
    owner: string;
    repo: string;
    alert_number: AlertNumber;
  }): Promise<CodeScanningAlert> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/code-scanning-alert"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codeScanningUpdateAlert(
    params: {
      owner: string;
      repo: string;
      alert_number: AlertNumber;
    },
    body: {
      state: CodeScanningAlertSetState;
      dismissed_reason?: CodeScanningAlertDismissedReason;
    },
  ): Promise<CodeScanningAlert> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/code-scanning-alert"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codeScanningListAlertsInstances(params: {
    owner: string;
    repo: string;
    alert_number: AlertNumber;
    page?: number;
    per_page?: number;
    ref?: CodeScanningRef;
  }): Promise<CodeScanningAlertInstance[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.ref !== undefined)
      requestContext.setQueryParam('ref', r.serializeParameter(params.ref));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/code-scanning-alert-instance"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codeScanningListRecentAnalyses(params: {
    owner: string;
    repo: string;
    tool_name?: CodeScanningAnalysisToolName;
    tool_guid?: CodeScanningAnalysisToolGuid;
    page?: number;
    per_page?: number;
    ref?: CodeScanningRef;
    sarif_id?: CodeScanningAnalysisSarifId;
  }): Promise<CodeScanningAnalysis[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/code-scanning/analyses', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.tool_name !== undefined)
      requestContext.setQueryParam(
        'tool_name',
        r.serializeParameter(params.tool_name),
      );
    if (params.tool_guid !== undefined)
      requestContext.setQueryParam(
        'tool_guid',
        r.serializeParameter(params.tool_guid),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.ref !== undefined)
      requestContext.setQueryParam('ref', r.serializeParameter(params.ref));
    if (params.sarif_id !== undefined)
      requestContext.setQueryParam(
        'sarif_id',
        r.serializeParameter(params.sarif_id),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/code-scanning-analysis"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codeScanningGetAnalysis(params: {
    owner: string;
    repo: string;
    analysis_id: number;
  }): Promise<CodeScanningAnalysis> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/code-scanning-analysis"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codeScanningDeleteAnalysis(params: {
    owner: string;
    repo: string;
    analysis_id: number;
    confirm_delete?: string | null;
  }): Promise<CodeScanningAnalysisDeletion> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.confirm_delete !== undefined)
      requestContext.setQueryParam(
        'confirm_delete',
        r.serializeParameter(params.confirm_delete),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/code-scanning-analysis-deletion"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('400', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codeScanningUploadSarif(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      commit_sha: CodeScanningAnalysisCommitSha;
      ref: CodeScanningRef;
      sarif: CodeScanningAnalysisSarifFile;
      checkout_uri?: string;
      started_at?: Date;
      tool_name?: string;
    },
  ): Promise<CodeScanningSarifsReceipt> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/code-scanning/sarifs', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('202', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/code-scanning-sarifs-receipt"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('400', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('413', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codeScanningGetSarif(params: {
    owner: string;
    repo: string;
    sarif_id: string;
  }): Promise<CodeScanningSarifsStatus> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/code-scanning-sarifs-status"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListCollaborators(params: {
    owner: string;
    repo: string;
    affiliation?: 'outside' | 'direct' | 'all';
    per_page?: number;
    page?: number;
  }): Promise<Collaborator[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/collaborators', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.affiliation !== undefined)
      requestContext.setQueryParam(
        'affiliation',
        r.serializeParameter(params.affiliation),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/collaborator"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCheckCollaborator(params: {
    owner: string;
    repo: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/collaborators/{username}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposAddCollaborator(
    params: {
      owner: string;
      repo: string;
      username: string;
    },
    body: {
      permission?: 'pull' | 'push' | 'admin' | 'maintain' | 'triage';
      permissions?: string;
    },
  ): Promise<RepositoryInvitation> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/collaborators/{username}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/repository-invitation"}'),
        this.resolver,
      );
    if (r.isCodeInRange('204', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposRemoveCollaborator(params: {
    owner: string;
    repo: string;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/collaborators/{username}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetCollaboratorPermissionLevel(params: {
    owner: string;
    repo: string;
    username: string;
  }): Promise<RepositoryCollaboratorPermission> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/collaborators/{username}/permission',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/repository-collaborator-permission"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListCommitCommentsForRepo(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<CommitComment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/comments', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/commit-comment"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetCommitComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
  }): Promise<CommitComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/comments/{comment_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/commit-comment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdateCommitComment(
    params: {
      owner: string;
      repo: string;
      comment_id: number;
    },
    body: {
      body: string;
    },
  ): Promise<CommitComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/comments/{comment_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/commit-comment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteCommitComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/comments/{comment_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsListForCommitComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
    content?:
      | '+1'
      | '-1'
      | 'laugh'
      | 'confused'
      | 'heart'
      | 'hooray'
      | 'rocket'
      | 'eyes';
    per_page?: number;
    page?: number;
  }): Promise<Reaction[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/comments/{comment_id}/reactions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.content !== undefined)
      requestContext.setQueryParam(
        'content',
        r.serializeParameter(params.content),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/reaction"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsCreateForCommitComment(
    params: {
      owner: string;
      repo: string;
      comment_id: number;
    },
    body: {
      content:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
    },
  ): Promise<Reaction> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/comments/{comment_id}/reactions',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
        this.resolver,
      );
    if (r.isCodeInRange('201', response.httpStatusCode))
      throw new r.ApiException<Reaction>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsDeleteForCommitComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
    reaction_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListCommits(params: {
    owner: string;
    repo: string;
    sha?: string;
    path?: string;
    author?: string;
    since?: string;
    until?: string;
    per_page?: number;
    page?: number;
    top?: string;
    last_sha?: string;
  }): Promise<Commit[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/commits', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.sha !== undefined)
      requestContext.setQueryParam('sha', r.serializeParameter(params.sha));
    if (params.path !== undefined)
      requestContext.setQueryParam('path', r.serializeParameter(params.path));
    if (params.author !== undefined)
      requestContext.setQueryParam(
        'author',
        r.serializeParameter(params.author),
      );
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.until !== undefined)
      requestContext.setQueryParam('until', r.serializeParameter(params.until));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.top !== undefined)
      requestContext.setQueryParam('top', r.serializeParameter(params.top));
    if (params.last_sha !== undefined)
      requestContext.setQueryParam(
        'last_sha',
        r.serializeParameter(params.last_sha),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/commit"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('400', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('500', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListBranchesForHeadCommit(params: {
    owner: string;
    repo: string;
    commit_sha: string;
  }): Promise<BranchShort[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/branch-short"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListCommentsForCommit(params: {
    owner: string;
    repo: string;
    commit_sha: string;
    per_page?: number;
    page?: number;
  }): Promise<CommitComment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/commits/{commit_sha}/comments',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/commit-comment"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateCommitComment(
    params: {
      owner: string;
      repo: string;
      commit_sha: string;
    },
    body: {
      body: string;
      path?: string;
      position?: number;
      line?: number;
    },
  ): Promise<CommitComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/commits/{commit_sha}/comments',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/commit-comment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListPullRequestsAssociatedWithCommit(params: {
    owner: string;
    repo: string;
    commit_sha: string;
    per_page?: number;
    page?: number;
  }): Promise<PullRequestSimple[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/commits/{commit_sha}/pulls',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/pull-request-simple"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetCommit(params: {
    owner: string;
    repo: string;
    page?: number;
    per_page?: number;
    ref: string;
  }): Promise<Commit> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/commits/{ref}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/commit"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('500', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksListForRef(params: {
    owner: string;
    repo: string;
    ref: string;
    check_name?: string;
    status?: 'queued' | 'in_progress' | 'completed';
    filter?: 'latest' | 'all';
    per_page?: number;
    page?: number;
    app_id?: number;
  }): Promise<{
    total_count: number;
    check_runs: CheckRun[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/commits/{ref}/check-runs',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.check_name !== undefined)
      requestContext.setQueryParam(
        'check_name',
        r.serializeParameter(params.check_name),
      );
    if (params.status !== undefined)
      requestContext.setQueryParam(
        'status',
        r.serializeParameter(params.status),
      );
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.app_id !== undefined)
      requestContext.setQueryParam(
        'app_id',
        r.serializeParameter(params.app_id),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","check_runs"],"properties":{"total_count":{"type":"integer"},"check_runs":{"type":"array","items":{"$ref":"#/components/schemas/check-run"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async checksListSuitesForRef(params: {
    owner: string;
    repo: string;
    ref: string;
    app_id?: number;
    check_name?: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    check_suites: CheckSuite[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/commits/{ref}/check-suites',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.app_id !== undefined)
      requestContext.setQueryParam(
        'app_id',
        r.serializeParameter(params.app_id),
      );
    if (params.check_name !== undefined)
      requestContext.setQueryParam(
        'check_name',
        r.serializeParameter(params.check_name),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","check_suites"],"properties":{"total_count":{"type":"integer"},"check_suites":{"type":"array","items":{"$ref":"#/components/schemas/check-suite"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetCombinedStatusForRef(params: {
    owner: string;
    repo: string;
    ref: string;
    per_page?: number;
    page?: number;
  }): Promise<CombinedCommitStatus> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/commits/{ref}/status', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/combined-commit-status"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListCommitStatusesForRef(params: {
    owner: string;
    repo: string;
    ref: string;
    per_page?: number;
    page?: number;
  }): Promise<Status[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/commits/{ref}/statuses', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/status"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('301', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async codesOfConductGetForRepo(params: {
    owner: string;
    repo: string;
  }): Promise<CodeOfConduct> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/community/code_of_conduct',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/code-of-conduct"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetCommunityProfileMetrics(params: {
    owner: string;
    repo: string;
  }): Promise<CommunityProfile> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/community/profile', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/community-profile"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCompareCommits(params: {
    owner: string;
    repo: string;
    base: string;
    head: string;
  }): Promise<CommitComparison> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/compare/{base}...{head}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/commit-comparison"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('500', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetContent(params: {
    owner: string;
    repo: string;
    path: string;
    ref?: string;
  }): Promise<
    ContentDirectory | ContentFile | ContentSymlink | ContentSubmodule
  > {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/contents/{path}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.ref !== undefined)
      requestContext.setQueryParam('ref', r.serializeParameter(params.ref));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"oneOf":[{"$ref":"#/components/schemas/content-directory"},{"$ref":"#/components/schemas/content-file"},{"$ref":"#/components/schemas/content-symlink"},{"$ref":"#/components/schemas/content-submodule"}]}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateOrUpdateFileContents(
    params: {
      owner: string;
      repo: string;
      path: string;
    },
    body: {
      message: string;
      content: string;
      sha?: string;
      branch?: string;
      committer?: {
        name: string;
        email: string;
        date?: string;
      };
      author?: {
        name: string;
        email: string;
        date?: string;
      };
    },
  ): Promise<FileCommit> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/contents/{path}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/file-commit"}'),
        this.resolver,
      );
    if (r.isCodeInRange('201', response.httpStatusCode))
      throw new r.ApiException<FileCommit>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/file-commit"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteFile(
    params: {
      owner: string;
      repo: string;
      path: string;
    },
    body: {
      message: string;
      sha: string;
      branch?: string;
      committer?: {
        name?: string;
        email?: string;
      };
      author?: {
        name?: string;
        email?: string;
      };
    },
  ): Promise<FileCommit> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/contents/{path}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/file-commit"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListContributors(params: {
    owner: string;
    repo: string;
    anon?: string;
    per_page?: number;
    page?: number;
  }): Promise<Contributor[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/contributors', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.anon !== undefined)
      requestContext.setQueryParam('anon', r.serializeParameter(params.anon));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/contributor"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('204', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListDeployments(params: {
    owner: string;
    repo: string;
    sha?: string;
    ref?: string;
    task?: string;
    environment?: string | null;
    per_page?: number;
    page?: number;
  }): Promise<Deployment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/deployments', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.sha !== undefined)
      requestContext.setQueryParam('sha', r.serializeParameter(params.sha));
    if (params.ref !== undefined)
      requestContext.setQueryParam('ref', r.serializeParameter(params.ref));
    if (params.task !== undefined)
      requestContext.setQueryParam('task', r.serializeParameter(params.task));
    if (params.environment !== undefined)
      requestContext.setQueryParam(
        'environment',
        r.serializeParameter(params.environment),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/deployment"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateDeployment(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      ref: string;
      task?: string;
      auto_merge?: boolean;
      required_contexts?: string[];
      payload?:
        | {
            [key: string]: any;
          }
        | string;
      environment?: string;
      description?: string | null;
      transient_environment?: boolean;
      production_environment?: boolean;
      created_at?: string;
    },
  ): Promise<Deployment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/deployments', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/deployment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('202', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string","example":"\\"https://docs.github.com/rest/reference/repos#create-a-deployment\\""}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetDeployment(params: {
    owner: string;
    repo: string;
    deployment_id: number;
  }): Promise<Deployment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/deployments/{deployment_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/deployment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteDeployment(params: {
    owner: string;
    repo: string;
    deployment_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/deployments/{deployment_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListDeploymentStatuses(params: {
    owner: string;
    repo: string;
    deployment_id: number;
    per_page?: number;
    page?: number;
  }): Promise<DeploymentStatus[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/deployments/{deployment_id}/statuses',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/deployment-status"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateDeploymentStatus(
    params: {
      owner: string;
      repo: string;
      deployment_id: number;
    },
    body: {
      state:
        | 'error'
        | 'failure'
        | 'inactive'
        | 'in_progress'
        | 'queued'
        | 'pending'
        | 'success';
      target_url?: string;
      log_url?: string;
      description?: string;
      environment?: 'production' | 'staging' | 'qa';
      environment_url?: string;
      auto_inactive?: boolean;
    },
  ): Promise<DeploymentStatus> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/deployments/{deployment_id}/statuses',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/deployment-status"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetDeploymentStatus(params: {
    owner: string;
    repo: string;
    deployment_id: number;
    status_id: number;
  }): Promise<DeploymentStatus> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/deployment-status"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateDispatchEvent(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      event_type: string;
      client_payload?: {
        [key: string]: any;
      };
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/dispatches', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetAllEnvironments(params: {
    owner: string;
    repo: string;
  }): Promise<{
    total_count?: number;
    environments?: Environment[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/environments', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{"total_count":{"description":"The number of environments in this repository","example":5,"type":"integer"},"environments":{"type":"array","items":{"$ref":"#/components/schemas/environment"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetEnvironment(params: {
    owner: string;
    repo: string;
    environment_name: string;
  }): Promise<Environment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/environments/{environment_name}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/environment"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateOrUpdateEnvironment(
    params: {
      owner: string;
      repo: string;
      environment_name: string;
    },
    body: {
      wait_timer?: WaitTimer;
      reviewers?:
        | {
            type?: DeploymentReviewerType;
            id?: number;
          }[]
        | null;
      deployment_branch_policy?: Deployment_branch_policy;
    } | null,
  ): Promise<Environment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/environments/{environment_name}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/environment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteAnEnvironment(params: {
    owner: string;
    repo: string;
    environment_name: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/environments/{environment_name}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListRepoEvents(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<Event[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/events', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/event"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListForks(params: {
    owner: string;
    repo: string;
    sort?: 'newest' | 'oldest' | 'stargazers' | 'watchers';
    per_page?: number;
    page?: number;
    org?: string;
    organization?: string;
  }): Promise<MinimalRepository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/forks', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.org !== undefined)
      requestContext.setQueryParam('org', r.serializeParameter(params.org));
    if (params.organization !== undefined)
      requestContext.setQueryParam(
        'organization',
        r.serializeParameter(params.organization),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('400', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateFork(
    params: {
      owner: string;
      repo: string;
      org?: string;
      organization?: string;
    },
    body: {
      organization?: string;
    } | null,
  ): Promise<Repository> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/forks', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.org !== undefined)
      requestContext.setQueryParam('org', r.serializeParameter(params.org));
    if (params.organization !== undefined)
      requestContext.setQueryParam(
        'organization',
        r.serializeParameter(params.organization),
      );
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('202', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/repository"}'),
        this.resolver,
      );
    if (r.isCodeInRange('400', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitCreateBlob(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      content: string;
      encoding?: string;
    },
  ): Promise<ShortBlob> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/blobs', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/short-blob"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitGetBlob(params: {
    owner: string;
    repo: string;
    file_sha: string;
  }): Promise<Blob> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/blobs/{file_sha}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/blob"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitCreateCommit(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      message: string;
      tree: string;
      parents?: string[];
      author?: {
        name?: string;
        email?: string;
        date?: string;
      };
      committer?: {
        name?: string;
        email?: string;
        date?: string;
      };
      signature?: string;
    },
  ): Promise<GitCommit> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/commits', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/git-commit"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitGetCommit(params: {
    owner: string;
    repo: string;
    commit_sha: string;
  }): Promise<GitCommit> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/git/commits/{commit_sha}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/git-commit"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitListMatchingRefs(params: {
    owner: string;
    repo: string;
    ref: string;
    per_page?: number;
    page?: number;
  }): Promise<GitRef[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/git/matching-refs/{ref}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/git-ref"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitGetRef(params: {
    owner: string;
    repo: string;
    ref: string;
  }): Promise<GitRef> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/ref/{ref}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/git-ref"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitCreateRef(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      ref: string;
      sha: string;
      key?: string;
    },
  ): Promise<GitRef> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/refs', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/git-ref"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitUpdateRef(
    params: {
      owner: string;
      repo: string;
      ref: string;
    },
    body: {
      sha: string;
      force?: boolean;
    },
  ): Promise<GitRef> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/refs/{ref}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/git-ref"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitDeleteRef(params: {
    owner: string;
    repo: string;
    ref: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/refs/{ref}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitCreateTag(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      tag: string;
      message: string;
      object: string;
      type: 'commit' | 'tree' | 'blob';
      tagger?: {
        name?: string;
        email?: string;
        date?: string;
      };
    },
  ): Promise<GitTag> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/tags', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/git-tag"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitGetTag(params: {
    owner: string;
    repo: string;
    tag_sha: string;
  }): Promise<GitTag> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/tags/{tag_sha}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/git-tag"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitCreateTree(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      tree: {
        path?: string;
        mode?: '100644' | '100755' | '040000' | '160000' | '120000';
        type?: 'blob' | 'tree' | 'commit';
        sha?: string | null;
        content?: string;
      }[];
      base_tree?: string;
    },
  ): Promise<GitTree> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/trees', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/git-tree"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gitGetTree(params: {
    owner: string;
    repo: string;
    tree_sha: string;
    recursive?: string;
  }): Promise<GitTree> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/git/trees/{tree_sha}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.recursive !== undefined)
      requestContext.setQueryParam(
        'recursive',
        r.serializeParameter(params.recursive),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/git-tree"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListWebhooks(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<Hook[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/hooks', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/hook"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateWebhook(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      name?: string;
      config: {
        url: WebhookConfigUrl;
        content_type?: WebhookConfigContentType;
        secret?: WebhookConfigSecret;
        insecure_ssl?: WebhookConfigInsecureSsl;
        token?: string;
        digest?: string;
      };
      events?: string[];
      active?: boolean;
    },
  ): Promise<Hook> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/hooks', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/hook"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetWebhook(params: {
    owner: string;
    repo: string;
    hook_id: number;
  }): Promise<Hook> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/hooks/{hook_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/hook"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdateWebhook(
    params: {
      owner: string;
      repo: string;
      hook_id: number;
    },
    body: {
      config?: {
        url: WebhookConfigUrl;
        content_type?: WebhookConfigContentType;
        secret?: WebhookConfigSecret;
        insecure_ssl?: WebhookConfigInsecureSsl;
        address?: string;
        room?: string;
      };
      events?: string[];
      add_events?: string[];
      remove_events?: string[];
      active?: boolean;
    },
  ): Promise<Hook> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/hooks/{hook_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/hook"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteWebhook(params: {
    owner: string;
    repo: string;
    hook_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/hooks/{hook_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetWebhookConfigForRepo(params: {
    owner: string;
    repo: string;
    hook_id: number;
  }): Promise<WebhookConfig> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/hooks/{hook_id}/config', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/webhook-config"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdateWebhookConfigForRepo(
    params: {
      owner: string;
      repo: string;
      hook_id: number;
    },
    body: {
      url?: WebhookConfigUrl;
      content_type?: WebhookConfigContentType;
      secret?: WebhookConfigSecret;
      insecure_ssl?: WebhookConfigInsecureSsl;
    },
  ): Promise<WebhookConfig> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/hooks/{hook_id}/config', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/webhook-config"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposPingWebhook(params: {
    owner: string;
    repo: string;
    hook_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/hooks/{hook_id}/pings', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposTestPushWebhook(params: {
    owner: string;
    repo: string;
    hook_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/hooks/{hook_id}/tests', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsGetImportStatus(params: {
    owner: string;
    repo: string;
  }): Promise<Import> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/import', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/import"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsStartImport(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      vcs_url: string;
      vcs?: 'subversion' | 'git' | 'mercurial' | 'tfvc';
      vcs_username?: string;
      vcs_password?: string;
      tfvc_project?: string;
    },
  ): Promise<Import> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/import', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/import"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsUpdateImport(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      vcs_username?: string;
      vcs_password?: string;
      vcs?: string;
      tfvc_project?: string;
    },
  ): Promise<Import> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/import', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/import"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsCancelImport(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/import', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsGetCommitAuthors(params: {
    owner: string;
    repo: string;
    since?: number;
  }): Promise<PorterAuthor[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/import/authors', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/porter-author"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsMapCommitAuthor(
    params: {
      owner: string;
      repo: string;
      author_id: number;
    },
    body: {
      email?: string;
      name?: string;
      remote_id?: string;
    },
  ): Promise<PorterAuthor> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/import/authors/{author_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/porter-author"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsGetLargeFiles(params: {
    owner: string;
    repo: string;
  }): Promise<PorterLargeFile[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/import/large_files', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/porter-large-file"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsSetLfsPreference(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      use_lfs: 'opt_in' | 'opt_out';
    },
  ): Promise<Import> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/import/lfs', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/import"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsGetRepoInstallation(params: {
    owner: string;
    repo: string;
  }): Promise<Installation> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/installation', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/installation"}'),
        this.resolver,
      );
    if (r.isCodeInRange('301', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async interactionsGetRestrictionsForRepo(params: {
    owner: string;
    repo: string;
  }): Promise<InteractionLimitResponse> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/interaction-limits', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/interaction-limit-response"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async interactionsSetRestrictionsForRepo(
    params: {
      owner: string;
      repo: string;
    },
    body: InteractionLimit,
  ): Promise<InteractionLimitResponse> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/interaction-limits', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/interaction-limit-response"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async interactionsRemoveRestrictionsForRepo(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/interaction-limits', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListInvitations(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<RepositoryInvitation[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/invitations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/repository-invitation"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdateInvitation(
    params: {
      owner: string;
      repo: string;
      invitation_id: number;
    },
    body: {
      permissions?: 'read' | 'write' | 'maintain' | 'triage' | 'admin';
    },
  ): Promise<RepositoryInvitation> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/invitations/{invitation_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/repository-invitation"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteInvitation(params: {
    owner: string;
    repo: string;
    invitation_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/invitations/{invitation_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListForRepo(params: {
    owner: string;
    repo: string;
    milestone?: string;
    state?: 'open' | 'closed' | 'all';
    assignee?: string;
    creator?: string;
    mentioned?: string;
    labels?: string;
    sort?: 'created' | 'updated' | 'comments';
    direction?: 'asc' | 'desc';
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<IssueSimple[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/issues', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.milestone !== undefined)
      requestContext.setQueryParam(
        'milestone',
        r.serializeParameter(params.milestone),
      );
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.assignee !== undefined)
      requestContext.setQueryParam(
        'assignee',
        r.serializeParameter(params.assignee),
      );
    if (params.creator !== undefined)
      requestContext.setQueryParam(
        'creator',
        r.serializeParameter(params.creator),
      );
    if (params.mentioned !== undefined)
      requestContext.setQueryParam(
        'mentioned',
        r.serializeParameter(params.mentioned),
      );
    if (params.labels !== undefined)
      requestContext.setQueryParam(
        'labels',
        r.serializeParameter(params.labels),
      );
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/issue-simple"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('301', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesCreate(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      title: string | number;
      body?: string;
      assignee?: string | null;
      milestone?: (string | number) | null;
      labels?: (
        | string
        | {
            id?: number;
            name?: string;
            description?: string | null;
            color?: string | null;
          }
      )[];
      assignees?: string[];
    },
  ): Promise<Issue> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/issues', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/issue"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListCommentsForRepo(params: {
    owner: string;
    repo: string;
    sort?: 'created' | 'updated';
    direction?: 'asc' | 'desc';
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<IssueComment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/issues/comments', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/issue-comment"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesGetComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
  }): Promise<IssueComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/comments/{comment_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/issue-comment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesUpdateComment(
    params: {
      owner: string;
      repo: string;
      comment_id: number;
    },
    body: {
      body: string;
    },
  ): Promise<IssueComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/comments/{comment_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/issue-comment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesDeleteComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/comments/{comment_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsListForIssueComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
    content?:
      | '+1'
      | '-1'
      | 'laugh'
      | 'confused'
      | 'heart'
      | 'hooray'
      | 'rocket'
      | 'eyes';
    per_page?: number;
    page?: number;
  }): Promise<Reaction[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.content !== undefined)
      requestContext.setQueryParam(
        'content',
        r.serializeParameter(params.content),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/reaction"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsCreateForIssueComment(
    params: {
      owner: string;
      repo: string;
      comment_id: number;
    },
    body: {
      content:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
    },
  ): Promise<Reaction> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
        this.resolver,
      );
    if (r.isCodeInRange('201', response.httpStatusCode))
      throw new r.ApiException<Reaction>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsDeleteForIssueComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
    reaction_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListEventsForRepo(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<IssueEvent[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/issues/events', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/issue-event"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesGetEvent(params: {
    owner: string;
    repo: string;
    event_id: number;
  }): Promise<IssueEvent> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/events/{event_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/issue-event"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesGet(params: {
    owner: string;
    repo: string;
    issue_number: number;
  }): Promise<Issue> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/issues/{issue_number}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/issue"}'),
        this.resolver,
      );
    if (r.isCodeInRange('301', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesUpdate(
    params: {
      owner: string;
      repo: string;
      issue_number: number;
    },
    body: {
      title?: (string | number) | null;
      body?: string | null;
      assignee?: string | null;
      state?: 'open' | 'closed';
      milestone?: (string | number) | null;
      labels?: (
        | string
        | {
            id?: number;
            name?: string;
            description?: string | null;
            color?: string | null;
          }
      )[];
      assignees?: string[];
    },
  ): Promise<Issue> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/issues/{issue_number}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/issue"}'),
        this.resolver,
      );
    if (r.isCodeInRange('301', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesAddAssignees(
    params: {
      owner: string;
      repo: string;
      issue_number: number;
    },
    body: {
      assignees?: string[];
    },
  ): Promise<IssueSimple> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/assignees',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/issue-simple"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesRemoveAssignees(
    params: {
      owner: string;
      repo: string;
      issue_number: number;
    },
    body: {
      assignees?: string[];
    },
  ): Promise<IssueSimple> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/assignees',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/issue-simple"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListComments(params: {
    owner: string;
    repo: string;
    issue_number: number;
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<IssueComment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/comments',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/issue-comment"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesCreateComment(
    params: {
      owner: string;
      repo: string;
      issue_number: number;
    },
    body: {
      body: string;
    },
  ): Promise<IssueComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/comments',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/issue-comment"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListEvents(params: {
    owner: string;
    repo: string;
    issue_number: number;
    per_page?: number;
    page?: number;
  }): Promise<IssueEventForIssue[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/events',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/issue-event-for-issue"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListLabelsOnIssue(params: {
    owner: string;
    repo: string;
    issue_number: number;
    per_page?: number;
    page?: number;
  }): Promise<Label[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/labels',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/label"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesAddLabels(
    params: {
      owner: string;
      repo: string;
      issue_number: number;
    },
    body: {
      labels: string[];
    },
  ): Promise<Label[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/labels',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/label"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesSetLabels(
    params: {
      owner: string;
      repo: string;
      issue_number: number;
    },
    body: {
      labels?: string[];
    },
  ): Promise<Label[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/labels',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/label"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesRemoveAllLabels(params: {
    owner: string;
    repo: string;
    issue_number: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/labels',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesRemoveLabel(params: {
    owner: string;
    repo: string;
    issue_number: number;
    name: string;
  }): Promise<Label[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/label"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesLock(
    params: {
      owner: string;
      repo: string;
      issue_number: number;
    },
    body: {
      lock_reason?: 'off-topic' | 'too heated' | 'resolved' | 'spam';
    } | null,
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/lock',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesUnlock(params: {
    owner: string;
    repo: string;
    issue_number: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/lock',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsListForIssue(params: {
    owner: string;
    repo: string;
    issue_number: number;
    content?:
      | '+1'
      | '-1'
      | 'laugh'
      | 'confused'
      | 'heart'
      | 'hooray'
      | 'rocket'
      | 'eyes';
    per_page?: number;
    page?: number;
  }): Promise<Reaction[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/reactions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.content !== undefined)
      requestContext.setQueryParam(
        'content',
        r.serializeParameter(params.content),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/reaction"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsCreateForIssue(
    params: {
      owner: string;
      repo: string;
      issue_number: number;
    },
    body: {
      content:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
    },
  ): Promise<Reaction> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/reactions',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
        this.resolver,
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsDeleteForIssue(params: {
    owner: string;
    repo: string;
    issue_number: number;
    reaction_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListEventsForTimeline(params: {
    owner: string;
    repo: string;
    issue_number: number;
    per_page?: number;
    page?: number;
  }): Promise<IssueEventForIssue[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/issues/{issue_number}/timeline',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/issue-event-for-issue"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListDeployKeys(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<DeployKey[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/keys', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/deploy-key"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateDeployKey(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      title?: string;
      key: string;
      read_only?: boolean;
    },
  ): Promise<DeployKey> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/keys', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/deploy-key"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetDeployKey(params: {
    owner: string;
    repo: string;
    key_id: number;
  }): Promise<DeployKey> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/keys/{key_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/deploy-key"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteDeployKey(params: {
    owner: string;
    repo: string;
    key_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/keys/{key_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListLabelsForRepo(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<Label[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/labels', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/label"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesCreateLabel(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      name: string;
      color?: string;
      description?: string;
    },
  ): Promise<Label> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/labels', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/label"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesGetLabel(params: {
    owner: string;
    repo: string;
    name: string;
  }): Promise<Label> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/labels/{name}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/label"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesUpdateLabel(
    params: {
      owner: string;
      repo: string;
      name: string;
    },
    body: {
      new_name?: string;
      color?: string;
      description?: string;
    },
  ): Promise<Label> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/labels/{name}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/label"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesDeleteLabel(params: {
    owner: string;
    repo: string;
    name: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/labels/{name}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListLanguages(params: {
    owner: string;
    repo: string;
  }): Promise<Language> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/languages', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/language"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async licensesGetForRepo(params: {
    owner: string;
    repo: string;
  }): Promise<LicenseContent> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/license', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/license-content"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposMerge(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      base: string;
      head: string;
      commit_message?: string;
    },
  ): Promise<Commit> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/merges', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/commit"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string","example":"\\"https://docs.github.com/rest/reference/repos#perform-a-merge\\""}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string","example":"\\"https://docs.github.com/rest/reference/repos#perform-a-merge\\""}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListMilestones(params: {
    owner: string;
    repo: string;
    state?: 'open' | 'closed' | 'all';
    sort?: 'due_on' | 'completeness';
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<Milestone[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/milestones', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/milestone"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesCreateMilestone(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      title: string;
      state?: 'open' | 'closed';
      description?: string;
      due_on?: string;
    },
  ): Promise<Milestone> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/milestones', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/milestone"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesGetMilestone(params: {
    owner: string;
    repo: string;
    milestone_number: number;
  }): Promise<Milestone> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/milestones/{milestone_number}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/milestone"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesUpdateMilestone(
    params: {
      owner: string;
      repo: string;
      milestone_number: number;
    },
    body: {
      title?: string;
      state?: 'open' | 'closed';
      description?: string;
      due_on?: string;
    },
  ): Promise<Milestone> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/milestones/{milestone_number}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/milestone"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesDeleteMilestone(params: {
    owner: string;
    repo: string;
    milestone_number: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/milestones/{milestone_number}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListLabelsForMilestone(params: {
    owner: string;
    repo: string;
    milestone_number: number;
    per_page?: number;
    page?: number;
  }): Promise<Label[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/milestones/{milestone_number}/labels',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/label"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListRepoNotificationsForAuthenticatedUser(params: {
    owner: string;
    repo: string;
    all?: boolean;
    participating?: boolean;
    since?: string;
    before?: string;
    per_page?: number;
    page?: number;
  }): Promise<Thread[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/notifications', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.all !== undefined)
      requestContext.setQueryParam('all', r.serializeParameter(params.all));
    if (params.participating !== undefined)
      requestContext.setQueryParam(
        'participating',
        r.serializeParameter(params.participating),
      );
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.before !== undefined)
      requestContext.setQueryParam(
        'before',
        r.serializeParameter(params.before),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/thread"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityMarkRepoNotificationsAsRead(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      last_read_at?: string;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/notifications', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('202', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetPages(params: { owner: string; repo: string }): Promise<Page> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pages', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/page"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreatePagesSite(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      source: {
        branch: string;
        path?: '/' | '/docs';
      };
    },
  ): Promise<Page> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pages', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/page"}'),
        this.resolver,
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdateInformationAboutPagesSite(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      cname?: string | null;
      public?: boolean;
      source:
        | ('gh-pages' | 'master' | 'master /docs')
        | {
            branch: string;
            path: '/' | '/docs';
          };
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pages', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('400', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeletePagesSite(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pages', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListPagesBuilds(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<PageBuild[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pages/builds', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/page-build"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposRequestPagesBuild(params: {
    owner: string;
    repo: string;
  }): Promise<PageBuildStatus> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pages/builds', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/page-build-status"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetLatestPagesBuild(params: {
    owner: string;
    repo: string;
  }): Promise<PageBuild> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pages/builds/latest', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/page-build"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetPagesBuild(params: {
    owner: string;
    repo: string;
    build_id: number;
  }): Promise<PageBuild> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pages/builds/{build_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/page-build"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsListForRepo(params: {
    owner: string;
    repo: string;
    state?: 'open' | 'closed' | 'all';
    per_page?: number;
    page?: number;
  }): Promise<Project[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/projects', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/project"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsCreateForRepo(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      name: string;
      body?: string;
    },
  ): Promise<Project> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/projects', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project"}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('410', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsList(params: {
    owner: string;
    repo: string;
    state?: 'open' | 'closed' | 'all';
    head?: string;
    base?: string;
    sort?: 'created' | 'updated' | 'popularity' | 'long-running';
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<PullRequestSimple[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pulls', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.head !== undefined)
      requestContext.setQueryParam('head', r.serializeParameter(params.head));
    if (params.base !== undefined)
      requestContext.setQueryParam('base', r.serializeParameter(params.base));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/pull-request-simple"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsCreate(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      title?: string;
      head: string;
      base: string;
      body?: string;
      maintainer_can_modify?: boolean;
      draft?: boolean;
      issue?: number;
    },
  ): Promise<PullRequest> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pulls', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsListReviewCommentsForRepo(params: {
    owner: string;
    repo: string;
    sort?: 'created' | 'updated' | 'created_at';
    direction?: 'asc' | 'desc';
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<PullRequestReviewComment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pulls/comments', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/pull-request-review-comment"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsGetReviewComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
  }): Promise<PullRequestReviewComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/comments/{comment_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/pull-request-review-comment"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsUpdateReviewComment(
    params: {
      owner: string;
      repo: string;
      comment_id: number;
    },
    body: {
      body: string;
    },
  ): Promise<PullRequestReviewComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/comments/{comment_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/pull-request-review-comment"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsDeleteReviewComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/comments/{comment_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsListForPullRequestReviewComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
    content?:
      | '+1'
      | '-1'
      | 'laugh'
      | 'confused'
      | 'heart'
      | 'hooray'
      | 'rocket'
      | 'eyes';
    per_page?: number;
    page?: number;
  }): Promise<Reaction[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.content !== undefined)
      requestContext.setQueryParam(
        'content',
        r.serializeParameter(params.content),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/reaction"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsCreateForPullRequestReviewComment(
    params: {
      owner: string;
      repo: string;
      comment_id: number;
    },
    body: {
      content:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
    },
  ): Promise<Reaction> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
        this.resolver,
      );
    if (r.isCodeInRange('201', response.httpStatusCode))
      throw new r.ApiException<Reaction>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsDeleteForPullRequestComment(params: {
    owner: string;
    repo: string;
    comment_id: number;
    reaction_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsGet(params: {
    owner: string;
    repo: string;
    pull_number: number;
  }): Promise<PullRequest> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pulls/{pull_number}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('500', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsUpdate(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
    },
    body: {
      title?: string;
      body?: string;
      state?: 'open' | 'closed';
      base?: string;
      maintainer_can_modify?: boolean;
    },
  ): Promise<PullRequest> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/pulls/{pull_number}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsListReviewComments(params: {
    owner: string;
    repo: string;
    pull_number: number;
    sort?: 'created' | 'updated';
    direction?: 'asc' | 'desc';
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<PullRequestReviewComment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/comments',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/pull-request-review-comment"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsCreateReviewComment(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
    },
    body: {
      body: string;
      commit_id?: string;
      path?: string;
      position?: number;
      side?: 'LEFT' | 'RIGHT';
      line?: number;
      start_line?: number;
      start_side?: 'LEFT' | 'RIGHT' | 'side';
      in_reply_to?: number;
    },
  ): Promise<PullRequestReviewComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/comments',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/pull-request-review-comment"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsCreateReplyForReviewComment(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
      comment_id: number;
    },
    body: {
      body: string;
    },
  ): Promise<PullRequestReviewComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/pull-request-review-comment"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsListCommits(params: {
    owner: string;
    repo: string;
    pull_number: number;
    per_page?: number;
    page?: number;
  }): Promise<Commit[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/commits',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/commit"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsListFiles(params: {
    owner: string;
    repo: string;
    pull_number: number;
    per_page?: number;
    page?: number;
  }): Promise<DiffEntry[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/files',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/diff-entry"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('500', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsCheckIfMerged(params: {
    owner: string;
    repo: string;
    pull_number: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/merge',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsMerge(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
    },
    body: {
      commit_title?: string;
      commit_message?: string;
      sha?: string;
      merge_method?: 'merge' | 'squash' | 'rebase';
    } | null,
  ): Promise<PullRequestMergeResult> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/merge',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request-merge-result"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('405', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsListRequestedReviewers(params: {
    owner: string;
    repo: string;
    pull_number: number;
    per_page?: number;
    page?: number;
  }): Promise<PullRequestReviewRequest> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/pull-request-review-request"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsRequestReviewers(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
    },
    body: {
      reviewers?: string[];
      team_reviewers?: string[];
    },
  ): Promise<PullRequestSimple> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request-simple"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsRemoveRequestedReviewers(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
    },
    body: {
      reviewers: string[];
      team_reviewers?: string[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsListReviews(params: {
    owner: string;
    repo: string;
    pull_number: number;
    per_page?: number;
    page?: number;
  }): Promise<PullRequestReview[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/reviews',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/pull-request-review"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsCreateReview(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
    },
    body: {
      commit_id?: string;
      body?: string;
      event?: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
      comments?: {
        path: string;
        position?: number;
        body: string;
        line?: number;
        side?: string;
        start_line?: number;
        start_side?: string;
      }[];
    },
  ): Promise<PullRequestReview> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/reviews',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request-review"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsGetReview(params: {
    owner: string;
    repo: string;
    pull_number: number;
    review_id: number;
  }): Promise<PullRequestReview> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request-review"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsUpdateReview(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
      review_id: number;
    },
    body: {
      body: string;
    },
  ): Promise<PullRequestReview> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request-review"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsDeletePendingReview(params: {
    owner: string;
    repo: string;
    pull_number: number;
    review_id: number;
  }): Promise<PullRequestReview> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request-review"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsListCommentsForReview(params: {
    owner: string;
    repo: string;
    pull_number: number;
    review_id: number;
    per_page?: number;
    page?: number;
  }): Promise<ReviewComment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/review-comment"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsDismissReview(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
      review_id: number;
    },
    body: {
      message: string;
      event?: string;
    },
  ): Promise<PullRequestReview> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request-review"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsSubmitReview(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
      review_id: number;
    },
    body: {
      body?: string;
      event: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
    },
  ): Promise<PullRequestReview> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/pull-request-review"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async pullsUpdateBranch(
    params: {
      owner: string;
      repo: string;
      pull_number: number;
    },
    body: {
      expected_head_sha?: string;
    } | null,
  ): Promise<{
    message?: string;
    url?: string;
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/pulls/{pull_number}/update-branch',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('202', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","properties":{"message":{"type":"string"},"url":{"type":"string"}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetReadme(params: {
    owner: string;
    repo: string;
    ref?: string;
  }): Promise<ContentFile> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/readme', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.ref !== undefined)
      requestContext.setQueryParam('ref', r.serializeParameter(params.ref));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/content-file"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetReadmeFromAltPath(params: {
    owner: string;
    repo: string;
    dir: string;
    ref?: string;
  }): Promise<ContentFile> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/readme/{dir}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.ref !== undefined)
      requestContext.setQueryParam('ref', r.serializeParameter(params.ref));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/content-file"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListReleases(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<Release[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/releases', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/release"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateRelease(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      tag_name: string;
      target_commitish?: string;
      name?: string;
      body?: string;
      draft?: boolean;
      prerelease?: boolean;
    },
  ): Promise<Release> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/releases', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/release"}'),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetReleaseAsset(params: {
    owner: string;
    repo: string;
    asset_id: number;
  }): Promise<ReleaseAsset> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/releases/assets/{asset_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/release-asset"}'),
        this.resolver,
      );
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdateReleaseAsset(
    params: {
      owner: string;
      repo: string;
      asset_id: number;
    },
    body: {
      name?: string;
      label?: string;
      state?: string;
    },
  ): Promise<ReleaseAsset> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/releases/assets/{asset_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/release-asset"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteReleaseAsset(params: {
    owner: string;
    repo: string;
    asset_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/releases/assets/{asset_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetLatestRelease(params: {
    owner: string;
    repo: string;
  }): Promise<Release> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/releases/latest', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/release"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetReleaseByTag(params: {
    owner: string;
    repo: string;
    tag: string;
  }): Promise<Release> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/releases/tags/{tag}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/release"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetRelease(params: {
    owner: string;
    repo: string;
    release_id: number;
  }): Promise<Release> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/releases/{release_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/release"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUpdateRelease(
    params: {
      owner: string;
      repo: string;
      release_id: number;
    },
    body: {
      tag_name?: string;
      target_commitish?: string;
      name?: string;
      body?: string;
      draft?: boolean;
      prerelease?: boolean;
    },
  ): Promise<Release> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/releases/{release_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/release"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeleteRelease(params: {
    owner: string;
    repo: string;
    release_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/releases/{release_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListReleaseAssets(params: {
    owner: string;
    repo: string;
    release_id: number;
    per_page?: number;
    page?: number;
  }): Promise<ReleaseAsset[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/releases/{release_id}/assets',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/release-asset"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposUploadReleaseAsset(
    params: {
      owner: string;
      repo: string;
      release_id: number;
      name?: string;
      label?: string;
    },
    body: any,
  ): Promise<ReleaseAsset> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/releases/{release_id}/assets',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.name !== undefined)
      requestContext.setQueryParam('name', r.serializeParameter(params.name));
    if (params.label !== undefined)
      requestContext.setQueryParam('label', r.serializeParameter(params.label));
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/release-asset"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async secretScanningListAlertsForRepo(params: {
    owner: string;
    repo: string;
    state?: 'open' | 'resolved';
    page?: number;
    per_page?: number;
  }): Promise<SecretScanningAlert[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/secret-scanning/alerts', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/secret-scanning-alert"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async secretScanningGetAlert(params: {
    owner: string;
    repo: string;
    alert_number: AlertNumber;
  }): Promise<SecretScanningAlert> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/secret-scanning-alert"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async secretScanningUpdateAlert(
    params: {
      owner: string;
      repo: string;
      alert_number: AlertNumber;
    },
    body: {
      state: SecretScanningAlertState;
      resolution?: SecretScanningAlertResolution;
    },
  ): Promise<SecretScanningAlert> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/secret-scanning-alert"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListStargazersForRepo(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/stargazers', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetCodeFrequencyStats(params: {
    owner: string;
    repo: string;
  }): Promise<CodeFrequencyStat[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/stats/code_frequency', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/code-frequency-stat"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetCommitActivityStats(params: {
    owner: string;
    repo: string;
  }): Promise<CommitActivity[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/stats/commit_activity', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/commit-activity"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetContributorsStats(params: {
    owner: string;
    repo: string;
  }): Promise<ContributorActivity[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/stats/contributors', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/contributor-activity"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetParticipationStats(params: {
    owner: string;
    repo: string;
  }): Promise<ParticipationStats> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/stats/participation', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/participation-stats"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetPunchCardStats(params: {
    owner: string;
    repo: string;
  }): Promise<CodeFrequencyStat[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/stats/punch_card', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/code-frequency-stat"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateCommitStatus(
    params: {
      owner: string;
      repo: string;
      sha: string;
    },
    body: {
      state: 'error' | 'failure' | 'pending' | 'success';
      target_url?: string;
      description?: string;
      context?: string;
    },
  ): Promise<Status> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/statuses/{sha}', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/status"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListWatchersForRepo(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/subscribers', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityGetRepoSubscription(params: {
    owner: string;
    repo: string;
  }): Promise<RepositorySubscription> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/subscription', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/repository-subscription"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activitySetRepoSubscription(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      subscribed?: boolean;
      ignored?: boolean;
    },
  ): Promise<RepositorySubscription> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/subscription', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/repository-subscription"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityDeleteRepoSubscription(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/subscription', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListTags(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<Tag[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/tags', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/tag"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDownloadTarballArchive(params: {
    owner: string;
    repo: string;
    ref: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/tarball/{ref}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListTeams(params: {
    owner: string;
    repo: string;
    per_page?: number;
    page?: number;
  }): Promise<Team[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/teams', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetAllTopics(params: {
    owner: string;
    repo: string;
    page?: number;
    per_page?: number;
  }): Promise<Topic> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/topics', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/topic"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposReplaceAllTopics(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      names: string[];
    },
  ): Promise<Topic> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/topics', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/topic"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetClones(params: {
    owner: string;
    repo: string;
    per?: '' | 'day' | 'week';
  }): Promise<CloneTraffic> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/traffic/clones', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per !== undefined)
      requestContext.setQueryParam('per', r.serializeParameter(params.per));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/clone-traffic"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetTopPaths(params: {
    owner: string;
    repo: string;
  }): Promise<ContentTraffic[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/traffic/popular/paths', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/content-traffic"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetTopReferrers(params: {
    owner: string;
    repo: string;
  }): Promise<ReferrerTraffic[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{owner}/{repo}/traffic/popular/referrers',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/referrer-traffic"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposGetViews(params: {
    owner: string;
    repo: string;
    per?: '' | 'day' | 'week';
  }): Promise<ViewTraffic> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/traffic/views', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per !== undefined)
      requestContext.setQueryParam('per', r.serializeParameter(params.per));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/view-traffic"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposTransfer(
    params: {
      owner: string;
      repo: string;
    },
    body: {
      new_owner: string;
      team_ids?: number[];
    },
  ): Promise<Repository> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/transfer', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('202', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/repository"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCheckVulnerabilityAlerts(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/vulnerability-alerts', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposEnableVulnerabilityAlerts(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/vulnerability-alerts', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDisableVulnerabilityAlerts(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/vulnerability-alerts', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDownloadZipballArchive(params: {
    owner: string;
    repo: string;
    ref: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repos/{owner}/{repo}/zipball/{ref}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateUsingTemplate(
    params: {
      template_owner: string;
      template_repo: string;
    },
    body: {
      owner?: string;
      name: string;
      description?: string;
      include_all_branches?: boolean;
      private?: boolean;
    },
  ): Promise<Repository> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repos/{template_owner}/{template_repo}/generate',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/repository"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListPublic(params: {
    since?: number;
  }): Promise<MinimalRepository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/repositories', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsListEnvironmentSecrets(params: {
    repository_id: number;
    environment_name: string;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    secrets: ActionsSecret[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repositories/{repository_id}/environments/{environment_name}/secrets',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","secrets"],"properties":{"total_count":{"type":"integer"},"secrets":{"type":"array","items":{"$ref":"#/components/schemas/actions-secret"}}}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetEnvironmentPublicKey(params: {
    repository_id: number;
    environment_name: string;
  }): Promise<ActionsPublicKey> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repositories/{repository_id}/environments/{environment_name}/secrets/public-key',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/actions-public-key"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsGetEnvironmentSecret(params: {
    repository_id: number;
    environment_name: string;
    secret_name: string;
  }): Promise<ActionsSecret> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/actions-secret"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsCreateOrUpdateEnvironmentSecret(
    params: {
      repository_id: number;
      environment_name: string;
      secret_name: string;
    },
    body: {
      encrypted_value?: string;
      key_id?: string;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('204', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async actionsDeleteEnvironmentSecret(params: {
    repository_id: number;
    environment_name: string;
    secret_name: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminListProvisionedGroupsEnterprise(params: {
    enterprise: string;
    startIndex?: number;
    count?: number;
    filter?: string;
    excludedAttributes?: string;
  }): Promise<ScimGroupListEnterprise> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/scim/v2/enterprises/{enterprise}/Groups', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.startIndex !== undefined)
      requestContext.setQueryParam(
        'startIndex',
        r.serializeParameter(params.startIndex),
      );
    if (params.count !== undefined)
      requestContext.setQueryParam('count', r.serializeParameter(params.count));
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    if (params.excludedAttributes !== undefined)
      requestContext.setQueryParam(
        'excludedAttributes',
        r.serializeParameter(params.excludedAttributes),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/scim-group-list-enterprise"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminProvisionAndInviteEnterpriseGroup(
    params: {
      enterprise: string;
    },
    body: {
      schemas: string[];
      displayName: string;
      members?: {
        value: string;
      }[];
    },
  ): Promise<ScimEnterpriseGroup> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/scim/v2/enterprises/{enterprise}/Groups', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/scim-enterprise-group"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminGetProvisioningInformationForEnterpriseGroup(params: {
    enterprise: string;
    scim_group_id: string;
    excludedAttributes?: string;
  }): Promise<ScimEnterpriseGroup> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.excludedAttributes !== undefined)
      requestContext.setQueryParam(
        'excludedAttributes',
        r.serializeParameter(params.excludedAttributes),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/scim-enterprise-group"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminSetInformationForProvisionedEnterpriseGroup(
    params: {
      enterprise: string;
      scim_group_id: string;
    },
    body: {
      schemas: string[];
      displayName: string;
      members?: {
        value: string;
      }[];
    },
  ): Promise<ScimEnterpriseGroup> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/scim-enterprise-group"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminUpdateAttributeForEnterpriseGroup(
    params: {
      enterprise: string;
      scim_group_id: string;
    },
    body: {
      schemas: string[];
      Operations: {
        op: 'add' | 'Add' | 'remove' | 'Remove' | 'replace' | 'Replace';
        path?: string;
        value?: string | any | any[];
      }[];
    },
  ): Promise<ScimEnterpriseGroup> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/scim-enterprise-group"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminDeleteScimGroupFromEnterprise(params: {
    enterprise: string;
    scim_group_id: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminListProvisionedIdentitiesEnterprise(params: {
    enterprise: string;
    startIndex?: number;
    count?: number;
    filter?: string;
  }): Promise<ScimUserListEnterprise> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/scim/v2/enterprises/{enterprise}/Users', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.startIndex !== undefined)
      requestContext.setQueryParam(
        'startIndex',
        r.serializeParameter(params.startIndex),
      );
    if (params.count !== undefined)
      requestContext.setQueryParam('count', r.serializeParameter(params.count));
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/scim-user-list-enterprise"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminProvisionAndInviteEnterpriseUser(
    params: {
      enterprise: string;
    },
    body: {
      schemas: string[];
      userName: string;
      name: {
        givenName: string;
        familyName: string;
      };
      emails: {
        value: string;
        type: string;
        primary: boolean;
      }[];
      groups?: {
        value?: string;
      }[];
    },
  ): Promise<ScimEnterpriseUser> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/scim/v2/enterprises/{enterprise}/Users', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/scim-enterprise-user"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminGetProvisioningInformationForEnterpriseUser(params: {
    enterprise: string;
    scim_user_id: string;
  }): Promise<ScimEnterpriseUser> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/scim-enterprise-user"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminSetInformationForProvisionedEnterpriseUser(
    params: {
      enterprise: string;
      scim_user_id: string;
    },
    body: {
      schemas: string[];
      userName: string;
      name: {
        givenName: string;
        familyName: string;
      };
      emails: {
        value: string;
        type: string;
        primary: boolean;
      }[];
      groups?: {
        value?: string;
      }[];
    },
  ): Promise<ScimEnterpriseUser> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/scim-enterprise-user"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminUpdateAttributeForEnterpriseUser(
    params: {
      enterprise: string;
      scim_user_id: string;
    },
    body: {
      schemas: string[];
      Operations: any[];
    },
  ): Promise<ScimEnterpriseUser> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/scim-enterprise-user"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async enterpriseAdminDeleteUserFromEnterprise(params: {
    enterprise: string;
    scim_user_id: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async scimListProvisionedIdentities(params: {
    org: string;
    startIndex?: number;
    count?: number;
    filter?: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/scim/v2/organizations/{org}/Users', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.startIndex !== undefined)
      requestContext.setQueryParam(
        'startIndex',
        r.serializeParameter(params.startIndex),
      );
    if (params.count !== undefined)
      requestContext.setQueryParam('count', r.serializeParameter(params.count));
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('400', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async scimProvisionAndInviteUser(
    params: {
      org: string;
    },
    body: {
      userName: string;
      displayName?: string;
      name: {
        givenName: string;
        familyName: string;
        formatted?: string;
      };
      emails: {
        value: string;
        primary?: boolean;
        type?: string;
      }[];
      schemas?: string[];
      externalId?: string;
      groups?: string[];
      active?: boolean;
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/scim/v2/organizations/{org}/Users', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('400', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('500', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async scimGetProvisioningInformationForUser(params: {
    org: string;
    scim_user_id: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/organizations/{org}/Users/{scim_user_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async scimSetInformationForProvisionedUser(
    params: {
      org: string;
      scim_user_id: string;
    },
    body: {
      schemas?: string[];
      displayName?: string;
      externalId?: string;
      groups?: string[];
      active?: boolean;
      userName: string;
      name: {
        givenName: string;
        familyName: string;
        formatted?: string;
      };
      emails: {
        type?: string;
        value: string;
        primary?: boolean;
      }[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/organizations/{org}/Users/{scim_user_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async scimUpdateAttributeForUser(
    params: {
      org: string;
      scim_user_id: string;
    },
    body: {
      schemas?: string[];
      Operations: {
        op: 'add' | 'remove' | 'replace';
        path?: string;
        value?:
          | {
              active?: boolean | null;
              userName?: string | null;
              externalId?: string | null;
              givenName?: string | null;
              familyName?: string | null;
            }
          | {
              value?: string;
              primary?: boolean;
            }[]
          | string;
      }[];
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/organizations/{org}/Users/{scim_user_id}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('400', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('429', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async scimDeleteUserFromOrg(params: {
    org: string;
    scim_user_id: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/scim/v2/organizations/{org}/Users/{scim_user_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<ScimError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/scim-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async searchCode(params: {
    q: string;
    sort?: 'indexed';
    order?: 'desc' | 'asc';
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    incomplete_results: boolean;
    items: CodeSearchResultItem[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/search/code', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.q !== undefined)
      requestContext.setQueryParam('q', r.serializeParameter(params.q));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.order !== undefined)
      requestContext.setQueryParam('order', r.serializeParameter(params.order));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","incomplete_results","items"],"properties":{"total_count":{"type":"integer"},"incomplete_results":{"type":"boolean"},"items":{"type":"array","items":{"$ref":"#/components/schemas/code-search-result-item"}}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async searchCommits(params: {
    q: string;
    sort?: 'author-date' | 'committer-date';
    order?: 'desc' | 'asc';
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    incomplete_results: boolean;
    items: CommitSearchResultItem[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/search/commits', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.q !== undefined)
      requestContext.setQueryParam('q', r.serializeParameter(params.q));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.order !== undefined)
      requestContext.setQueryParam('order', r.serializeParameter(params.order));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","incomplete_results","items"],"properties":{"total_count":{"type":"integer"},"incomplete_results":{"type":"boolean"},"items":{"type":"array","items":{"$ref":"#/components/schemas/commit-search-result-item"}}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async searchIssuesAndPullRequests(params: {
    q: string;
    sort?:
      | 'comments'
      | 'reactions'
      | 'reactions-+1'
      | 'reactions--1'
      | 'reactions-smile'
      | 'reactions-thinking_face'
      | 'reactions-heart'
      | 'reactions-tada'
      | 'interactions'
      | 'created'
      | 'updated';
    order?: 'desc' | 'asc';
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    incomplete_results: boolean;
    items: IssueSearchResultItem[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/search/issues', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.q !== undefined)
      requestContext.setQueryParam('q', r.serializeParameter(params.q));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.order !== undefined)
      requestContext.setQueryParam('order', r.serializeParameter(params.order));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","incomplete_results","items"],"properties":{"total_count":{"type":"integer"},"incomplete_results":{"type":"boolean"},"items":{"type":"array","items":{"$ref":"#/components/schemas/issue-search-result-item"}}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async searchLabels(params: {
    repository_id: number;
    q: string;
    sort?: 'created' | 'updated';
    order?: 'desc' | 'asc';
  }): Promise<{
    total_count: number;
    incomplete_results: boolean;
    items: LabelSearchResultItem[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/search/labels', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.repository_id !== undefined)
      requestContext.setQueryParam(
        'repository_id',
        r.serializeParameter(params.repository_id),
      );
    if (params.q !== undefined)
      requestContext.setQueryParam('q', r.serializeParameter(params.q));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.order !== undefined)
      requestContext.setQueryParam('order', r.serializeParameter(params.order));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","incomplete_results","items"],"properties":{"total_count":{"type":"integer"},"incomplete_results":{"type":"boolean"},"items":{"type":"array","items":{"$ref":"#/components/schemas/label-search-result-item"}}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async searchRepos(params: {
    q: string;
    sort?: 'stars' | 'forks' | 'help-wanted-issues' | 'updated';
    order?: 'desc' | 'asc';
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    incomplete_results: boolean;
    items: RepoSearchResultItem[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/search/repositories', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.q !== undefined)
      requestContext.setQueryParam('q', r.serializeParameter(params.q));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.order !== undefined)
      requestContext.setQueryParam('order', r.serializeParameter(params.order));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","incomplete_results","items"],"properties":{"total_count":{"type":"integer"},"incomplete_results":{"type":"boolean"},"items":{"type":"array","items":{"$ref":"#/components/schemas/repo-search-result-item"}}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async searchTopics(params: {
    q: string;
  }): Promise<{
    total_count: number;
    incomplete_results: boolean;
    items: TopicSearchResultItem[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/search/topics', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.q !== undefined)
      requestContext.setQueryParam('q', r.serializeParameter(params.q));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","incomplete_results","items"],"properties":{"total_count":{"type":"integer"},"incomplete_results":{"type":"boolean"},"items":{"type":"array","items":{"$ref":"#/components/schemas/topic-search-result-item"}}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async searchUsers(params: {
    q: string;
    sort?: 'followers' | 'repositories' | 'joined';
    order?: 'desc' | 'asc';
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    incomplete_results: boolean;
    items: UserSearchResultItem[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/search/users', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.q !== undefined)
      requestContext.setQueryParam('q', r.serializeParameter(params.q));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.order !== undefined)
      requestContext.setQueryParam('order', r.serializeParameter(params.order));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","incomplete_results","items"],"properties":{"total_count":{"type":"integer"},"incomplete_results":{"type":"boolean"},"items":{"type":"array","items":{"$ref":"#/components/schemas/user-search-result-item"}}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('503', response.httpStatusCode))
      throw new r.ApiException<{
        code?: string;
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"code":{"type":"string"},"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsGetLegacy(params: { team_id: number }): Promise<TeamFull> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-full"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsUpdateLegacy(
    params: {
      team_id: number;
    },
    body: {
      name: string;
      description?: string;
      privacy?: 'secret' | 'closed';
      permission?: 'pull' | 'push' | 'admin';
      parent_team_id?: number | null;
    },
  ): Promise<TeamFull> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-full"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsDeleteLegacy(params: { team_id: number }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListDiscussionsLegacy(params: {
    team_id: number;
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<TeamDiscussion[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/discussions', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team-discussion"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCreateDiscussionLegacy(
    params: {
      team_id: number;
    },
    body: {
      title: string;
      body: string;
      private?: boolean;
    },
  ): Promise<TeamDiscussion> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/discussions', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsGetDiscussionLegacy(params: {
    team_id: number;
    discussion_number: number;
  }): Promise<TeamDiscussion> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsUpdateDiscussionLegacy(
    params: {
      team_id: number;
      discussion_number: number;
    },
    body: {
      title?: string;
      body?: string;
    },
  ): Promise<TeamDiscussion> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsDeleteDiscussionLegacy(params: {
    team_id: number;
    discussion_number: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListDiscussionCommentsLegacy(params: {
    team_id: number;
    discussion_number: number;
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<TeamDiscussionComment[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}/comments',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team-discussion-comment"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCreateDiscussionCommentLegacy(
    params: {
      team_id: number;
      discussion_number: number;
    },
    body: {
      body: string;
    },
  ): Promise<TeamDiscussionComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}/comments',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion-comment"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsGetDiscussionCommentLegacy(params: {
    team_id: number;
    discussion_number: number;
    comment_number: number;
  }): Promise<TeamDiscussionComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion-comment"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsUpdateDiscussionCommentLegacy(
    params: {
      team_id: number;
      discussion_number: number;
      comment_number: number;
    },
    body: {
      body: string;
    },
  ): Promise<TeamDiscussionComment> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}',
        params,
      ),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-discussion-comment"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsDeleteDiscussionCommentLegacy(params: {
    team_id: number;
    discussion_number: number;
    comment_number: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsListForTeamDiscussionCommentLegacy(params: {
    team_id: number;
    discussion_number: number;
    comment_number: number;
    content?:
      | '+1'
      | '-1'
      | 'laugh'
      | 'confused'
      | 'heart'
      | 'hooray'
      | 'rocket'
      | 'eyes';
    per_page?: number;
    page?: number;
  }): Promise<Reaction[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.content !== undefined)
      requestContext.setQueryParam(
        'content',
        r.serializeParameter(params.content),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/reaction"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsCreateForTeamDiscussionCommentLegacy(
    params: {
      team_id: number;
      discussion_number: number;
      comment_number: number;
    },
    body: {
      content:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
    },
  ): Promise<Reaction> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsListForTeamDiscussionLegacy(params: {
    team_id: number;
    discussion_number: number;
    content?:
      | '+1'
      | '-1'
      | 'laugh'
      | 'confused'
      | 'heart'
      | 'hooray'
      | 'rocket'
      | 'eyes';
    per_page?: number;
    page?: number;
  }): Promise<Reaction[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}/reactions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.content !== undefined)
      requestContext.setQueryParam(
        'content',
        r.serializeParameter(params.content),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/reaction"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reactionsCreateForTeamDiscussionLegacy(
    params: {
      team_id: number;
      discussion_number: number;
    },
    body: {
      content:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
    },
  ): Promise<Reaction> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/teams/{team_id}/discussions/{discussion_number}/reactions',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/reaction"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListPendingInvitationsLegacy(params: {
    team_id: number;
    per_page?: number;
    page?: number;
  }): Promise<OrganizationInvitation[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/invitations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/organization-invitation"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListMembersLegacy(params: {
    team_id: number;
    role?: 'member' | 'maintainer' | 'all';
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/members', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.role !== undefined)
      requestContext.setQueryParam('role', r.serializeParameter(params.role));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsGetMemberLegacy(params: {
    team_id: number;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/members/{username}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsAddMemberLegacy(params: {
    team_id: number;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/members/{username}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        errors?: {
          code?: string;
          field?: string;
          resource?: string;
        }[];
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"errors":{"type":"array","items":{"type":"object","properties":{"code":{"type":"string"},"field":{"type":"string"},"resource":{"type":"string"}}}},"documentation_url":{"type":"string","example":"\\"https://docs.github.com/rest\\""}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsRemoveMemberLegacy(params: {
    team_id: number;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/members/{username}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsGetMembershipForUserLegacy(params: {
    team_id: number;
    username: string;
  }): Promise<TeamMembership> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/memberships/{username}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-membership"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsAddOrUpdateMembershipForUserLegacy(
    params: {
      team_id: number;
      username: string;
    },
    body: {
      role?: 'member' | 'maintainer';
    },
  ): Promise<TeamMembership> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/memberships/{username}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-membership"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        errors?: {
          code?: string;
          field?: string;
          resource?: string;
        }[];
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"errors":{"type":"array","items":{"type":"object","properties":{"code":{"type":"string"},"field":{"type":"string"},"resource":{"type":"string"}}}},"documentation_url":{"type":"string","example":"\\"https://help.github.com/articles/github-and-trade-controls\\""}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsRemoveMembershipForUserLegacy(params: {
    team_id: number;
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/memberships/{username}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListProjectsLegacy(params: {
    team_id: number;
    per_page?: number;
    page?: number;
  }): Promise<TeamProject[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/projects', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team-project"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCheckPermissionsForProjectLegacy(params: {
    team_id: number;
    project_id: number;
  }): Promise<TeamProject> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/projects/{project_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/team-project"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsAddOrUpdateProjectPermissionsLegacy(
    params: {
      team_id: number;
      project_id: number;
    },
    body: {
      permission?: 'read' | 'write' | 'admin';
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/projects/{project_id}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<{
        message?: string;
        documentation_url?: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsRemoveProjectLegacy(params: {
    team_id: number;
    project_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/projects/{project_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListReposLegacy(params: {
    team_id: number;
    per_page?: number;
    page?: number;
  }): Promise<MinimalRepository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/repos', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCheckPermissionsForRepoLegacy(params: {
    team_id: number;
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/repos/{owner}/{repo}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('204', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsAddOrUpdateRepoPermissionsLegacy(
    params: {
      team_id: number;
      owner: string;
      repo: string;
    },
    body: {
      permission?: 'pull' | 'push' | 'admin';
    },
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/repos/{owner}/{repo}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsRemoveRepoLegacy(params: {
    team_id: number;
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/repos/{owner}/{repo}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListIdpGroupsForLegacy(params: {
    team_id: number;
  }): Promise<GroupMapping> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/team-sync/group-mappings', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/group-mapping"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsCreateOrUpdateIdpGroupConnectionsLegacy(
    params: {
      team_id: number;
    },
    body: {
      groups: {
        group_id: string;
        group_name: string;
        group_description: string;
        id?: string;
        name?: string;
        description?: string;
      }[];
      synced_at?: string;
    },
  ): Promise<GroupMapping> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/team-sync/group-mappings', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/group-mapping"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListChildLegacy(params: {
    team_id: number;
    per_page?: number;
    page?: number;
  }): Promise<Team[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/teams/{team_id}/teams', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersGetAuthenticated(params: {}): Promise<PrivateUser | PublicUser> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"oneOf":[{"$ref":"#/components/schemas/private-user"},{"$ref":"#/components/schemas/public-user"}]}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersUpdateAuthenticated(
    params: {},
    body: {
      name?: string;
      email?: string;
      blog?: string;
      twitter_username?: string | null;
      company?: string;
      location?: string;
      hireable?: boolean;
      bio?: string;
    },
  ): Promise<PrivateUser> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/private-user"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListBlockedByAuthenticated(params: {}): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/blocks', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersCheckBlocked(params: { username: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/blocks/{username}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersBlock(params: { username: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/blocks/{username}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersUnblock(params: { username: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/blocks/{username}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersSetPrimaryEmailVisibilityForAuthenticated(
    params: {},
    body: {
      email: string;
      visibility: 'public' | 'private';
    },
  ): Promise<Email[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/email/visibility', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/email"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListEmailsForAuthenticated(params: {
    per_page?: number;
    page?: number;
  }): Promise<Email[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/emails', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/email"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersAddEmailForAuthenticated(
    params: {},
    body:
      | {
          emails: string[];
        }
      | string[]
      | string,
  ): Promise<Email[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/emails', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/email"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersDeleteEmailForAuthenticated(
    params: {},
    body:
      | {
          emails: string[];
        }
      | string[]
      | string,
  ): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/emails', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListFollowersForAuthenticatedUser(params: {
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/followers', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListFollowedByAuthenticated(params: {
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/following', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersCheckPersonIsFollowedByAuthenticated(params: {
    username: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/following/{username}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersFollow(params: { username: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/following/{username}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersUnfollow(params: { username: string }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/following/{username}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListGpgKeysForAuthenticated(params: {
    per_page?: number;
    page?: number;
  }): Promise<GpgKey[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/gpg_keys', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/gpg-key"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersCreateGpgKeyForAuthenticated(
    params: {},
    body: {
      armored_public_key: string;
    },
  ): Promise<GpgKey> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/gpg_keys', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/gpg-key"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersGetGpgKeyForAuthenticated(params: {
    gpg_key_id: number;
  }): Promise<GpgKey> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/gpg_keys/{gpg_key_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/gpg-key"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersDeleteGpgKeyForAuthenticated(params: {
    gpg_key_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/gpg_keys/{gpg_key_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsListInstallationsForAuthenticatedUser(params: {
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    installations: Installation[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/installations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","installations"],"properties":{"total_count":{"type":"integer"},"installations":{"type":"array","items":{"$ref":"#/components/schemas/installation"}}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsListInstallationReposForAuthenticatedUser(params: {
    installation_id: number;
    per_page?: number;
    page?: number;
  }): Promise<{
    total_count: number;
    repository_selection?: string;
    repositories: Repository[];
  }> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/user/installations/{installation_id}/repositories',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"object","required":["total_count","repositories"],"properties":{"total_count":{"type":"integer"},"repository_selection":{"type":"string"},"repositories":{"type":"array","items":{"$ref":"#/components/schemas/repository"}}}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsAddRepoToInstallation(params: {
    installation_id: number;
    repository_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/user/installations/{installation_id}/repositories/{repository_id}',
        params,
      ),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsRemoveRepoFromInstallation(params: {
    installation_id: number;
    repository_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/user/installations/{installation_id}/repositories/{repository_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async interactionsGetRestrictionsForAuthenticatedUser(params: {}): Promise<InteractionLimitResponse> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/interaction-limits', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/interaction-limit-response"}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async interactionsSetRestrictionsForAuthenticatedUser(
    params: {},
    body: InteractionLimit,
  ): Promise<InteractionLimitResponse> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/interaction-limits', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"$ref":"#/components/schemas/interaction-limit-response"}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async interactionsRemoveRestrictionsForAuthenticatedUser(params: {}): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/interaction-limits', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async issuesListForAuthenticatedUser(params: {
    filter?:
      | 'assigned'
      | 'created'
      | 'mentioned'
      | 'subscribed'
      | 'repos'
      | 'all';
    state?: 'open' | 'closed' | 'all';
    labels?: string;
    sort?: 'created' | 'updated' | 'comments';
    direction?: 'asc' | 'desc';
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<Issue[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/issues', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.filter !== undefined)
      requestContext.setQueryParam(
        'filter',
        r.serializeParameter(params.filter),
      );
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.labels !== undefined)
      requestContext.setQueryParam(
        'labels',
        r.serializeParameter(params.labels),
      );
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/issue"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListPublicSshKeysForAuthenticated(params: {
    per_page?: number;
    page?: number;
  }): Promise<Key[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/keys', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/key"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersCreatePublicSshKeyForAuthenticated(
    params: {},
    body: {
      title?: string;
      key: string;
    },
  ): Promise<Key> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/keys', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/key"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersGetPublicSshKeyForAuthenticated(params: {
    key_id: number;
  }): Promise<Key> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/keys/{key_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/key"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersDeletePublicSshKeyForAuthenticated(params: {
    key_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/keys/{key_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsListSubscriptionsForAuthenticatedUser(params: {
    per_page?: number;
    page?: number;
  }): Promise<UserMarketplacePurchase[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/marketplace_purchases', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/user-marketplace-purchase"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsListSubscriptionsForAuthenticatedUserStubbed(params: {
    per_page?: number;
    page?: number;
  }): Promise<UserMarketplacePurchase[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/marketplace_purchases/stubbed', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/user-marketplace-purchase"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListMembershipsForAuthenticatedUser(params: {
    state?: 'active' | 'pending';
    per_page?: number;
    page?: number;
  }): Promise<OrgMembership[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/memberships/orgs', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/org-membership"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsGetMembershipForAuthenticatedUser(params: {
    org: string;
  }): Promise<OrgMembership> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/memberships/orgs/{org}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/org-membership"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsUpdateMembershipForAuthenticatedUser(
    params: {
      org: string;
    },
    body: {
      state: 'active';
    },
  ): Promise<OrgMembership> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/memberships/orgs/{org}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/org-membership"}'),
        this.resolver,
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsListForAuthenticatedUser(params: {
    per_page?: number;
    page?: number;
  }): Promise<Migration[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/migrations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/migration"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsStartForAuthenticatedUser(
    params: {},
    body: {
      lock_repositories?: boolean;
      exclude_attachments?: boolean;
      exclude?: 'repositories'[];
      repositories: string[];
    },
  ): Promise<Migration> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/migrations', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/migration"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsGetStatusForAuthenticatedUser(params: {
    migration_id: number;
    exclude?: string[];
  }): Promise<Migration> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/migrations/{migration_id}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.exclude !== undefined)
      requestContext.setQueryParam(
        'exclude',
        r.serializeParameter(params.exclude),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/migration"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsGetArchiveForAuthenticatedUser(params: {
    migration_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/migrations/{migration_id}/archive', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('302', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsDeleteArchiveForAuthenticatedUser(params: {
    migration_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/migrations/{migration_id}/archive', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsUnlockRepoForAuthenticatedUser(params: {
    migration_id: number;
    repo_name: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/user/migrations/{migration_id}/repos/{repo_name}/lock',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async migrationsListReposForUser(params: {
    migration_id: number;
    per_page?: number;
    page?: number;
  }): Promise<MinimalRepository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/migrations/{migration_id}/repositories', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListForAuthenticatedUser(params: {
    per_page?: number;
    page?: number;
  }): Promise<OrganizationSimple[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/orgs', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/organization-simple"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesGetPackageForAuthenticatedUser(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
  }): Promise<Package> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/packages/{package_type}/{package_name}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/package"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesDeletePackageForAuthenticatedUser(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/packages/{package_type}/{package_name}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesRestorePackageForAuthenticatedUser(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    token?: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/user/packages/{package_type}/{package_name}/restore',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.token !== undefined)
      requestContext.setQueryParam('token', r.serializeParameter(params.token));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    page?: number;
    per_page?: number;
    state?: 'active' | 'deleted';
  }): Promise<PackageVersion[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/user/packages/{package_type}/{package_name}/versions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/package-version"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesGetPackageVersionForAuthenticatedUser(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    package_version_id: number;
  }): Promise<PackageVersion> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/user/packages/{package_type}/{package_name}/versions/{package_version_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/package-version"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesDeletePackageVersionForAuthenticatedUser(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    package_version_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/user/packages/{package_type}/{package_name}/versions/{package_version_id}',
        params,
      ),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesRestorePackageVersionForAuthenticatedUser(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    package_version_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore',
        params,
      ),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsCreateForAuthenticatedUser(
    params: {},
    body: {
      name: string;
      body?: string | null;
    },
  ): Promise<Project> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/projects', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/project"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationErrorSimple>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error-simple"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListPublicEmailsForAuthenticated(params: {
    per_page?: number;
    page?: number;
  }): Promise<Email[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/public_emails', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/email"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListForAuthenticatedUser(params: {
    visibility?: 'all' | 'public' | 'private';
    affiliation?: string;
    type?: 'all' | 'owner' | 'public' | 'private' | 'member';
    sort?: 'created' | 'updated' | 'pushed' | 'full_name';
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
    since?: string;
    before?: string;
  }): Promise<Repository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/repos', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.visibility !== undefined)
      requestContext.setQueryParam(
        'visibility',
        r.serializeParameter(params.visibility),
      );
    if (params.affiliation !== undefined)
      requestContext.setQueryParam(
        'affiliation',
        r.serializeParameter(params.affiliation),
      );
    if (params.type !== undefined)
      requestContext.setQueryParam('type', r.serializeParameter(params.type));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.before !== undefined)
      requestContext.setQueryParam(
        'before',
        r.serializeParameter(params.before),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/repository"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposCreateForAuthenticatedUser(
    params: {},
    body: {
      name: string;
      description?: string;
      homepage?: string;
      private?: boolean;
      has_issues?: boolean;
      has_projects?: boolean;
      has_wiki?: boolean;
      team_id?: number;
      auto_init?: boolean;
      gitignore_template?: string;
      license_template?: string;
      allow_squash_merge?: boolean;
      allow_merge_commit?: boolean;
      allow_rebase_merge?: boolean;
      delete_branch_on_merge?: boolean;
      has_downloads?: boolean;
      is_template?: boolean;
    },
  ): Promise<Repository> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/repos', params),
      r.HttpMethod.POST,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    requestContext.setBody(JSON.stringify(body));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('201', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/repository"}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('400', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListInvitationsForAuthenticatedUser(params: {
    per_page?: number;
    page?: number;
  }): Promise<RepositoryInvitation[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/repository_invitations', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/repository-invitation"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposAcceptInvitation(params: { invitation_id: number }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/repository_invitations/{invitation_id}', params),
      r.HttpMethod.PATCH,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposDeclineInvitation(params: {
    invitation_id: number;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/repository_invitations/{invitation_id}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('409', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListReposStarredByAuthenticatedUser(params: {
    sort?: 'created' | 'updated';
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<Repository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/starred', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/repository"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityCheckRepoIsStarredByAuthenticatedUser(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/starred/{owner}/{repo}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityStarRepoForAuthenticatedUser(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/starred/{owner}/{repo}', params),
      r.HttpMethod.PUT,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityUnstarRepoForAuthenticatedUser(params: {
    owner: string;
    repo: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/starred/{owner}/{repo}', params),
      r.HttpMethod.DELETE,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListWatchedReposForAuthenticatedUser(params: {
    per_page?: number;
    page?: number;
  }): Promise<MinimalRepository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/subscriptions', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async teamsListForAuthenticatedUser(params: {
    per_page?: number;
    page?: number;
  }): Promise<TeamFull[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/user/teams', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/team-full"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersList(params: {
    since?: number;
    per_page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('304', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersGetByUsername(params: {
    username: string;
  }): Promise<PrivateUser | PublicUser> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"oneOf":[{"$ref":"#/components/schemas/private-user"},{"$ref":"#/components/schemas/public-user"}]}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListEventsForAuthenticatedUser(params: {
    username: string;
    per_page?: number;
    page?: number;
  }): Promise<Event[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/events', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/event"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListOrgEventsForAuthenticatedUser(params: {
    username: string;
    org: string;
    per_page?: number;
    page?: number;
  }): Promise<Event[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/events/orgs/{org}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/event"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListPublicEventsForUser(params: {
    username: string;
    per_page?: number;
    page?: number;
  }): Promise<Event[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/events/public', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/event"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListFollowersForUser(params: {
    username: string;
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/followers', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListFollowingForUser(params: {
    username: string;
    per_page?: number;
    page?: number;
  }): Promise<SimpleUser[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/following', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/simple-user"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersCheckFollowingForUser(params: {
    username: string;
    target_user: string;
  }): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/following/{target_user}', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('204', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<any>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async gistsListForUser(params: {
    username: string;
    since?: string;
    per_page?: number;
    page?: number;
  }): Promise<BaseGist[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/gists', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.since !== undefined)
      requestContext.setQueryParam('since', r.serializeParameter(params.since));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/base-gist"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListGpgKeysForUser(params: {
    username: string;
    per_page?: number;
    page?: number;
  }): Promise<GpgKey[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/gpg_keys', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/gpg-key"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersGetContextForUser(params: {
    username: string;
    subject_type?: 'organization' | 'repository' | 'issue' | 'pull_request';
    subject_id?: string;
  }): Promise<Hovercard> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/hovercard', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.subject_type !== undefined)
      requestContext.setQueryParam(
        'subject_type',
        r.serializeParameter(params.subject_type),
      );
    if (params.subject_id !== undefined)
      requestContext.setQueryParam(
        'subject_id',
        r.serializeParameter(params.subject_id),
      );
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/hovercard"}'),
        this.resolver,
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async appsGetUserInstallation(params: {
    username: string;
  }): Promise<Installation> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/installation', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/installation"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async usersListPublicKeysForUser(params: {
    username: string;
    per_page?: number;
    page?: number;
  }): Promise<KeySimple[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/keys', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/key-simple"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async orgsListForUser(params: {
    username: string;
    per_page?: number;
    page?: number;
  }): Promise<OrganizationSimple[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/orgs', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/organization-simple"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesGetPackageForUser(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    username: string;
  }): Promise<Package> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/users/{username}/packages/{package_type}/{package_name}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/package"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesGetAllPackageVersionsForPackageOwnedByUser(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    username: string;
  }): Promise<PackageVersion[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/users/{username}/packages/{package_type}/{package_name}/versions',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/package-version"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('401', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('403', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('404', response.httpStatusCode))
      throw new r.ApiException<BasicError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/basic-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async packagesGetPackageVersionForUser(params: {
    package_type:
      | 'npm'
      | 'maven'
      | 'rubygems'
      | 'docker'
      | 'nuget'
      | 'container';
    package_name: string;
    package_version_id: number;
    username: string;
  }): Promise<PackageVersion> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/package-version"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async projectsListForUser(params: {
    username: string;
    state?: 'open' | 'closed' | 'all';
    per_page?: number;
    page?: number;
  }): Promise<Project[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/projects', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.state !== undefined)
      requestContext.setQueryParam('state', r.serializeParameter(params.state));
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/project"}}',
        ),
        this.resolver,
      );
    if (r.isCodeInRange('415', response.httpStatusCode))
      throw new r.ApiException<{
        message: string;
        documentation_url: string;
      }>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse(
            '{"type":"object","required":["message","documentation_url"],"properties":{"message":{"type":"string"},"documentation_url":{"type":"string"}}}',
          ),
          this.resolver,
        ),
      );
    if (r.isCodeInRange('422', response.httpStatusCode))
      throw new r.ApiException<ValidationError>(
        response.httpStatusCode,
        r.applyTransforms(
          await response.body.json(),
          JSON.parse('{"$ref":"#/components/schemas/validation-error"}'),
          this.resolver,
        ),
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListReceivedEventsForUser(params: {
    username: string;
    per_page?: number;
    page?: number;
  }): Promise<Event[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/received_events', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/event"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListReceivedPublicEventsForUser(params: {
    username: string;
    per_page?: number;
    page?: number;
  }): Promise<Event[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/received_events/public', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/event"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async reposListForUser(params: {
    username: string;
    type?: 'all' | 'owner' | 'member';
    sort?: 'created' | 'updated' | 'pushed' | 'full_name';
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<MinimalRepository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/repos', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.type !== undefined)
      requestContext.setQueryParam('type', r.serializeParameter(params.type));
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async billingGetGithubActionsBillingUser(params: {
    username: string;
  }): Promise<ActionsBillingUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/settings/billing/actions', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/actions-billing-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async billingGetGithubPackagesBillingUser(params: {
    username: string;
  }): Promise<PackagesBillingUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/settings/billing/packages', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/packages-billing-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async billingGetSharedStorageBillingUser(params: {
    username: string;
  }): Promise<CombinedBillingUsage> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating(
        '/users/{username}/settings/billing/shared-storage',
        params,
      ),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{"$ref":"#/components/schemas/combined-billing-usage"}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListReposStarredByUser(params: {
    username: string;
    sort?: 'created' | 'updated';
    direction?: 'asc' | 'desc';
    per_page?: number;
    page?: number;
  }): Promise<Repository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/starred', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.sort !== undefined)
      requestContext.setQueryParam('sort', r.serializeParameter(params.sort));
    if (params.direction !== undefined)
      requestContext.setQueryParam(
        'direction',
        r.serializeParameter(params.direction),
      );
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/repository"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async activityListReposWatchedByUser(params: {
    username: string;
    per_page?: number;
    page?: number;
  }): Promise<MinimalRepository[]> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/users/{username}/subscriptions', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    if (params.per_page !== undefined)
      requestContext.setQueryParam(
        'per_page',
        r.serializeParameter(params.per_page),
      );
    if (params.page !== undefined)
      requestContext.setQueryParam('page', r.serializeParameter(params.page));
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse(
          '{"type":"array","items":{"$ref":"#/components/schemas/minimal-repository"}}',
        ),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
  async metaGetZen(params: {}): Promise<any> {
    const requestContext = this.server.makeRequestContext(
      r.applyTemplating('/zen', params),
      r.HttpMethod.GET,
    );
    requestContext.setHeaderParam('Content-Type', 'application/json');
    const response = await this.http.send(requestContext);
    if (r.isCodeInRange('200', response.httpStatusCode))
      return r.applyTransforms(
        await response.body.json(),
        JSON.parse('{}'),
        this.resolver,
      );
    throw new r.ApiException<string>(
      response.httpStatusCode,
      'Unknown API Status Code!',
    );
  }
}
